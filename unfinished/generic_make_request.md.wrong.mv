---
title:  generic_make_request
date: '2017-01-04'
tags: [tag_null_yet]
categories: I/O
---

linux-3.10.86/block/blk-core.c

先断章取义下:

```c
void generic_make_request(struct bio *bio)
{

	bio_list_init(&bio_list_on_stack);
	current->bio_list = &bio_list_on_stack;
	...
		/*
		从这里来看, q->make_request_fn()可能会往current->bio_list中添加bio,
		否则, 从哪里pop呢?
		*/
	q->make_request_fn(q, bio);
	bio = bio_list_pop(current->bio_list);
	...
}
```
上面的猜想是片面的, 还是来个全貌的:


```c
void generic_make_request(struct bio *bio)
{
	struct bio_list bio_list_on_stack;

	if (!generic_make_request_checks(bio))
		return;

	if (current->bio_list) {
		bio_list_add(current->bio_list, bio);
		return;
	}

	BUG_ON(bio->bi_next);
	bio_list_init(&bio_list_on_stack);
	current->bio_list = &bio_list_on_stack;
	do {
		/*
		while再次执行时, q (struct request_queue *)可能和上次循环时的q不一样了,
		所以, 实现从一种设备到另一种设备的映射, 提交给新的块设备执行.
		*/
		struct request_queue *q = bdev_get_queue(bio->bi_bdev);
		q->make_request_fn(q, bio);
		/*
		从这里来看, q->make_request_fn()可能会往current->bio_list中添加bio,
		否则, 从哪里pop呢?
		当然也可以不往current->bio_list添加bio, 表示无需再经过转换了, 
		这样, while也就结束了.
		*/
		bio = bio_list_pop(current->bio_list);
	} while (bio);
	current->bio_list = NULL; /* deactivate */
}

```

假定经过1次转换, 那么, 调用大概是这样的:

	generic_make_request
	|-- q->make_request_fn
	|	|--...
	|	|--generic_make_request
	|	|	|--if (current->bio_list) {	bio_list_add(current->bio_list, bio); return; }
	|-- bio = bio_list_pop(current->bio_list);
	|-- q->make_request_fn(q, bio);
	|	|--no call generic_make_request
	|--return


无需转换是这样:
	
	generic_make_request
	|-- q->make_request_fn  比如为 blk_queue_bio
	|	|--no call generic_make_request
	|--return

	
