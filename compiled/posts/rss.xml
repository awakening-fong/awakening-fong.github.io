<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>HOMEPAGE</title>
    <description>HOMEPAGE</description>
    <link>https://awakening-fong.github.io</link>
    <pubDate>2017-02-06</pubDate>
    <item>
      <title>arm linux&#x7684;ASID (Address Space ID)</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_asid</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;
&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2; http://blog.163.com/awaken_ing/blog/static/1206131972015112011286335
&lt;/p&gt;

&lt;p&gt;&#x5E73;&#x53F0;:ARM Versatile Express for Cortex-A9 (ARMv7)&lt;br&gt;
 # CONFIG_ARM_LPAE is not set, &#x4E5F;&#x5C31;&#x662F;&#x4F7F;&#x7528;Short-descriptor&#x683C;&#x5F0F;, ASID&#x5B58;&#x50A8;&#x5728;CONTEXTIDR&#x7684;&#x4F4E;8 bit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;31                         7          0
+-------------------------+-----------+
|      PROCID             |   ASID    |
+-------------------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x9875;&#x8868;&#x9879;&#x4E2D; nG == 1&#x65F6;, &#x8FD9;&#x4E2A;&#x9875;&#x8868;&#x9879;&#x4FE1;&#x606F;&#x5C31;&#x662F; non-global, &#x6216;&#x8005;&#x8BF4; process-specific, &#x5BF9;&#x5E94;&#x7684;TLB&#x4E2D;&#x5C31;&#x4F1A;&#x6709;ASID&#x4FE1;&#x606F;, &#x6267;&#x884C;&#x865A;&#x62DF;&#x5730;&#x5740;&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;&#x8F6C;&#x6362;&#x65F6;, ASID&#x4E5F;&#x9700;&#x8981;&#x53C2;&#x4E0E;&#x8BE5;&#x8FC7;&#x7A0B;.&lt;/p&gt;

&lt;p&gt;&#x7528;&#x6237;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x7684;&#x9875;&#x8868;&#x624D;&#x4F1A;&#x8BBE;&#x7F6E;nG&#x6807;&#x5FD7; (&#x5185;&#x6838;&#x5730;&#x5740;&#x7684;&#x4E00;&#x90E8;&#x5206;&#x5730;&#x5740;&#x8303;&#x56F4;&#x4F7F;&#x7528;TLB lockdown&#x6BD4;&#x8F83;&#x5408;&#x9002;):
linux-3.10.86/arch/arm/include/asm/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void set_pte_at(struct mm_struct *mm, unsigned long addr, 
                  pte_t *ptep, pte_t pteval) 
{ 
...
    if (addr &amp;lt; TASK_SIZE &amp;amp;&amp;amp; pte_present_user(pteval)) { 
... 
        ext |= PTE_EXT_NG; 
    } 
... 
    set_pte_ext(ptep, pteval, ext); 
}

set_pte_at -&amp;gt; set_pte_ext -&amp;gt; cpu_v7_set_pte_ext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;arm linux&#x4E2D;&#x901A;&#x8FC7;&#x8BBE;&#x7F6E;CONTEXTIDR, &#x8FDB;&#x800C;&#x8BBE;&#x7F6E;ASID, &#x76F8;&#x5173;&#x4EE3;&#x7801;&#x4E3A;:
linux-3.10.86/arch/arm/mm/proc-v7-2level.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ENTRY(cpu_v7_switch_mm) 
... 
mcr    p15, 0, r1, c13, c0, 1        @ set context ID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8C03;&#x7528;&#x5173;&#x7CFB;&#x4E3A;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context_switch() -&amp;gt;switch_mm() -&amp;gt; check_and_switch_context(struct mm_struct *mm, struct task_struct *tsk) -&amp;gt; cpu_switch_mm() -&amp;gt; cpu_v7_switch_mm(pgd_t * pgd, struct mm_struct *mm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux&#x628A;ASID&#x5B58;&#x50A8;&#x5728;mm-&amp;gt;context.id&#x7684;&#x4F4E;8&#x4F4D; (D7:D0).&lt;/p&gt;

&lt;p&gt;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x975E;&#x5185;&#x6838;&#x7EBF;&#x7A0B; (&#x5185;&#x6838;&#x7EBF;&#x7A0B;&#x4E0D;&#x4F1A;&#x8C03;&#x7528;&#x5230;dup_mm), &#x521D;&#x59CB;&#x5316;ASID&#x4E3A;0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;copy_mm -&amp;gt; dup_mm -&amp;gt; init_new_context
#define init_new_context(tsk,mm)   ({ atomic64_set(&amp;amp;mm-&amp;gt;context.id, 0); 0; })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5230;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#x7684;&#x65F6;&#x5019;&#x624D;&#x771F;&#x6B63;&#x5F00;&#x59CB;&#x7ED9;ASID&#x8D4B;&#x503C;, &#x5E76;&#x8BBE;&#x7F6E;CONTEXTIDR&#x5BC4;&#x5B58;&#x5668;.&lt;/p&gt;

&lt;p&gt;&#x6709;&#x5206;&#x914D;, &#x5C31;&#x8BE5;&#x6709;&#x56DE;&#x6536;, &#x8FD9;&#x4E5F;&#x662F;&#x4F7F;&#x7528;bitmap&#x6765;&#x7BA1;&#x7406;ASID, &#x800C;&#x4E0D;&#x662F;asid++&#x7684;&#x65B9;&#x5F0F;&#x7684;&#x539F;&#x56E0;. ASID&#x7684;&#x5206;&#x914D;&#x662F;&#x901A;&#x8FC7;bitmap&#x53D8;&#x91CF;asid_map&#x6765;&#x8BB0;&#x5F55;&#x7684;. set bit&#x7684;&#x64CD;&#x4F5C;&#x5728;new_context()&#x4E2D;&#x53EF;&#x4EE5;&#x627E;&#x5230;. &#x67E5;&#x627E;&#x5BF9;&#x8BE5;&#x53D8;&#x91CF;&#x7684;clear bit&#x64CD;&#x4F5C;, &#x8FDB;&#x7A0B;&#x9000;&#x51FA;&#x65F6;, &#x672C;&#x5E94;&#x6709;&#x8BE5;&#x52A8;&#x4F5C;(&#x6E05;asid_map&#x4E2D;&#x8BE5;&#x8FDB;&#x7A0B;&#x6240;&#x5BF9;&#x5E94;&#x7684;bit), &#x4F46;&#x5F88;&#x9057;&#x61BE;, &#x6CA1;&#x6709;&#x627E;&#x5230;, &#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x5077;&#x61D2;&#x4E86;?&lt;/p&gt;

&lt;p&gt;&#x7531;&#x4E8E;ASID&#x53EA;&#x6709;8bit, &#x8303;&#x56F4;&#x4E3A;0~0xff, &#x5F53;&#x8FD9;&#x4E9B;&#x503C;&#x5206;&#x914D;&#x5B8C;&#x540E;, &#x5C31;&#x9700;&#x8981;flush TLB, &#x540C;&#x65F6;&#x5BF9;generation&#x52A0;1, &#x7136;&#x540E;&#x91CD;&#x65B0;&#x5F00;&#x59CB;&#x5206;&#x914D;ASID. generation&#x4E3A;mm-&amp;gt;context.id&#x7684;&#x9AD8;24+32&#x4F4D;(D63:D8), &#x8FD9;&#x6837;, &#x540E;&#x7EED;&#x518D;&#x8C03;&#x5EA6;&#x5230;&#x8FD9;&#x4E2A;&#x8FDB;&#x7A0B;&#x65F6;, &#x5C31;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5224;&#x65AD;generation&#x662F;&#x5426;&#x53D8;&#x5316;&#x4E86;, &#x6765;&#x77E5;&#x9053; mm-&amp;gt;context.id&#x4E2D;&#x7684;ASID&#x662F;&#x5426;&#x8FD8;&#x6709;&#x6548;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>&#x4E2D;&#x65AD;, softirq, tasklet&#x7684;&#x533A;&#x522B;</title>
      <link>https://awakening-fong.github.io/posts/arm/interrupt_softirq_in_arm</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4E2D;&#x65AD;&#x6D41;&#x7A0B;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5047;&#x5B9A; CONFIG_MULTI_IRQ_HANDLER=y, handle_arch_irq &#x4E3A; gic_handle_irq.&lt;br&gt;
linux-3.10.86/arch/arm/kernel/setup.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__irq_svc @entry-armv.S
|   |--svc_entry    &#x4FDD;&#x5B58;spsr_&amp;lt;exception&amp;gt; &#x5230;r5
|   |--irq_handler
|   |   |--handle_arch_irq =&amp;gt; gic_handle_irq
|   |   |   |--irq_find_mapping  &#x5B8C;&#x6210; an hw irq number&#x5230;a linux irq&#x7684;&#x8F6C;&#x6362;
|   |   |   |--handle_IRQ(irqnr, regs) if not IPI 
|   |   |   |       |--generic_handle_irq  -&amp;gt; generic_handle_irq_desc -&amp;gt; handle_fasteoi_irq
|   |   |   |       |   |--raw_spin_lock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |   |--handle_irq_event
|   |   |   |       |   |   |--raw_spin_unlock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |   |   |--handle_irq_event_percpu -&amp;gt; action-&amp;gt;handler
|   |   |   |       |   |   |--raw_spin_lock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |   |--chip-&amp;gt;irq_eoi
|   |   |   |       |   |--raw_spin_unlock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |--irq_exit();  &#x8FD9;&#x91CC;&#x4E2D;&#x65AD;&#x8FD8;&#x662F;&#x7981;&#x7528;&#x7684;&#x5417;? &#x7B54;:&#x662F;&#x7684;, ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED
|   |   |   |       |   |--WARN_ON_ONCE(!irqs_disabled());
|   |   |   |       |   |--if( ... ) invoke_softirq() 
|   |   |   |       |   |    |--do_softirq -&amp;gt; __do_softirq
|   |   |   |       |   |    |    |--local_irq_enable   //&#x4FEE;&#x6539;CPSR I bit, &#x6253;&#x5F00;&#x4E2D;&#x65AD;
|   |   |   |       |   |    |    |--h-&amp;gt;action(h)
|   |   |   |       |   |    |    |--local_irq_disable  //&#x8FD9;&#x91CC;&#x4E3A;&#x4F55;&#x53C8;&#x7981;&#x6B62;&#x4E2D;&#x65AD;???
|   |   |   |       |--set_irq_regs(old_regs)  &#x8FD9;&#x91CC;&#x5F00;&#x542F;&#x4E2D;&#x65AD;? &#x7B54;:&#x4E0D;&#x662F;.
|   |--svc_exit r5, irq = 1  @entry-header.S
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5047;&#x5B9A;&#x53D1;&#x751F;&#x4E2D;&#x65AD;&#x524D;, &#x662F;&#x5904;&#x4E8E;svc&#x6A21;&#x5F0F;&#x7684;, &#x6240;&#x4EE5;, &#x4E0A;&#x9762;&#x6D41;&#x7A0B;&#x4E3A;__irq_svc.
&#x4E2D;&#x65AD;&#x4E0A;&#x534A;&#x90E8;&#x5206; &#x4E2D;&#x65AD;&#x662F;&#x5173;&#x95ED;&#x7684;, &#x4F55;&#x65F6;&#x91CD;&#x65B0;&#x4F7F;&#x80FD;&#x4E2D;&#x65AD;, &#x4E0A;&#x9762;&#x90FD;&#x4EE5;&#x6807;&#x51FA;. &#x4F7F;&#x80FD;&#x4E4B;&#x540E;, &#x5C31;&#x5F00;&#x59CB;&#x5904;&#x7406;&#x8F6F;&#x4E2D;&#x65AD;&#x4E86;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. tasklet&#x7684;&#x7279;&#x70B9;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4E24;&#x4E2A;&#x7C7B;&#x578B;&#x76F8;&#x540C;&#x7684;tasklet&#x4E0D;&#x80FD;&#x540C;&#x65F6;&#x8FD0;&#x884C;, &#x5373;&#x4F7F;&#x5728;&#x4E0D;&#x540C;&#x7684;&#x5904;&#x7406;&#x5668;&#x4E0A;&#x4E5F;&#x662F;&#x5982;&#x6B64;, &#x56E0;&#x4E3A;&#x4EE3;&#x7801;&#x4E0A;&#x68C0;&#x67E5;&#x7684;&#x5E76;&#x4E0D;&#x662F;per cpu&#x7684;&#x53D8;&#x91CF;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void __init softirq_init(void)
{
...
    open_softirq(TASKLET_SOFTIRQ, tasklet_action);
    open_softirq(HI_SOFTIRQ, tasklet_hi_action);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4EE3;&#x7801;:linux-3.10/kernel/softirq.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void tasklet_action(struct softirq_action *a)
{
        struct tasklet_struct *t
        ...
        if (tasklet_trylock(t)) {
            ...
            t-&amp;gt;func(t-&amp;gt;data);
        }

}

#ifdef CONFIG_SMP
static inline int tasklet_trylock(struct tasklet_struct *t)
{
    return !test_and_set_bit(TASKLET_STATE_RUN, &amp;amp;(t)-&amp;gt;state);
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. softirq&#x7684;&#x7279;&#x70B9;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;softirq&#x7684;pending&#x53D8;&#x91CF;&#x662F;per-cpu&#x7684;, &#x5E76;&#x4E0D;&#x4F1A;&#x963B;&#x6B62;&#x76F8;&#x540C;&#x7684;handler&#x540C;&#x65F6;&#x8FD0;&#x884C;&#x5728;&#x4E0D;&#x540C;&#x7684;cpu&#x4E0A;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/kernel/softirq.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__do_softirq
{

    pending = local_softirq_pending();
    set_softirq_pending(0);

    do {
        if (pending &amp;amp; 1) {

            -&amp;gt;action
        }

        pending &amp;gt;&amp;gt;= 1;
    }while (pending);

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x4ECE;create_mapping()&#x770B;arm linux&#x7684;&#x9875;&#x8868;</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_create_mapping_page_table</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;
&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;
http://blog.163.com/awaken_ing/blog/static/120613197201571932454226
&lt;/p&gt;

&lt;p&gt;create_mapping&#x4F1A;&#x8C03;&#x7528;&#x5230;alloc_init_pte(), &#x8FDB;&#x800C;&#x8C03;&#x7528;set_pte_ext()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define set_pte_ext(ptep,pte,ext) cpu_set_pte_ext(ptep,pte,ext)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;qemu&#x6A21;&#x62DF;&#x7684;versatilepb ARM Versatile/PB (ARM926EJ-S) ARMv5TEJ&lt;/p&gt;

&lt;p&gt;&#x6240;&#x4EE5;set_pte_ext(pte, pfn_pte(pfn, __pgprot(type-&amp;gt;prot_pte)), 0);&lt;/p&gt;

&lt;p&gt;&#x5C31;&#x662F;&lt;/p&gt;

&lt;p&gt;cpu_arm926_set_pte_ext (pte, pfn_pte(pfn, __pgprot(type-&amp;gt;prot_pte)), 0);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * cpu_arm926_set_pte_ext(ptep, pte, ext)
 *
 * Set a PTE and flush it out
 */
    .align  5
ENTRY(cpu_arm926_set_pte_ext)
#ifdef CONFIG_MMU
    armv3_set_pte_ext
    mov r0, r0
#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
    mcr p15, 0, r0, c7, c10, 1      @ clean D entry
#endif
    mcr p15, 0, r0, c7, c10, 4      @ drain WB
#endif
    mov pc, lr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5176;&#x4E2D;&#x5B8F;armv3_set_pte_ext&#x5B9E;&#x73B0;&#x5728; linux-2.6.35.7/arch/arm/mm/proc-macros.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * The ARMv3, ARMv4 and ARMv5 set_pte_ext translation function,
 * covering most CPUs except Xscale and Xscale 3.
 *
 * Permission translation:
 *  YUWD   AP   SVC User
 *  0xxx  0x00  no acc  no acc
 *  100x  0x00  r/o no acc
 *  10x0  0x00  r/o no acc
 *  1011  0x55  r/w no acc
 *  110x  0xaa  r/w r/o
 *  11x0  0xaa  r/w r/o
 *  1111  0xff  r/w r/w
 */

    .macro  armv3_set_pte_ext wc_disable=1
    str r1, [r0], #-2048        @ linux version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpu_arm926_set_pte_ext(ptep, pte, ext)&#x53C2;&#x6570;&#x4E2D;&#x7684;ptep&#x5DF2;&#x7ECF;&#x6307;&#x5411;linux&#x7248;&#x7684;pte&#x4E86;, linux&#x7248;&#x5728;&#x9AD8;&#x5730;&#x5740;, hw&#x7248;&#x5728;&#x4F4E;&#x5730;&#x5740;, &#x6240;&#x4EE5;&#x6709;&#x4E0A;&#x9762;&#x7684;-2048.&lt;br&gt;
arm hw&#x7248;&#x4E8C;&#x7EA7;&#x9875;&#x8868;&#x548C;linux&#x7248; &#x5728;&#x5185;&#x5B58;&#x5E03;&#x5C40;&#x7684;&#x5173;&#x7CFB;&#x5982;&#x4E0B;&#x56FE;&#x6240;&#x793A;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &#x9AD8;&#x5730;&#x5740;   +--------------+ x+1024*4
   ^     |   linux pte  | 
   |     |              |
   |     +--------------+ x+1024*3
   |     |   linux pte  | 
   |     |              |  
   |     +--------------+ x+1024*2
   |     |   hw pte     | 
   |     |              | 
   |     +--------------+ x+1024*1
         |   hw pte     |
         |              | 
  &#x4F4E;&#x5730;&#x5740;  +--------------+ x+0



    eor r3, r1, #L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_WRITE | L_PTE_DIRTY

    bic r2, r1, #PTE_SMALL_AP_MASK  @ keep C, B bits
    bic r2, r2, #PTE_TYPE_MASK
    orr r2, r2, #PTE_TYPE_SMALL
&#x5148;&#x6E05;&#x4F4E;2&#x4F4D;,&#x7136;&#x540E;D1:D0&#x5199;&#x4E3A;10,&#x4E5F;&#x5C31;&#x662F;&#x4F7F;&#x7528;small page


    tst r3, #L_PTE_USER         @ user?
    orrne   r2, r2, #PTE_SMALL_AP_URO_SRW
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5C06;linux&#x7248;&#x672C;&#x7684;L_PTE_USER&#x8F6C;&#x4E3A;arm&#x7248;&#x672C;&lt;br&gt;
&#x8FD9;&#x4E2A;bit(L_PTE_USER)&#x6765;&#x81EA;mem_types[]&#x7684;struct mem_type&#x7684;&#x6210;&#x5458;prot_pte&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static struct mem_type mem_types[] = {

    [MT_HIGH_VECTORS] = {
        .prot_pte  = L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_DIRTY |
                L_PTE_USER | L_PTE_EXEC,
        .prot_l1   = PMD_TYPE_TABLE,
        .domain    = DOMAIN_USER,
    },

};


tst r3, #L_PTE_WRITE | L_PTE_DIRTY  @ write and dirty?
orreq   r2, r2, #PTE_SMALL_AP_UNO_SRW
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7559;&#x610F;0x55| 0xaa==0xff, &#x5BF9;&#x5E94;&#x672C;&#x6BB5;&#x4EE3;&#x7801;&#x524D;&#x9762;&#x7684;&#x6CE8;&#x91CA;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Permission translation:
YUWD   AP   SVC User
1011  0x55  r/w no acc
110x  0xaa  r/w r/o
11x0  0xaa  r/w r/o
1111  0xff  r/w r/w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="/assets/media/second-level_descriptor.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x95EE;&#x9898;:AP3&#x5230;AP0&#x662F;?&lt;br&gt;
&#x7B54;:If the level one descriptor defines a page-mapped access and the level two descriptor is for a large or small page, four access permission fields, ap3
to ap0, are specified, each corresponding to one quarter of the page. For small pages ap3 is selected by the top 1KB of the page and ap0 is selected by the bottom 1KB of the page. &lt;/p&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x5BF9;&#x4E8E;&#x4E8C;&#x7EA7;&#x9875;&#x8868;&#x4E2D;small page, &#x5F53;&#x524D;&#x662F;&#x54EA;&#x4E2A;domain&#x5462;?&lt;br&gt;
&#x7B54;:&#x6240;&#x5C5E;&#x7684;&#x4E00;&#x7EA7;&#x9875;&#x8868;&#x7684;domain&#x51B3;&#x5B9A;, &#x89C1;Figure3-4. D8:D5&#x8FD9;4&#x4E2A;bit&#x9009;&#x62E9;16&#x4E2A;domain&#x4E2D;&#x7684;&#x4E00;&#x4E2A;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/first-level_descriptor.jpg"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tst r3, #L_PTE_PRESENT | L_PTE_YOUNG    @ present and young?
movne   r2, #0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5BF9;&#x5E94;arm&#x7684;&#x4E8C;&#x7EA7;&#x9875;&#x8868;&#x4E2D;&#x7684;fault&#x7684;&#x60C5;&#x51B5;, &#x89C1;Figure3-9.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    .if \wc_disable
#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
    tst r2, #PTE_CACHEABLE
    bicne   r2, r2, #PTE_BUFFERABLE
#endif
    .endif
    str r2, [r0]            @ hardware version
    .endm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x76F8;&#x5173;&#x8D44;&#x6599;
ARM926EJ-S Technical Reference Manual &lt;/p&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x4E2D;&#x65AD;&#x5904;&#x7406;&#x8FC7;&#x7A0B;&#x4E2D;&#x5BC4;&#x5B58;&#x5668;&#x7684;&#x4FDD;&#x5B58;</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_int_pt_regs</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;
&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;
http://blog.163.com/awaken_ing/blog/static/1206131972015839465987
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#x6A21;&#x5F0F;   usr            exception                                   svc                             
-----|----|--------------------------------|---------------------------------------------------                                                                                               
&#x51FD;&#x6570;                 vector_\name:                             usr_entry:                         


                                                                            &#x5BF9;&#x5E94;&#x7684;&#x6C47;&#x7F16;&#x8BED;&#x53E5;:                    
                  +----------------+        0  +------------------+   ------------------------    
           &#x9AD8;&#x5730;&#x5740; |spsr_&amp;lt;exception&amp;gt;|           |      r0          |      str     r1, [sp]         
                  |                |        4  +------------------+    ----------------------     
             ^    +----------------+           |      r1          |                               
             |    |                |           |                  |                               
             |    |lr_&amp;lt;exception&amp;gt;  |           |      .           |                               
             |    |                |           |      .           |      stmib   sp, {r1 - r12}   
             |    +----------------+           |      .           |                               
                  |                |           |                  |                               
           &#x4F4E;&#x5730;&#x5740; |      r0        |           |     r12          |                               
                  |                |           |                  |                               
                  +----------------+       52  +------------------+     ----------------------    
                    struct stack               |      sp_usr      |                               
                                               |                  |                               
                                           56  +------------------+     stmdb   r0, {sp, lr}^     
                                               |     lr_usr       |                               
                                               |                  |                               
                                           60  +------------------+      ---------------------    
                                               |  lr_&amp;lt;exception&amp;gt;  |                               
                                               |                  |                               
                                           64  +------------------+                                
                                               | spsr_&amp;lt;exception&amp;gt; |      stmia   r0, {r2 - r4}    
                                               |                  |                               
                                           68  +------------------+                               
                                               |      -1          |                               
                                               |                  |                               
                                           72  +------------------+     -----------------------   
                                                struct  pt_regs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4EE3;&#x7801;&#x5728;linux-2.6.35.7/arch/arm/kernel/entry-armv.S&lt;/p&gt;

&lt;p&gt;lr_&amp;lt;exception&amp;gt; &#x8868;&#x793A; parent PC&lt;br&gt;
spsr_&amp;lt;exception&amp;gt; &#x8868;&#x793A; parent CPSR&lt;/p&gt;

&lt;p&gt;&#x53F3;&#x8FB9;72&#x4E2A;&#x5B57;&#x8282;&#x6784;&#x6210;&#x7684;&#x662F;struct  pt_regs.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x7684;iounmap()&#x5982;&#x4F55;&#x5904;&#x7406;&#x4E3B;&#x9875;&#x8868;(master page table)&#x7684;&#x540C;&#x6B65;</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_iounmap_master_table</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;: http://blog.163.com/awaken_ing/blog/static/120613197201510308269773&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x80CC;&#x666F;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5E73;&#x53F0;&#x4E3A;qemu ARM Versatile/PB (ARM926EJ-S) ARMv5TEJ, UP&lt;/p&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x77E5;&#x9053;&#x8FDB;&#x7A0B;&#x7684;&#x5185;&#x6838;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x7684;&#x9875;&#x8868; &#x548C; swapper_pg_dir &#x8FDB;&#x884C;&#x540C;&#x6B65;, &#x5728;&#x8FDB;&#x7A0B;&#x521B;&#x5EFA;&#x65F6;, do_fork()&#x4F1A;&#x62F7;&#x8D1D;&#x4E00;&#x7EA7;&#x9875;&#x8868;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x95EE;&#x9898;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;vmalloc() area&#x53D1;&#x751F;&#x5F02;&#x5E38;, &#x7531;do_translation_fault()&#x5904;&#x7406;, &#x5904;&#x7406;&#x7684;&#x662F;&#x4E00;&#x7EA7;&#x9875;&#x8868;&#x65E0;&#x6548;&#x7684;&#x60C5;&#x51B5;, &#x5904;&#x7406;&#x65B9;&#x6CD5;: If the init_task&amp;#39;s first level page tables contains the relevant entry, we copy the it to this task.&lt;/p&gt;

&lt;p&gt;&#x53EF;&#x4EE5;&#x731C;&#x60F3;, vmalloc&#x533A;&#x57DF;&#x7684;&#x9875;&#x8868;&#x662F; &#x4E24;&#x7EA7;&#x9875;&#x8868;(&#x4F4E;&#x4E24;&#x4F4D;D1D0&#x4E3A;0b01), &#x800C;&#x4E0D;&#x662F;section (D1D0&#x4E3A;0b10)&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/first-level_descriptor.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x6253;&#x5370;vmalloc&#x533A;&#x57DF;&#x7684;&#x5BF9;&#x5E94;&#x7684;&#x9875;&#x8868;, &#x53EF;&#x4EE5;&#x770B;&#x5230; D1D0 &#x65E2;&#x6709;0b01(&#x6307;&#x5411;&#x4E8C;&#x7EA7;&#x9875;&#x8868;), &#x4E5F;&#x6709;0b10(&#x65E0;&#x9700;&#x4E8C;&#x7EA7;&#x9875;&#x8868;) &#x7684;.&lt;/p&gt;

&lt;p&gt;&#x4ECE;cat /proc/vmallocinfo&#x53EF;&#x77E5;, &#x53EF;&#x77E5;0b10&#x4E0D;&#x662F;&#x7531;vmalloc()&#x5F15;&#x53D1;&#x7684;&#x9875;&#x8868;&#x521B;&#x5EFA;, &#x800C;&#x662F;ioremap(). (&#x8FD9;&#x91CC;&#x5E76;&#x4E0D;&#x662F;&#x8BF4;ioremap&#x521B;&#x5EFA;&#x7684;&#x90FD;&#x662F;section)&lt;/p&gt;

&lt;p&gt;&#x865A;&#x62DF;&#x5730;&#x5740;0xc9000000&#x5F00;&#x59CB;&#x5BF9;&#x5E94;&#x7684;&#x4E00;&#x7EA7;&#x9875;&#x8868;entry&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p /x *(int *)0xc0007240@65
$1 = {0x34000452, 0x34100452, 0x34200452, 0x34300452, 0x34400452, 0x34500452, 0x34600452, 0x34700452, 0x34800452, 
  0x34900452, 0x34a00452, 0x34b00452, 0x34c00452, 0x34d00452, 0x34e00452, 0x34f00452, 0x35000452, 0x35100452, 0x35200452, 
  0x35300452, 0x35400452, 0x35500452, 0x35600452, 0x35700452, 0x35800452, 0x35900452, 0x35a00452, 0x35b00452, 0x35c00452, 
  0x35d00452, 0x35e00452, 0x35f00452, 0x36000452, 0x36100452, 0x36200452, 0x36300452, 0x36400452, 0x36500452, 0x36600452, 
  0x36700452, 0x36800452, 0x36900452, 0x36a00452, 0x36b00452, 0x36c00452, 0x36d00452, 0x36e00452, 0x36f00452, 0x37000452, 
  0x37100452, 0x37200452, 0x37300452, 0x37400452, 0x37500452, 0x37600452, 0x37700452, 0x37800452, 0x37900452, 0x37a00452, 
  0x37b00452, 0x37c00452, 0x37d00452, 0x37e00452, 0x37f00452, 0x0}

# cat /proc/vmallocinfo
...
0xc9000000-0xcd001000 67112960 armflash_subdev_probe+0x64/0x120 ioremap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5BF9;&#x4E8E; 0b10(&#x65E0;&#x9700;&#x4E8C;&#x7EA7;&#x9875;&#x8868;) &#x5C31;&#x4E0D;&#x597D;&#x7406;&#x89E3;. &#x8003;&#x8651;&#x8FD9;&#x6837;&#x4E00;&#x79CD;&#x60C5;&#x51B5;,&lt;/p&gt;

&lt;p&gt;&#x8FDB;&#x7A0B;A&#x6267;&#x884C;ioremap(), &#x7136;&#x540E;&#x8FDB;&#x7A0B;B&#x66F4;&#x65B0;&#x4E86;the first level page table. &#x4E4B;&#x540E;&#x8FDB;&#x7A0B;A&#x6267;&#x884C;iounmap(), &#x8FDB;&#x7A0B;B&#x5982;&#x4F55;&#x80FD;&#x591F;&#x77E5;&#x9053;&#x5462;? (use-after-iounmap cases)&lt;/p&gt;

&lt;p&gt;&#x6240;&#x4EE5;, ioremap()&#x5BF9;&#x5E94;&#x7684;iounmap() &#x5982;&#x4F55;&#x5904;&#x7406;&#x4E00;&#x7EA7;&#x9875;&#x8868;, &#x624D;&#x80FD;&#x8FBE;&#x5230; &#x9875;&#x8868;&#x95F4;&#x7684;&#x540C;&#x6B65;?&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x89E3;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5148;&#x770B;&#x4E0B;&#x5728;&#x4F55;&#x5904;&#x521B;&#x5EFA;:&lt;/p&gt;

&lt;p&gt;&#x865A;&#x62DF;&#x5730;&#x5740;&#x7684;0xc9000000&#x7684;&#x4E00;&#x7EA7;&#x9875;&#x8868;&#x5728;0xc0007240&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) watch *(unsigned int *)0xc0007240
Watchpoint 5: *(unsigned int *)0xc0007240
(gdb) c
Continuing.
Watchpoint 5: *(unsigned int *)0xc0007240

Old value = 0
New value = 872416338
remap_area_sections (virt=&amp;lt;value optimized out&amp;gt;, pfn=213248, size=&amp;lt;value optimized out&amp;gt;, type=&amp;lt;value optimized out&amp;gt;)
    at arch/arm/mm/ioremap.c:207
207         pmd[1] = __pmd(__pfn_to_phys(pfn) | type-&amp;gt;prot_sect);
(gdb) p /x 872416338
$7 = 0x34000452
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7531; (gdb) bt &#x53EF;&#x77E5;, &#x8C03;&#x7528;&#x8DEF;&#x5F84;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ioremap
|--__arm_ioremap
|    |--__arm_ioremap_caller
|    |   |--__arm_ioremap_pfn_caller
|    |   |   |--remap_area_sections
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ioremap()&#x6709;remap_area_sections(), &#x76F8;&#x5BF9;&#x5E94;&#x7684;iounmap()&#x6709;unmap_area_sections()&lt;/p&gt;

&lt;p&gt;linux-2.6.35.7/arch/arm/mm/ioremap.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifndef CONFIG_SMP
/*
 * Section support is unsafe on SMP - If you iounmap and ioremap a region,
 * the other CPUs will not see this change until their next context switch.
 * Meanwhile, (eg) if an interrupt comes in on one of those other CPUs
 * which requires the new ioremap&amp;#39;d region to be referenced, the CPU will
 * reference the _old_ region.
 *
 * Note that get_vm_area_caller() allocates a guard 4K page, so we need to
 * mask the size back to 1MB aligned or we will overflow in the loop below.
 */
static void unmap_area_sections(unsigned long virt, unsigned long size)
{
        do {
            ...
                init_mm.context.kvm_seq++;
                ...
        } while (addr &amp;lt; end);

 /*
  * Ensure that the active_mm is up to date - we want to
  * catch any use-after-iounmap cases.
  */
 if (current-&amp;gt;active_mm-&amp;gt;context.kvm_seq != init_mm.context.kvm_seq)
  __check_kvm_seq(current-&amp;gt;active_mm);
}
void __check_kvm_seq(struct mm_struct *mm)
{
...
memcpy(pgd_offset(mm, VMALLOC_START), ...);
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x53EA;&#x5904;&#x7406;&#x4E86;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;, &#x5176;&#x4ED6;&#x8FDB;&#x7A0B;&#x5462;? &#x641C;&#x7D22; kvm_seq, &#x627E;&#x5230;&lt;/p&gt;

&lt;p&gt;linux-2.6.35.7/arch/arm/include/asm/mmu_context.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;check_context
{
if (unlikely(mm-&amp;gt;context.kvm_seq != init_mm.context.kvm_seq))
  __check_kvm_seq(mm);
}

switch_mm
{
check_context(next);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x5728;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#x65F6;, &#x4F1A;&#x77E5;&#x9053;&#x4E00;&#x7EA7;&#x9875;&#x8868;&#x53D1;&#x751F;&#x4E86;&#x53D8;&#x5316;, &#x8FDB;&#x800C;&#x540C;&#x6B65;&#x4E0A;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>&#x5173;&#x4E8E;arm linux&#x7684;map_io</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_map_io</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt; &#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2; http://blog.163.com/awaken_ing/blog/static/1206131972016226674429
&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4E3B;&#x8981;&#x6D41;&#x7A0B;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5E73;&#x53F0;:versatilepb ARM Versatile/PB (ARM926EJ-S) &#x5185;&#x6838;&#x7248;&#x672C;2.6.35.7&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paging_init
|--devicemaps_init
|   |--from VMALLOC_END, pmd_clear(pmd_off_k(addr))
|   |--mdesc-&amp;gt;map_io() =&amp;gt; versatile_map_io  
|   |   |--iotable_init
|   |   |   |--create_mapping
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x4E3A;&#x4F55;&#x662F; MT_DEVICE&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-2.6.35.7/arch/arm/mach-versatile/core.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void __init versatile_map_io(void)
{
    iotable_init(versatile_io_desc, ARRAY_SIZE(versatile_io_desc));
}

static struct map_desc versatile_io_desc[] __initdata = {
    {
        ...
        .type       = MT_DEVICE
    },
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x662F; MT_DEVICE, &#x800C;&#x4E0D;&#x662F; MT_UNCACHED, why?&lt;/p&gt;

&lt;p&gt;MT_DEVICE&#x7C7B;&#x578B;&#x548C; MT_UNCACHED &#x7684;&#x533A;&#x522B;&#x5728; .prot_pte &#x548C; .prot_sect &#x4E0A;.&lt;/p&gt;

&lt;p&gt;&#x770B;&#x770B; .prot_pte &#x548C; .prot_sect &#x7684;&#x4F5C;&#x7528;?
2.1 .prot_pte &#x7528;&#x9014;
&#x4F7F;&#x7528;&#x5230; .prot_pte &#x7684;&#x5730;&#x65B9;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alloc_init_pte
{
    set_pte_ext(pte, pfn_pte(pfn, type-&amp;gt;prot_pte), 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7B49;&#x6548;&#x4E8E;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cpu_arm926_set_pte_ext(pte, pfn_pte(pfn, type-&amp;gt;prot_pte), 0);
#define pfn_pte(pfn,prot)    (__pte(((pfn) &amp;lt;&amp;lt; PAGE_SHIFT) | pgprot_val(prot)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpu_arm926_set_pte_ext&#x5C06;&#x4E3B;&#x8981;&#x5DE5;&#x4F5C;&#x4EA4;&#x7ED9; armv3_set_pte_ext, &#x8FD9;&#x91CC;&#x5E76;&#x6CA1;&#x6709;&#x5224;&#x65AD; L_PTE_MT_DEV_SHARED &#x6216;&#x8005; L_PTE_SHARED, &#x6240;&#x4EE5;, &#x5BF9;&#x4E8E;&#x786C;&#x4EF6;&#x9875;&#x8868;, &#x6DFB;&#x52A0;&#x4E0A;&#x4E5F;&#x6CA1;&#x6709;&#x5F71;&#x54CD;.
2.2 .prot_sect &#x7528;&#x9014;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alloc_init_section
{
pmd_t *pmd = pmd_offset(pgd, addr);
...&#x5982;&#x679C; &#x521B;&#x5EFA;&#x7684;&#x662F; section.
*pmd = phys | type-&amp;gt;prot_sect;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, .prot_sect &#x7528;&#x6765;&#x5199;&#x5230;&#x7269;&#x7406;&#x9875;&#x8868;&#x53BB;&#x7684;, &#x4E0D;&#x50CF;&#x4E8C;&#x7EA7;&#x9875;&#x8868;, &#x8FD9;&#x91CC;linux&#x4E0D;&#x9700;&#x8981;&#x8F6C;&#x6362;&#x5565;&#x7684;.&lt;/p&gt;

&lt;p&gt;MT_DEVICE&#x7684; .prot_sect = PROT_SECT_DEVICE | PMD_SECT_S,&lt;/p&gt;

&lt;p&gt;&#x7B49;&#x6548;&#x4E8E; PMD_TYPE_SECT|PMD_SECT_AP_WRITE | PMD_SECT_S MT_UNCACHED&#x7684;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.prot_sect = PMD_TYPE_SECT | PMD_SECT_XN,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;build_mem_type_table()&#x4E2D;&#x4F1A;&#x6839;&#x636E;arm&#x7248;&#x672C;, &#x5BF9; .prot_sect &#x8FDB;&#x884C;&#x4FEE;&#x6B63;, &#x6BD4;&#x5982;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build_mem_type_table
{
    if (cpu_arch &amp;lt; CPU_ARCH_ARMv6 ...)
        mem_types[i].prot_sect &amp;amp;= ~PMD_SECT_S;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x5C31;&#x4E0D;&#x8D70;&#x8BFB;&#x4EE3;&#x7801;&#x4E86;, &#x76F4;&#x63A5;&#x6253;&#x5370;&#x7ED3;&#x679C;.&lt;/p&gt;

&lt;p&gt;&#x5F80;build_mem_type_table()&#x4E2D;&#x6DFB;&#x52A0;&#x6253;&#x5370;&#x540E;(&#x672A;&#x6DFB;&#x52A0;&#x4E0A;domain), &#x6709;&lt;/p&gt;

&lt;p&gt;MT_DEVICE &#x7684; .prot_sect &#x4E3A; 0x412&lt;/p&gt;

&lt;p&gt;MT_UNCACHED&#x7684; .prot_sect &#x4E3A; 0x12&lt;/p&gt;

&lt;p&gt;C(D3)&#x548C;B(D2) &#x90FD;&#x662F;&#x5173;&#x95ED;&#x7684;.&lt;/p&gt;

&lt;p&gt;&#x4E5F;&#x5C31;&#x662F;&#x591A;&#x4E86;&#x4E2A; PMD_SECT_AP_WRITE&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PMD_SECT_AP_WRITE (1 &amp;lt;&amp;lt; 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5148;&#x68C0;&#x67E5;domain, &#x5982;&#x679C;&#x4E3A;01(Client), &#x5219;&#x63A5;&#x7740;&#x68C0;&#x67E5;AP bits.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/ARM_access_permission.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x5982;&#x679C;&#x521B;&#x5EFA;&#x7684;&#x662F;section&#x7684;&#x8BDD;, &#x7C7B;&#x578B;MT_UNCACHED, &#x6700;&#x591A;&#x53EA;&#x80FD;&#x591F; read-only, &#x4E0D;&#x7B26;&#x5408;&#x8981;&#x6C42;, &#x6545;&#x4E0D;&#x4F7F;&#x7528;.
3. &#x865A;&#x62DF;&#x5730;&#x5740;&#x6307;&#x5B9A;&#x6210;&#x5565;&#x597D;&#x5462;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;create_mapping
{
    if ((md-&amp;gt;type == MT_DEVICE || md-&amp;gt;type == MT_ROM) &amp;amp;&amp;amp;
        md-&amp;gt;virtual &amp;gt;= PAGE_OFFSET &amp;amp;&amp;amp; md-&amp;gt;virtual &amp;lt; VMALLOC_END) {
        printk(KERN_WARNING &amp;quot;BUG: mapping for 0x%08llx at 0x%08lx &amp;quot;
               &amp;quot;overlaps vmalloc space\n&amp;quot;,
               __pfn_to_phys((u64)md-&amp;gt;pfn), md-&amp;gt;virtual);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5982;&#x679C;&#x662F;MT_DEVICE, &#x90A3;&#x4E48;, &#x4E0D;&#x592A;&#x5EFA;&#x8BAE;&#x6620;&#x5C04;(&#x4E0D;&#x662F;&#x7981;&#x6B62;, &#x56E0;&#x4E3A;&#x53EA;&#x662F;&#x6253;&#x5370;&#x4E86;warning&#x800C;&#x5DF2;)&#x5230; 3G~VMALLOC_END &#x4E4B;&#x95F4;. &#x5EFA;&#x8BAE;&#x6211;&#x4EEC;&#x6620;&#x5C04;&#x5230;vmalloc&#x4E0E;DMA&#x4E4B;&#x95F4;&#x7684;gap&#x5185; (vmalloc&#x548C;DMA&#x95F4;&#x7684;gap&#x53EF;&#x4E0D;&#x662F;8MB).&lt;/p&gt;

&lt;p&gt;&#x770B;&#x4E0B;versatile&#x7684;&#x6620;&#x5C04;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;. linux-2.6.35.7/arch/arm/mach-versatile/core.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static struct map_desc versatile_io_desc[] __initdata = {
    {
        .virtual    =  IO_ADDRESS(VERSATILE_SYS_BASE),
        .pfn        = __phys_to_pfn(VERSATILE_SYS_BASE),
        .length        = SZ_4K,
        .type        = MT_DEVICE
    },

#define VERSATILE_SYS_BASE   0x1000 0000
#define IO_ADDRESS(x)  (((x) &amp;amp; 0x0fff ffff) 
                       + (((x) &amp;gt;&amp;gt; 4) &amp;amp; 0x0f00 0000) 
                       + 0xf000 0000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x8BA1;&#x7B97;&#x51FA;&#x6765;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x4E3A; 0xf100 0000.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Virtual kernel memory layout:
...
    DMA     : 0xffc00000 - 0xffe00000   (   2 MB)
    vmalloc : 0xc8800000 - 0xd8000000   ( 248 MB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6B63;&#x662F;&#x5904;&#x4E8E;vmalloc&#x4E0E;DMA&#x4E4B;&#x95F4;&#x7684;gap&#x5185;. &lt;/p&gt;
</description>
    </item>
    <item>
      <title>qemu&#x89C2;&#x5BDF;arm linux&#x542F;&#x52A8;&#x8FC7;&#x7A0B;01</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_qemu_01</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt; &#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2; 
http://blog.163.com/awaken_ing/blog/static/12061319720157611510386
&lt;/p&gt; 

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x65B9;&#x6CD5;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;qemu-system-arm -M versatilepb -m 128M -kernel /opt/qemu_arm/linux-2.6.35.7/arch/arm/boot/compressed/vmlinux -S -s&lt;/p&gt;

&lt;p&gt;&#x9700;&#x8981;&#x7559;&#x610F;, &#x8FD9;&#x91CC;-kernel&#x7684;&#x53C2;&#x6570;&#x4E0D;&#x662F;/opt/qemu_arm/linux-2.6.35.7/vmlinux&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arm-none-linux-gnueabi-gdb -tui -q /opt/qemu_arm/linux-2.6.35.7/arch/arm/boot/compressed/vmlinux
Reading symbols from /opt/qemu_arm/linux-2.6.35.7/arch/arm/boot/compressed/vmlinux...done.
(gdb) target extended-remote localhost:1234
Remote debugging using localhost:1234
warning: Source file is more recent than executable.
start () at arch/arm/boot/compressed/head.S:115
(gdb) b __setup_mmu
Breakpoint 1 at 0x200: file arch/arm/boot/compressed/head.S, line 409.
(gdb) c
Continuing.
Breakpoint 1, __setup_mmu () at arch/arm/boot/compressed/head.S:409
(gdb) i r r3 r4
r3 0x4000 16384
r4 0x8000 32768
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;r3 r4&#x7684;&#x503C;&#x6765;&#x81EA;&lt;/p&gt;

&lt;p&gt;linux-2.6.35.7/arch/arm/mach-versatile/Makefile.boot&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zreladdr-y := 0x00008000
params_phys-y := 0x00000100
initrd_phys-y := 0x00800000
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2&#x4E0B;&#x9762;&#x4E3B;&#x8981;&#x770B;&#x770B;__setup_mmu&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;__setup_mmu:    sub r3, r4, #16384      @ Page directory size
    ...ignore some code here...
1:      cmp r1, r9          @ if virt &amp;gt; start of RAM
        orrhs   r1, r1, #0x0c       @ set cacheable, bufferable
        cmp r1, r10         @ if virt &amp;gt; end of RAM
        bichs   r1, r1, #0x0c       @ clear cacheable, bufferable
        str r1, [r0], #4        @ 1:1 mapping
        add r1, r1, #1048576
        teq r0, r2
        bne 1b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5728;&#x8FD9;&#x4E2A;&#x5FAA;&#x73AF;&#x7ED3;&#x675F;&#x65F6;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) i r r0 r2 r9 r10
r0 0x8000 32768
r2 0x8000 32768
r9 0x0 0
r10 0x10000000 268435456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;r10==0x10000000 &#x9664;&#x4EE5; 1M&#x540E;, &#x7B49;&#x4E8E;0x100&lt;/p&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x4E34;&#x754C;&#x662F;0x4000+0x100*4=0x4400&lt;/p&gt;

&lt;p&gt;&#x6253;&#x5370;&#x51FA;&#x8FD9;&#x4E2A;&#x8868;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p /x *(unsigned int*)0x43f0@0x10
$49 = {0xfc00c1e, 0xfd00c1e, 0xfe00c1e, 0xff00c1e, 0x10000c12, 0x10100c12, 0x10200c12, 0x10300c12, 0x10400c12, 0x10500c12, 0x10600c12,
0x10700c12, 0x10800c12, 0x10900c12, 0x10a00c12, 0x10b00c12}
(gdb) p /x *(unsigned int*)0x43fc
$64 = 0xff00c1e
(gdb) p /x *(unsigned int*)(0x43fc+4)
$65 = 0x10000c12
(gdb) p /x *(unsigned int*)0x4000@0x101
$70 = {0xc1e, 0x100c1e, 0x200c1e, 0x300c1e, 0x400c1e, 0x500c1e, 0x600c1e, 0x700c1e,
&#x7701;&#x7565;&#x90E8;&#x5206;&#x6253;&#x5370;
0xb500c1e, 0xb600c1e, 0xb700c1e, 0xb800c1e, 0xb900c1e, 0xba00c1e, 0xbb00c1e, 0xbc00c1e, 0xbd00c1e, 0xbe00c1e, 0xbf00c1e, 0xc000c1e,
0xc100c1e, 0xc200c1e, 0xc300c1e, 0xc400c1e, 0xc500c1e, 0xc600c1e, 0xc700c1e...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x672C;&#x4F8B;&#x4E2D;zreladdr&#x5C0F;&#x4E8E;1M, &#x7B97;&#x6BD4;&#x8F83;&#x7279;&#x6B8A;. &#x4E0B;&#x56FE;&#x662F;&#x8F83;&#x5E38;&#x89C1;&#x7684;&#x60C5;&#x51B5;, &#x56FE;&#x7247;&#x6765;&#x81EA;&amp;lt;&amp;lt;ARM Linux&#x5185;&#x6838;&#x6E90;&#x7801;&#x5256;&#x6790;&amp;gt;&amp;gt; &#x7684;&#x56FE;5-4&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/arm9_page_table.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x8FD9;&#x4E2A;&#x8868;&#x5EFA;&#x7ACB;&#x540E;, &#x63A5;&#x7740;&#x5EFA;&#x8868;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * If ever we are running from Flash, then we surely want the cache
 * to be enabled also for our execution instance...  We map 2MB of it
 * so there is no map overlap problem for up to 1 MB compressed kernel.
 * If the execution is in RAM then we would only be duplicating the above.
 */
        mov r1, #0x1e
        orr r1, r1, #3 &amp;lt;&amp;lt; 10
        mov r2, pc, lsr #20
        orr r1, r1, r2, lsl #20
        add r0, r3, r2, lsl #2
        str r1, [r0], #4
        add r1, r1, #1048576
        str r1, [r0]
        mov pc, lr

@ r0&#x5185;&#x5BB9;&#xFF1A;  
@ 31       14               13       2                     1 0  
@  &#x9875;&#x8868;&#x57FA;&#x5740;               &#x9875;&#x8868;index(pc&#x9AD8;12bit)             0 0  

@ r1&#x5185;&#x5BB9;&#xFF1A;  
@ 31       20      19 12     11 10    9     8  5      4 3 2 1 0  
@  PC&#x9AD8;12bit       0        AP     0          &#x57DF;         1 C B 1 0
@  PC&#x9AD8;12bit       0        11      0        0000       1 1 1 1 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3&#x518D;&#x770B;&#x770B;&#x4F7F;&#x80FD;cache on&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x8FD9;&#x91CC;qemu&#x6A21;&#x62DF;&#x7684;&#x662F;versatilepb, &#x4F53;&#x7CFB;&#x4E3A;ARMv5TEJ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__common_mmu_cache_on:
    ....ignore some code here...
    .align  5           @ cache line aligned
1:  mcr p15, 0, r0, c1, c0, 0   @ load control register
    mrc p15, 0, r0, c1, c0, 0   @ and read it back to
    sub pc, lr, r0, lsr #32 @ properly flush pipeline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6982;&#x62EC;&#x5730;&#x8BF4;, &#x901A;&#x8FC7;r0&#x5EFA;&#x7ACB;&#x8D77;&#x524D;&#x540E;&#x8BED;&#x53E5;&#x7684;dependency, &#x5B9E;&#x73B0;barrier&#x529F;&#x80FD;. &#x8BE6;&#x7EC6;&#x7684;, &#x8BF7;&#x53C2;&#x8003;&#x6587;&#x672B;&#x7684;&#x76F8;&#x5173;&#x8D44;&#x6599;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4&#x51FA;&#x9519;&#x4E86;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x7EE7;&#x7EED;&#x8FD0;&#x884C;,&#x53D1;&#x73B0;&#x51FA;&#x9519;&#x4E86;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) bt
#0 0x000008c4 in error (x=0x3f37 &amp;quot;uncompression error&amp;quot;) at arch/arm/boot/compressed/misc.c:177
#1 0x00002d94 in gunzip (buf=0x3f4b &amp;quot;\037\213\b&amp;quot;, len=&amp;lt;value optimized out&amp;gt;,
out_buf=0x1d61c0 &amp;quot;\323\360!\343\020\237\020&amp;quot;, &amp;lt;incomplete sequence \356\272&amp;gt;, pos=0x0, flush=0, fill=0xbf0 &amp;lt;nofill&amp;gt;,
error_fn=&amp;lt;value optimized out&amp;gt;) at arch/arm/boot/compressed/../../../../lib/decompress_inflate.c:152
#2 0x00003004 in do_decompress (input=&amp;lt;value optimized out&amp;gt;, len=&amp;lt;value optimized out&amp;gt;, output=&amp;lt;value optimized out&amp;gt;,
error=&amp;lt;value optimized out&amp;gt;) at arch/arm/boot/compressed/decompress.c:49
#3 0x00000a7c in decompress_kernel (output_start=&amp;lt;value optimized out&amp;gt;, free_mem_ptr_p=&amp;lt;value optimized out&amp;gt;,
free_mem_ptr_end_p=&amp;lt;value optimized out&amp;gt;, arch_id=&amp;lt;value optimized out&amp;gt;) at arch/arm/boot/compressed/misc.c:209
#4 0x000000e8 in not_relocated () at arch/arm/boot/compressed/head.S:266
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;5&#x539F;&#x56E0;&#x548C;&#x5904;&#x7406;&#x65B9;&#x6CD5;&lt;/h4&gt;&lt;/h1&gt;

&lt;h2 id="toc_5"&gt;&lt;h4&gt;5.1 &#x539F;&#x56E0;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x7531;&#x4E8E;&#x4F7F;&#x7528;&#x7684;&#x662F;vmlinux, &#x6240;&#x4EE5;&#x6CA1;&#x6709;bootloader&#x5BF9;&#x5185;&#x6838;&#x7684;&#x642C;&#x8FD0;&#x52A8;&#x4F5C;, &#x4E14;&lt;br&gt;
arch/arm/boot/compressed/Makefile&#x4E2D; ZTEXTADDR := 0,&lt;br&gt;
arch/arm/mach-versatile/Makefile.boot&#x4E2D; zreladdr-y:= 0x00008000&lt;br&gt;
&#x5185;&#x6838;&#x5927;&#x5C0F;&amp;gt;0x00008000, &#x6240;&#x4EE5;,&#x6267;&#x884C;&#x89E3;&#x538B;&#x7F29;&#x65F6;&#x4F1A;&#x5BFC;&#x81F4;&#x8986;&#x76D6;.&lt;/p&gt;

&lt;h1 id="toc_6"&gt;&lt;h4&gt;5.2&#x8981;&#x89E3;&#x51B3;&#x8FD9;&#x4E2A;&#x95EE;&#x9898;, &#x53EF;&#x4EE5;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4FEE;&#x6539;arch/arm/boot/compressed/Makefile&#x4E2D; ZTEXTADDR:= 0x200000&lt;/p&gt;

&lt;p&gt;&#x5E76;rm arch/arm/boot/compressed/vmlinux.lds&lt;/p&gt;

&lt;p&gt;&#x53E6;&#x5916;, &#x6CA1;&#x6709;&#x4E86;bootloader, &#x5C31;&#x8981;&#x5185;&#x6838;&#x81EA;&#x5DF1;&#x8BBE;&#x7F6E;bootargs&#x4E86;,&lt;/p&gt;

&lt;p&gt;&#x53EF;&#x4EE5;&#x4FEE;&#x6539;.config&#x4E2D;CONFIG_CMDLINE&#x4E3A;&lt;/p&gt;

&lt;p&gt;CONFIG_CMDLINE=&amp;quot;mem=128M root=/dev/nfs nfsroot=10.0.2.2:/opt/qemu_arm/busybox-1.19.3/_install rw ip=10.0.2.15::10.0.2.1:255.255.255.0 init=/sbin/init console=ttyAMA0&amp;quot;&lt;/p&gt;

&lt;p&gt;&#x7136;&#x540E;&#x91CD;&#x7F16;&#x5185;&#x6838;&lt;/p&gt;

&lt;p&gt;&#x8FD0;&#x884C;&#x65F6;&#x8FD8;&#x8981;&#x4F20;&#x9012;&#x5408;&#x9002;&#x7684;machine id, &#x5BF9;&#x4E8E;versatilepb, &#x503C;&#x4E3A;0x183&lt;/p&gt;

&lt;h1 id="toc_7"&gt;&lt;h4&gt;5.3&#x4E0B;&#x9762;&#x9A8C;&#x8BC1;&#x4E0B;&#x662F;&#x5426;&#x6B63;&#x5E38;&#x8FD0;&#x884C; &lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;# /opt/tools_src/qemu-2.2.0/out/bin/qemu-system-arm -M versatilepb -m 128M -kernel /opt/qemu_arm/linux-2.6.35.7/arch/arm/boot/compressed/vmlinux -S -s -nographic

[root@localhost qemu_arm]# arm-none-linux-gnueabi-gdb -q linux-2.6.35.7/arch/arm/boot/compressed/vmlinux
Reading symbols from /opt/qemu_arm/linux-2.6.35.7/arch/arm/boot/compressed/vmlinux...done.
(gdb) target extended-remote localhost:1234
Remote debugging using localhost:1234
start () at arch/arm/boot/compressed/head.S:115
115 #ifdef DEBUG
(gdb) set $r1=0x183
(gdb) c
Continuing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x4E00;&#x5207;&#x6B63;&#x5E38;.&lt;/p&gt;

&lt;h1 id="toc_8"&gt;&lt;h4&gt;6&#x76F8;&#x5173;&#x8D44;&#x6599;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;[&#x97E9;] &#x5C39;&#x9521;&#x8BAD; ARM Linux&#x5185;&#x6838;&#x6E90;&#x7801;&#x5256;&#x6790;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/11423784/qemu-arm-linux-kernel-boot-debug-no-source-code"&gt;http://stackoverflow.com/questions/11423784/qemu-arm-linux-kernel-boot-debug-no-source-code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/27655523/use-of-r0-lsr-32-in-the-return-sub-pc-lr-r0-lsr-32-with-mmu-cache-on"&gt;http://stackoverflow.com/questions/27655523/use-of-r0-lsr-32-in-the-return-sub-pc-lr-r0-lsr-32-with-mmu-cache-on&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x591A;&#x6838;&#x540C;&#x65F6;&#x83B7;&#x53D6;&#x8BFB;&#x5199;&#x9501;, &#x4F1A;&#x6B7B;&#x5FAA;&#x73AF;&#x5417;, &#x8FD8;&#x662F;&#x90FD;&#x5F97;&#x5230;&#x5199;&#x9501;</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_smp_rwlock</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;&#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;: http://blog.163.com/awaken_ing/blog/static/120613197201631133058159&lt;/p&gt;

&lt;p&gt;&#x672C;&#x7BC7;&#x53EA;&#x63D0;&#x95EE;, &#x4E0D;&#x89E3;&#x7B54;, &#x795D;&#x5F00;&#x5FC3;.&lt;/p&gt;

&lt;p&gt;&#x5982;&#x679C;&#x8BFB;&#x5199;&#x9501;&#x662F;unlocked, &#x7136;&#x540E;cpu 0&#x548C;cpu 1&#x90FD;&#x60F3;&#x83B7;&#x53D6;&#x5199;&#x9501;,
&#x5982;&#x8868;&#x683C;&#x6240;&#x793A;, CPU 0&#x5728;t2&#x65F6;&#x523B;&#x6267;&#x884C;&#x7684;&#x662F;wfene, &#x8FD9;&#x65F6;, CPU 1&#x6267;&#x884C;&#x7684;&#x662F;ldrex, &#x7136;&#x540E;&#x662F;&#x5426;&#x4F1A;&#x6709;cpu&#x80FD;&#x591F;&#x83B7;&#x53D6;&#x5230;&#x9501;?
&#x6E90;&#x7801;&#x6765;&#x81EA;
linux-3.10.86/arch/arm/include/asm/spinlock.h
arch_write_lock()&lt;/p&gt;

&lt;!--
&#x67E5;&#x770B;&#x6E90;&#x7801;&#x540E;, &#x5C06;&#x7B2C;1&#x4E2A;&lt;table&gt;&#x6539;&#x4E3A;
&lt;table class="table table-bordered table-striped table-condensed"&gt;

&#x65F6;&#x95F4; | CPU0                      |&#x65F6;&#x95F4;  |CPU1
-----|---------------------------|------|----
t0/t6| 1:    ldrex    %0, [%1]   |      |
t1/t7| teq    %0, #0             |      |
t2   |WFE("ne")                  |t2    |1:    ldrex    %0, [%1]
t3   |strexeq    %0, %2, [%1]    |t3    |teq    %0, #0
t4   |teq    %0, #0              |t4    |WFE("ne")
t5   |bne    1b                  |t5    |strexeq    %0, %2, [%1]
t6   |                           |t6    |teq    %0, #0
t7   |                           |t7    |bne    1b
--&gt;

&lt;table class="table table-bordered table-striped table-condensed"&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&#x65F6;&#x95F4;&lt;/th&gt;
&lt;th&gt;CPU0&lt;/th&gt;
&lt;th&gt;&#x65F6;&#x95F4;&lt;/th&gt;
&lt;th&gt;CPU1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;t0/t6&lt;/td&gt;
&lt;td&gt;1:    ldrex    %0, [%1]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t1/t7&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t2&lt;/td&gt;
&lt;td&gt;WFE(&amp;quot;ne&amp;quot;)&lt;/td&gt;
&lt;td&gt;t2&lt;/td&gt;
&lt;td&gt;1:    ldrex    %0, [%1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t3&lt;/td&gt;
&lt;td&gt;strexeq    %0, %2, [%1]&lt;/td&gt;
&lt;td&gt;t3&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t4&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;td&gt;t4&lt;/td&gt;
&lt;td&gt;WFE(&amp;quot;ne&amp;quot;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t5&lt;/td&gt;
&lt;td&gt;bne    1b&lt;/td&gt;
&lt;td&gt;t5&lt;/td&gt;
&lt;td&gt;strexeq    %0, %2, [%1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;t6&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;t7&lt;/td&gt;
&lt;td&gt;bne    1b&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;CPU 0&#x548C;CPU 1&#x90FD;&#x62FF;&#x5230; &#x5199;&#x9501;? &#x4E24;&#x4E2A;CPU&#x90FD;&#x6B7B;&#x5FAA;&#x73AF;? &#x597D;&#x50CF;&#x4E0D;&#x5E94;&#x8BE5;&#x554A;?
&#x672C;&#x7BC7;&#x53EA;&#x63D0;&#x95EE;, &#x4E0D;&#x89E3;&#x7B54;, &#x795D;&#x5F00;&#x5FC3;. ^_^&lt;/p&gt;

&lt;p&gt;&#x9644; linux-3.10.86/arch/arm/include/asm/spinlock.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void arch_write_lock(arch_rwlock_t *rw)
{
    unsigned long tmp;

    __asm__ __volatile__(
&amp;quot;1: ldrex   %0, [%1]\n&amp;quot;
&amp;quot;   teq %0, #0\n&amp;quot;
    WFE(&amp;quot;ne&amp;quot;)
&amp;quot;   strexeq %0, %2, [%1]\n&amp;quot;
&amp;quot;   teq %0, #0\n&amp;quot;
&amp;quot;   bne 1b&amp;quot;
    : &amp;quot;=&amp;amp;r&amp;quot; (tmp)
    : &amp;quot;r&amp;quot; (&amp;amp;rw-&amp;gt;lock), &amp;quot;r&amp;quot; (0x80000000)
    : &amp;quot;cc&amp;quot;);

    smp_mb();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>qemu&#x89C2;&#x5BDF;arm linux&#x542F;&#x52A8;&#x8FC7;&#x7A0B;02</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_qemu_02</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt; &#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2; 
http://blog.163.com/awaken_ing/blog/static/12061319720157119242210
&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. __create_page_tables&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;pgtbl r4 @ page table address
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5176;&#x4E2D;pgtbl&#x4E3A;&#x5B8F;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.macro pgtbl, rd
ldr \rd, =(KERNEL_RAM_PADDR - 0x4000)
.endm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;KERNEL_RAM_PADDR&#x548C;zreladdr&#x7684;&#x503C;&#x76F8;&#x7B49;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;1.1 identity mapping&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;/*
* Create identity mapping for first MB of kernel to
* cater for the MMU enable. This identity mapping
* will be removed by paging_init(). We use our current program
* counter to determine corresponding section base address.
*/
mov r6, pc
mov r6, r6, lsr #20 @ start of kernel section
orr r3, r7, r6, lsl #20 @ flags + kernel base
str r3, [r4, r6, lsl #2] @ identity mapping
@ &#x548C;arch\arm\boot\compressed\head.S&#x7C7B;&#x4F3C;
@ r3&#x5185;&#x5BB9;:
@ 31       20       19                 0  
@  PC&#x9AD8;12bit       __cpu_mm_mmu_flags
@&#x5B58;&#x653E;&#x7684;&#x5730;&#x5740;:
@   31          14           13            2                1 0  
@  &#x9875;&#x8868;&#x57FA;&#x5740;(0x4000)         &#x9875;&#x8868;index(pc&#x9AD8;12bit)              00  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x5EFA;&#x7ACB;&#x7684;&#x548C;This identity mapping &#x548C;arch/arm/boot/compressed/head.S&#x7C7B;&#x4F3C;.&lt;/p&gt;

&lt;p&gt;&#x56E0;&#x4E3A;.init&#x6BB5;&#x5927;&#x5C0F;&#x5C0F;&#x4E8E;1M&#xFF0C;&#x6240;&#x4EE5;&#x53EA;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;section entry, &#x5C31;&#x53EF;&#x4EE5;&#x5BB9;&#x7EB3;&#x4E0B;.&lt;/p&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x4E3A;&#x4F55;&#x8FD9;&#x91CC;&#x8981;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x9875;&#x8868;?&lt;/p&gt;

&lt;p&gt;&#x7B54;:&#x56E0;&#x4E3A;&#x540E;&#x9762;&#x8981;&#x5F00;mmu, &#x8FD9;&#x4E9B;&#x6CA1;&#x6709;&#x88AB;&#x6620;&#x5C04;&#x8FC7;&#x7684;&#x5E94;&#x8BE5;&#x5C31;&#x6CA1;&#x6CD5;&#x8BBF;&#x95EE;. &#x8BA9;&#x6211;&#x4EEC;&#x8BD5;&#x4E0B;&#x4E0D;&#x5EFA;&#x7ACB;&#x8FD9;&#x4E2A;&#x9875;&#x8868;&#x7684;&#x6548;&#x679C;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost qemu_arm]#  arm-none-linux-gnueabi-gdb -q 
(gdb) b *0x8000
Breakpoint 1 at 0x8000
(gdb) target extended-remote localhost:1234
Remote debugging using localhost:1234
0x00000000 in ?? ()

(gdb) add-symbol-file linux-2.6.35.7/vmlinux 0xc0027000  -s .init 0x8000
add symbol table from file &amp;quot;linux-2.6.35.7/vmlinux&amp;quot; at
    .text_addr = 0xc0027000
    .init_addr = 0x8000
(y or n) y
Reading symbols from /opt/qemu_arm/linux-2.6.35.7/vmlinux...done.
(gdb) b __create_page_tables
Breakpoint 2 at 0x8078

(gdb) c
Continuing.

Breakpoint 1, 0x00008000 in stext ()
(gdb) c
Continuing.

Breakpoint 2, 0x00008078 in __create_page_tables ()
(gdb) disass  $pc
Dump of assembler code for function __create_page_tables:
=&amp;gt; 0x00008078 &amp;lt;+0&amp;gt;: mov r4, #16384  ; 0x4000
   0x0000807c &amp;lt;+4&amp;gt;: mov r0, r4
   0x00008080 &amp;lt;+8&amp;gt;: mov r3, #0
   0x00008084 &amp;lt;+12&amp;gt;:    add r6, r0, #16384  ; 0x4000
   0x00008088 &amp;lt;+16&amp;gt;:    str r3, [r0], #4
   0x0000808c &amp;lt;+20&amp;gt;:    str r3, [r0], #4
   0x00008090 &amp;lt;+24&amp;gt;:    str r3, [r0], #4
   0x00008094 &amp;lt;+28&amp;gt;:    str r3, [r0], #4
   0x00008098 &amp;lt;+32&amp;gt;:    teq r0, r6
   0x0000809c &amp;lt;+36&amp;gt;:    bne 0x8088 &amp;lt;__create_page_tables+16&amp;gt;
   0x000080a0 &amp;lt;+40&amp;gt;:    ldr r7, [r10, #8]
   0x000080a4 &amp;lt;+44&amp;gt;:    mov r6, pc
   0x000080a8 &amp;lt;+48&amp;gt;:    lsr r6, r6, #20
   0x000080ac &amp;lt;+52&amp;gt;:    orr r3, r7, r6, lsl #20
   0x000080b0 &amp;lt;+56&amp;gt;:    str r3, [r4, r6, lsl #2]
   0x000080b4 &amp;lt;+60&amp;gt;:    add r0, r4, #12288  ; 0x3000
   0x000080b8 &amp;lt;+64&amp;gt;:    str r3, [r0]!
   0x000080bc &amp;lt;+68&amp;gt;:    ldr r6, [pc, #88]   ; 0x811c
   0x000080c0 &amp;lt;+72&amp;gt;:    add r0, r0, #4
   0x000080c4 &amp;lt;+76&amp;gt;:    add r6, r4, r6, lsr #18
---Type  to continue, or q  to quit---q
Quit

(gdb) c
Continuing.

Breakpoint 3, 0x000080b0 in __create_page_tables ()
(gdb) i r r3 r4 r6 pc
r3             0xc1e    3102
r4             0x4000   16384
r6             0x0  0
pc             0x80b0   0x80b0 &amp;lt;__create_page_tables+56&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x7B49;&#x6548;&#x4E8E;set *0x4000=0xc1e&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b __turn_mmu_on
Breakpoint 4 at 0x8060
(gdb) c
Continuing.

Breakpoint 4, 0x00008060 in __turn_mmu_on ()
(gdb) p /x *0x4000   &#x524D;&#x9762;&#x5EFA;&#x7ACB;&#x7684;&#x9875;&#x8868;&#x9879;
$2 = 0xc1e
(gdb) set *0x4000=0x0    &#x8FD9;&#x91CC;&#x4FEE;&#x6539;&#x9875;&#x8868;&#x9879;
(gdb) p /x *0x4000   &#x786E;&#x8BA4;&#x4FEE;&#x6539;
$3 = 0x0
(gdb) b __mmap_switched
Breakpoint 5 at 0x8148
(gdb) c
Continuing.
Remote connection closed
(gdb)



[root@localhost qemu_arm]# sh debug_boot.sh 
Uncompressing Linux... done, booting the kernel.
qemu: fatal: Trying to execute code outside RAM or ROM at 0xffff000c

R00=00093177 R01=00000183 R02=00000100 R03=1f0f1c12
R04=00004000 R05=0000001f R06=00003135 R07=00000c12
R08=00021bec R09=41069265 R10=00021bb8 R11=00000000
R12=005c6b7c R13=00000000 R14=0000806c R15=ffff000c
PSR=400001d7 -Z-- A abt32
s00=00000000 s01=00000000 d00=0000000000000000
s02=00000000 s03=00000000 d01=0000000000000000
s04=00000000 s05=00000000 d02=0000000000000000
s06=00000000 s07=00000000 d03=0000000000000000
s08=00000000 s09=00000000 d04=0000000000000000
s10=00000000 s11=00000000 d05=0000000000000000
s12=00000000 s13=00000000 d06=0000000000000000
s14=00000000 s15=00000000 d07=0000000000000000
s16=00000000 s17=00000000 d08=0000000000000000
s18=00000000 s19=00000000 d09=0000000000000000
s20=00000000 s21=00000000 d10=0000000000000000
s22=00000000 s23=00000000 d11=0000000000000000
s24=00000000 s25=00000000 d12=0000000000000000
s26=00000000 s27=00000000 d13=0000000000000000
s28=00000000 s29=00000000 d14=0000000000000000
s30=00000000 s31=00000000 d15=0000000000000000
FPSCR: 00000000
debug_boot.sh: line 6: 27036 Aborted                 qemu-system-arm -M versatilepb -m 128M -kernel /opt/qemu_arm/linux-2.6.35.7/arch/arm/boot/zImage -nographic -S -s
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;1.2 &#x5C06;&#x5185;&#x6838;&#x6620;&#x5C04;&#x5230;&#x4EE5;0xC0008000&#x4E3A;&#x8D77;&#x59CB;&#x5730;&#x5740;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;/*
* Now setup the pagetables for our kernel direct
* mapped region.
*/
add r0, r4, #(KERNEL_START &amp;amp; 0xff000000) &amp;gt;&amp;gt; 18
str r3, [r0, #(KERNEL_START &amp;amp; 0x00f00000) &amp;gt;&amp;gt; 18]!
ldr r6, =(KERNEL_END - 1)
add r0, r0, #4
add r6, r4, r6, lsr #18
1: cmp r0, r6
add r3, r3, #1 &amp;lt;&amp;lt; 20
strls r3, [r0], #4
bls 1b
@KERNEL_START&#x4E3A;0xc000 8000
@ #(KERNEL_START &amp;amp; 0xff000000) &amp;gt;&amp;gt; 18 &#x4E3A;0x3000
@#(KERNEL_START &amp;amp; 0x00f00000) &amp;gt;&amp;gt; 18 &#x4E3A; 0
@ &#x9879;&#x5B58;&#x653E;&#x5230;&#x54EA;&#x4E2A;&#x7269;&#x7406;&#x5730;&#x5740;&#x53BB;&#x5462;:
@   31..14                 13..2                1 0  
@  &#x9875;&#x8868;&#x57FA;&#x5740;(0x4000)       &#x9875;&#x8868;index(pc&#x9AD8;12bit)    00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x8FD9;&#x91CC;&#x521B;&#x5EFA;&#x7684;&#x4E0D;&#x662F;identity mappings, &#x5982;&#x4F55;&#x770B;&#x51FA;&#x6765;?&lt;/p&gt;

&lt;p&gt;&#x7B54;:&#x56E0;&#x4E3A;#(KERNEL_START &amp;amp; 0xff000000)&#x662F;&#x865A;&#x62DF;&#x5730;&#x5740;, &#x8D85;&#x8FC7;&#x4E86;&#x7269;&#x7406;&#x5185;&#x5B58;&lt;/p&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x4E3A;&#x4F55; #(KERNEL_START &amp;amp; 0x00f00000) &amp;gt;&amp;gt; 18 ?&lt;/p&gt;

&lt;p&gt;&#x7B54;:&#x662F;&#x56E0;&#x4E3A;add&#x548C;str&#x6307;&#x4EE4;&#x7684;&#x673A;&#x5668;&#x7801;&#x7684;&#x683C;&#x5F0F;, &#x80FD;&#x591F;&#x8868;&#x793A;&#x7684;&#x7ACB;&#x5373;&#x6570;&#x8303;&#x56F4;&#x53D7;&#x9650;.&lt;br&gt;
add&#x7684; &#x683C;&#x5F0F;: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ADD &amp;lt;suffix&amp;gt; &amp;lt;dest&amp;gt;, &amp;lt;op 1&amp;gt;, &amp;lt;op 2&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;!---
31 - 28   | 27 | 26 | 25 | 24 - 21 | 20 | 19 - 16 | 15 - 12 | 11 - 0
----------|----|----|----|---------|----|---------|---------|----------
condition | 0  | 0  | I  | 0 1 0 0 | S  |   op_1  | dest    | op_2/shift
---&gt;

&lt;table class="table table-bordered table-striped table-condensed"&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;31 - 28&lt;/th&gt;
&lt;th&gt;27&lt;/th&gt;
&lt;th&gt;26&lt;/th&gt;
&lt;th&gt;25&lt;/th&gt;
&lt;th&gt;24 - 21&lt;/th&gt;
&lt;th&gt;20&lt;/th&gt;
&lt;th&gt;19 - 16&lt;/th&gt;
&lt;th&gt;15 - 12&lt;/th&gt;
&lt;th&gt;11 - 0&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;condition&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;0 1 0 0&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;op_1&lt;/td&gt;
&lt;td&gt;dest&lt;/td&gt;
&lt;td&gt;op_2/shift&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;2. &#x770B;&#x4E0B;sp&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;start_kernel&#x524D;&#x8BBE;&#x7F6E;sp&#x4E3A;init_thread_union + THREAD_START_SP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define THREAD_START_SP (THREAD_SIZE - 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-2.6.35.7\arch\arm\kernel\init_task.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;union thread_union init_thread_union __init_task_data =
{ INIT_THREAD_INFO(init_task) };

/* Attach to the init_task data structure for proper alignment */
#define __init_task_data __attribute__((__section__(&amp;quot;.data..init_task&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;arch/arm/kernel/vmlinux.lds.S&#x4E2D;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;. = ALIGN(THREAD_SIZE);
__data_loc = .;

.data : AT(__data_loc) {
    _data = .;      /* address in memory */
    _sdata = .;

    /*
     * first, the init task union, aligned
     * to an 8192 byte boundary.
     */
    INIT_TASK_DATA(THREAD_SIZE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5176;&#x4E2D;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define INIT_TASK_DATA(align)                       \
    . = ALIGN(align);                       \
    *(.data..init_task)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x4E3A;&#x4F55;&#x8981;&#x7528;&#x8054;&#x5408;&#x4F53;union thread_union ?
&#x7B54;:&#x7531;&#x4E8E;&#x6808;&#x662F;&#x5411;&#x4F4E;&#x5730;&#x5740;&#x751F;&#x957F;, thread_info&#x662F;&#x5411;&#x9AD8;&#x5730;&#x5740;&#x751F;&#x957F;, &#x8FD9;&#x6837;&#x5C31;&#x76F8;&#x5F53;&#x4E8E;&#x5171;&#x7528;HREAD_SIZE-8.&lt;/p&gt;

&lt;p&gt;&#x518D;&#x770B;&#x770B;&#x4E3A;&#x4F55;-8&lt;br&gt;
&#x51CF;&#x53BB;&#x67D0;&#x4E2A;&#x6570;, &#x662F;&#x56E0;&#x4E3A; &#x8FD9;&#x6837;&#x5C31;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline struct thread_info *current_thread_info(void)
{
register unsigned long sp asm (&amp;quot;sp&amp;quot;);
return (struct thread_info *)(sp &amp;amp; ~(THREAD_SIZE - 1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5F97;&#x5230;thread_info&#x7684;&#x8D77;&#x59CB;&#x5730;&#x5740;, &#x6240;&#x4EE5;, &#x8981;&#x51CF;&#x53BB;&#x67D0;&#x4E2A;&#x6B63;&#x6570;.
&#x51CF;&#x53BB;8, &#x800C;&#x4E0D;&#x662F;&#x522B;&#x7684;, &#x662F;&#x56E0;&#x4E3A;sp&#x8981;8&#x5BF9;&#x9F50;, &#x4E14;&#x5C3D;&#x91CF;&#x4E0D;&#x6D6A;&#x8D39;&#x7A7A;&#x95F4;. &#x53C2;&#x89C1;[2]&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;3. &#x76F8;&#x5173;&#x8D44;&#x6599;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;[1] http://lli_njupt.0fees.net/ar01s08.html&lt;/p&gt;

&lt;p&gt;[2] &lt;a href="http://stackoverflow.com/questions/25237607/in-arm-linux-what-is-the-purpose-of-the-few-bytes-reserved-at-the-bottom-of-k/25244273#2524427"&gt;http://stackoverflow.com/questions/25237607/in-arm-linux-what-is-the-purpose-of-the-few-bytes-reserved-at-the-bottom-of-k/25244273#2524427&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>SLUB 02:frozen</title>
      <link>https://awakening-fong.github.io/posts/mm/slub_frozen</link>
      <pubDate>2017-01-14</pubDate>
      <description>&lt;p&gt;&#x672C;&#x6587;&#x5047;&#x5B9A;&#x6CA1;&#x6709;&#x6253;&#x5F00;CONFIG_SLUB_DEBUG, &#x6CA1;&#x6709;&#x914D;&#x7F6E;CONFIG_NUMA.&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4EC0;&#x4E48;&#x662F;frozen&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/slub.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; *   If a slab is frozen then it is exempt(&#x514D;&#x9664;) from list management. It is not
 *   on any list. It is not on any list. The processor that froze the slab is the one who can
 *   perform list operations on the page. Other processors may put objects
 *   onto the freelist but the processor that froze the slab is the only
 *   one that can retrieve the objects from the page&amp;#39;s freelist.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpu01&#x7684;c-&amp;gt;page&#x662F;frozen, &#x90A3;&#x4E48;cpu01&#x53EF;&#x4EE5;&#x4ECE;&#x8BE5;page&#x4E2D;&#x53D6;&#x51FA;&#x6216;&#x653E;&#x56DE;obj, 
cpu02&#x4E0D;&#x80FD;&#x4ECE;&#x8BE5;page&#x4E2D;&#x53D6;obj, &#x53EA;&#x80FD;&#x628A;obj&#x8FD8;&#x7ED9;&#x8BE5;page.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. cpu partial&#x4E0A;&#x7684;page&#x90FD;&#x662F;frozen&#x72B6;&#x6001;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/include/linux/slub_def.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct kmem_cache_cpu {
...
    struct page *partial;   /* Partially allocated frozen slabs */
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c-&amp;gt;partial &#x90FD;&#x662F; &#x51BB;&#x4F4F;&#x7684;?&lt;br&gt;
&#x7B54;:&#x662F;&#x7684;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__slab_alloc
|--new_slab:
|   |--if (c-&amp;gt;partial) 
|   |   |--page = c-&amp;gt;page = c-&amp;gt;partial;
|   |   |--c-&amp;gt;partial = page-&amp;gt;next;
|   |   |--c-&amp;gt;freelist = NULL;
|--redo:
|   |--freelist = c-&amp;gt;freelist;
|--freelist = get_freelist(s, page); //obj01 -&amp;gt; obj02 -&amp;gt; obj03 -&amp;gt; NULL, get_freelist&#x8FD4;&#x56DE;obj01
|   |--...
|   |--page-&amp;gt;freelist = NULL;  //&#x4E3A;&#x540E;&#x7EED;&#x5F52;&#x8FD8;obj&#x5230;&#x8BE5;page&#x505A;&#x597D;&#x51C6;&#x5907;.
|   |--return page_bk-&amp;gt;freelist;
|--load_freelist:
|   |--VM_BUG_ON(!c-&amp;gt;page-&amp;gt;frozen);   //c-&amp;gt;partial&#x4E0A;&#x7684;page&#x90FD;&#x662F;frozen&#x7684;. page&#x53EA;&#x6709;frozen&#x7684;&#x624D;&#x53EF;&#x4F5C;&#x4E3A;c-&amp;gt;page
|   |-- c-&amp;gt;freelist = get_freepointer(s, freelist);//c-&amp;gt;freelist&#x6307;&#x5411;obj02
|   |-- c-&amp;gt;tid = next_tid(c-&amp;gt;tid);
|   |-- return freelist; //freelist&#x6307;&#x5411;obj01
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. node partial&#x4E0A;&#x7684;page&#x90FD;&#x662F;unfrozen&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;get_partial_node
{
    list_for_each_entry_safe(page, page2, &amp;amp;n-&amp;gt;partial, lru) {
        acquire_slab
        {
            VM_BUG_ON(new.frozen); //n-&amp;gt;partial&#x4E0A;&#x7684;page&#x90FD;&#x662F; &#x6CA1;&#x6709;&#x51BB; &#x7684;.
            new.frozen = 1;
            remove_partial(n, page);
        }
        ...
        c-&amp;gt;page = page  or  put_cpu_partial &#x4E24;&#x76F8;&#x5B9C;. page&#x90FD;&#x662F;frozen&#x7684;.
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. c-&amp;gt;page&#x8981;&#x6C42;frozen&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;__slab_alloc
|--local_irq_save(flags);
|--freelist =new_slab_objects //buddy&#x7684;page&#x7684;&#x9996;&#x4E2A;obj
|   |--page = new_slab(s, flags, node); //&#x5047;&#x5B9A;&#x5728;cpu0&#x4E0A;
|   |   |--page-&amp;gt;frozen = 1;
|   |--c = __this_cpu_ptr(s-&amp;gt;cpu_slab) //new_slab()&#x6BD4;&#x8F83;&#x6162;, &#x73B0;&#x5728;&#x8FDB;&#x7A0B;&#x53EF;&#x80FD;&#x8FC1;&#x79FB;&#x5230;cpu1&#x4E0A;
|   |--freelist = page-&amp;gt;freelist;
|   |--page-&amp;gt;freelist = NULL;
|   |--c-&amp;gt;page = page; //c-&amp;gt;page&#x7684;page  &#x5176;freelist &#x4E3A; NULL, &#x4E14;frozen &#x4E3A; 1.
|--goto load_freelist
|   |--That page must be frozen for per cpu allocations to work.
|   |--VM_BUG_ON(!c-&amp;gt;page-&amp;gt;frozen); 
|   |--&#x4FEE;&#x6539;c-&amp;gt;freelist  c-&amp;gt;tid
|   |--local_irq_restore(flags);
|   |--return freelist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x4E2A;&#x8BBE;&#x8BA1;&#x725B;&#x903C;&#x4E86;, &#x5141;&#x8BB8;&#x540C;&#x65F6;&#x4ECE;&#x540C;&#x4E00;&#x4E2A;page  &#x4E00;&#x7AEF;&#x53D6;&#x51FA; , &#x800C;&#x5728;&#x53E6;&#x4E00;&#x7AEF;&#x653E;&#x56DE;.
&#x53D6;&#x51FA;&#x901A;&#x8FC7;c-&amp;gt;freelist;&lt;br&gt;
&#x628A;&#x67D0;obj&#x653E;&#x56DE;, &#x6BD4;&#x5982;&#x628A;obj_t2&#x653E;&#x56DE;, &#x901A;&#x8FC7;obj_t2&#x627E;&#x5230;&#x5176;&#x6240;&#x5C5E;&#x7684;page, &#x7136;&#x540E;&#x653E;&#x56DE;page-&amp;gt;freepointer, &#x5F62;&#x6210;&#x94FE;&#x8868;:&lt;br&gt;
obj_t2 -&amp;gt;  obj_t1 -&amp;gt; NULL.&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;5. &#x8017;&#x5C3D;c-&amp;gt;page&#x7684;obj&#x540E;&#x89E3;&#x51BB;page&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;static inline void *get_freelist(struct kmem_cache *s, struct page *page)
{
    VM_BUG_ON(!new.frozen);
    ... 
    /*
    if NULL, then unfreeze. &#x89E3;&#x51BB;
    if !NULL, then &#x7EF4;&#x6301;frozen
    */
    new.frozen = freelist != NULL;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5982;&#x679C;c-&amp;gt;page&#x6CA1;&#x6709;obj&#x4F9B;&#x5206;&#x914D;&#x4E86;, &#x90A3;&#x4E48;&#x5C31;&#x89E3;&#x51BB;&#x4E86;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>SLUB 03:partial&#x548C;cpu partial</title>
      <link>https://awakening-fong.github.io/posts/mm/slub_partial</link>
      <pubDate>2017-01-14</pubDate>
      <description>&lt;p&gt;&#x4E3B;&#x8981;&#x4ECB;&#x7ECD;partial&#x548C;cpu partial&#x7684;&#x4EA7;&#x751F;.&lt;br&gt;
&#x5185;&#x6838;&#x672A;&#x5B9A;&#x4E49; CONFIG_NUMA&lt;/p&gt;

&lt;p&gt;partial&#x6CA1;&#x6709;&#x6307;&#x660E;&#x662F;node partial&#x8FD8;&#x662F;cpu partial&#x65F6;, &#x5219;&#x6307;&#x7684;&#x662F;node partial.&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. node partial&#x7684;&#x4EA7;&#x751F;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5728;cpu0&#x4E0A;&#x6267;&#x884C;new_slab_objects -&amp;gt; new_slab, &#x7531;&#x4E8E;&#x53EF;&#x80FD;&#x7761;&#x7720;, &#x4E4B;&#x540E;&#x53EF;&#x80FD;&#x8FD0;&#x884C;&#x5728;cpu1&#x4E0A;. &#x8FD9;&#x65F6;&#x82E5;cpu1&#x7684;c-&amp;gt;page&#x975E;&#x7A7A;, &#x5219;&#x6839;&#x636E;&#x60C5;&#x51B5;, &#x53EF;&#x80FD;&#x5C06;&#x5176;&#x653E;&#x5165;node partial&#x4E2D;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/mm/slub.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__slab_alloc
|--local_irq_save(flags);
|--freelist =new_slab_objects //buddy&#x7684;page&#x7684;&#x9996;&#x4E2A;obj
|    |--page = new_slab(s, flags, node); //&#x5728;cpu0&#x4E0A;
|    |--c = __this_cpu_ptr(s-&amp;gt;cpu_slab) //&#x8FDB;&#x7A0B;&#x53EF;&#x80FD;&#x8FC1;&#x79FB;&#x5230;cpu1&#x4E0A;
|    |--if (c-&amp;gt;page) flush_slab(s, c);

flush_slab(struct kmem_cache *s, struct kmem_cache_cpu *c)
|-- deactivate_slab(s, c-&amp;gt;page, c-&amp;gt;freelist)


static void deactivate_slab(struct kmem_cache *s, struct page *page, void *freelist)
{

    /*
     while&#x5FAA;&#x73AF;&#x524D;:
     obj_t2 -&amp;gt; obj_t1 -&amp;gt; NULL
     ^
     @page-&amp;gt;freelist

     obj_03 -&amp;gt; obj_02 -&amp;gt; obj_01 -&amp;gt; NULL
     ^
     @freelist


     &#x5FAA;&#x73AF;&#x5355;&#x6B21;&#x540E;:   
     obj_03   -&amp;gt;  obj_t2  -&amp;gt; obj_t1 -&amp;gt; NULL
     ^
     page-&amp;gt;freelist 


     obj_02 -&amp;gt; obj_01 -&amp;gt; NULL
     ^
     freelist

     &#x518D;&#x6765;&#x4E00;&#x56DE;:
     obj_02 -&amp;gt; obj_03   -&amp;gt;  obj_t2  -&amp;gt; obj_t1 -&amp;gt; NULL
     ^
     page-&amp;gt;freelist


     obj_01 -&amp;gt; NULL
     ^
     freelist

     &#x95EE;&#x9898;:&#x4E3A;&#x4F55;&#x4E0D;&#x76F4;&#x63A5;&#x4FEE;&#x6539;&#x6307;&#x9488;&#x628A;&#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x4E32;&#x8D77;&#x6765;, &#x800C;&#x662F;&#x8981;&#x4E00;&#x4E2A;&#x4E00;&#x4E2A;object&#x7684;&#x653E;&#x5230;&#x94FE;&#x8868;&#x4E2D;?
     &#x7B54;:&#x56E0;&#x4E3A;&#x8981;&#x4FEE;&#x6539;counters, &#x6240;&#x4EE5;&#x8981;&#x4E00;&#x4E2A;&#x4E00;&#x4E2A;&#x6570;.
    */
    while (freelist &amp;amp;&amp;amp; (nextfree = get_freepointer(s, freelist))) {
        ...
    }

    ....

    /*
    &#x5982;&#x679C;&#x8FD9;&#x91CC;freelist&#x4E3A;NULL, &#x8BF4;&#x660E;@freelist&#x4F20;&#x5165;&#x65F6;&#x5C31;&#x4E3A;NULL
    */
    /*&#x628A;the last one&#x4E5F;&#x63A5;&#x4E0A;*/
    if (freelist) {
        new.inuse--;
        /* 
        new-&amp;gt;freelist
        v
        obj_01 -&amp;gt; obj_02 -&amp;gt; obj_03   -&amp;gt;  obj_t2  -&amp;gt; obj_t1 -&amp;gt; NULL
        ^
        freelist
        */
        set_freepointer(s, freelist, old.freelist);
        new.freelist = freelist;
    } else
        ...

    new.frozen = 0;

    //&#x6709;M_FREE, M_PARTIAL&#x7B49;&#x60C5;&#x51B5;, &#x8FD9;&#x91CC;&#x53EA;&#x770B;M_PARTIAL
    ...

    if (m == M_PARTIAL) {
        /*&#x95EE;&#x9898;:&#x4E3A;&#x4F55;&#x4E0D;&#x662F;put_cpu_partial()?*/
        add_partial(n, page, tail);

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_1"&gt;&lt;h4&gt;2. cpu partial&#x7684;&#x4EA7;&#x751F;&lt;/h4&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;kmem_cache_free -&amp;gt; slab_free(s, virt_to_head_page(x), x, ...)
|-- if (page != c-&amp;gt;page) __slab_free
|   |--n = NULL
|   |-- &#x539F;&#x5148;obj&#x94FE;&#x8868;&#x4E3A;: -&amp;gt; NULL , &#x91CA;&#x653E;obj_t3&#x540E;&#x4E3A;: -&amp;gt; obj_t3 -&amp;gt; NULL
|   |-- new.inuse--; 
|   |--if (!prior) &amp;amp;&amp;amp; !was_frozen)new.frozen = 1;//obj_t3&#x6240;&#x5C5E;&#x7684;page, &#x9664;obj_t3&#x5916;, &#x6CA1;&#x6709;&#x5176;&#x4ED6;obj&#x53EF;&#x4F9B;&#x5206;&#x914D;&#x4E86;.
|   |--if (!new.inuse)&amp;amp;&amp;amp; !was_frozen) n = get_node //obj&#x653E;&#x56DE;page&#x540E;, page&#x5C31;&#x662F;&#x5B8C;&#x6574;&#x7684;, &#x6253;&#x7B97;&#x628A;page&#x653E;&#x5230;node partial&#x4E2D;
|--if (likely(!n)) //&#x4E0D;&#x653E;&#x56DE;node 
|   |--if (new.frozen &amp;amp;&amp;amp; !was_frozen) put_cpu_partial(s, page, 1)//&#x5F53;&#x524D;page&#x6CA1;&#x4EBA;&#x63A5;&#x7BA1;, &#x5219;&#x653E;&#x56DE;cpu partial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4EC0;&#x4E48;&#x60C5;&#x51B5;&#x4E0B;was_frozen&#x4F1A;&#x662F;0?&lt;br&gt;
&#x7B54;: c-&amp;gt;page&#x628A;obj&#x5206;&#x914D;&#x5149;&#x4E86;, c-&amp;gt;page&#x5C31;&#x5904;&#x4E8E;unforzen&#x72B6;&#x6001;, &#x63A5;&#x4E0B;&#x6765;&#x5176;&#x4ED6;page&#x4F5C;&#x4E3A;c-&amp;gt;page.
&#x8FD9;&#x65F6;&#x7684;page&#x5904;&#x4E8E;&#x6BD4;&#x8F83;&#x6709;&#x8DA3;&#x7684;&#x4E00;&#x79CD;&#x72B6;&#x6001;, struct kmem_cache&#x6CA1;&#x6709;&#x5B57;&#x6BB5;&#x7BA1;&#x7406;&#x8FD9;&#x4E2A;page,
struct kmem_cache_cpu&#x4E5F;&#x6CA1;&#x6709;&#x94FE;&#x8868;&#x7BA1;&#x7406;&#x8FD9;&#x4E2A;page. &#x6211;&#x4EEC;&#x53EA;&#x80FD;&#x901A;&#x8FC7;obj&#x6765;&#x627E;&#x5230;&#x8BE5;page.
&#x73B0;&#x5728;&#x91CA;&#x653E;obj, &#x6211;&#x4EEC;&#x5C31;&#x6709;&#x673A;&#x4F1A;&#x628A;&#x8FD9;&#x4E9B;&#x7279;&#x6B8A;&#x72B6;&#x6001;&#x7684;page&#x6536;&#x96C6;&#x8D77;&#x6765;, &#x5C06;&#x5176;&#x653E;&#x5165;cpu partial.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__slab_alloc
|--page = c-&amp;gt;page;
|--freelist = c-&amp;gt;freelist;
|-- if freelist &#x4E3A;&#x7A7A;
|   |--freelist = get_freelist(s, page);
|   |   |--/*if NULL, then unfreeze &#x89E3;&#x51BB;. if !NULL, then &#x7EF4;&#x6301;frozen */
|   |   |--new.frozen = freelist != NULL;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>SLUB 04:tid</title>
      <link>https://awakening-fong.github.io/posts/mm/slub_tid</link>
      <pubDate>2017-01-14</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. tid&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/include/linux/slub_def.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct kmem_cache_cpu {
    ...
    unsigned long tid;  /* Globally unique transaction id */
    ..
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/mm/slub.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifdef CONFIG_PREEMPT
/*
 * Calculate the next globally unique transaction for disambiguiation
 * during cmpxchg. The transactions start with the cpu number and are then
 * incremented by CONFIG_NR_CPUS.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x4E00;&#x6B21;&#x4E0D;&#x662F;&#x52A0;1, &#x800C;&#x662F;&#x52A0;CONFIG_NR_CPUS, &#x4E3A;&#x5565;?&lt;br&gt;
&#x7B54;:&#x8FD9;&#x4E2A;&#x8BBE;&#x8BA1;&#x662F;&#x4E3A;&#x4E86;&#x8BA9;&#x4EFB;&#x4F55;&#x65F6;&#x523B;&#x6BCF;&#x4E2A;cpu&#x7684;tid&#x503C;&#x90FD;&#x4E0D;&#x4E00;&#x6837;.
&#x4E0D;&#x8FC7;&#x4E0A;&#x9762;&#x7684;&#x6CE8;&#x91CA;&#x6709;&#x70B9;&#x8001;, &#x56E0;&#x4E3A;&#x5B9E;&#x9645;&#x5E76;&#x4E0D;&#x662F;&#x52A0;CONFIG_NR_CPUS, &#x800C;&#x662F;TID_STEP.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5148;&#x770B;&#x4E0B;&#x4E3A;&#x4F55;&#x52A0;CONFIG_NR_CPUS&#x4E5F;&#x662F;&#x9519;&#x8BEF;&#x7684;:&lt;br&gt;
linux-3.10.86/mm/slub.c &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void init_kmem_cache_cpus(struct kmem_cache *s)
{
    int cpu;

    for_each_possible_cpu(cpu)
        per_cpu_ptr(s-&amp;gt;cpu_slab, cpu)-&amp;gt;tid = init_tid(cpu);
}


&#x6BCF;&#x4E2A;cpu&#x5BF9;tid+ CONFIG_NR_CPUS, &#x672C;&#x4F8B;&#x4E2D;&#x662F;3&#x4E2A;cpu:
        cpu0 cpu1  cpu2
&#x521D;&#x59CB;&#x503C;:  0    1      2
         3    4      5
         6    7      0   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpu2&#x7684;tid  &#x548C; cpu0&#x7684;tid &#x53EF;&#x80FD;&#x51FA;&#x73B0;&#x76F8;&#x540C;&#x7684;&#x503C;, &#x672C;&#x4F8B;&#x4E2D;&#x4E3A;0, BUG&#x51FA;&#x73B0;.&lt;br&gt;
&#x5982;&#x679C;cpu&#x4E2A;&#x6570;&#x4E0D;&#x662F; 2^x&#x7684;&#x8BDD;, &#x5982;&#x679C;&#x6BCF;&#x6B21; &#x9012;&#x589E;CONFIG_NR_CPUS&#x7684;&#x8BDD;, &#x5C31;&#x4F1A;&#x51FA;&#x73B0;&#x4E0A;&#x9762;&#x4F8B;&#x5B50;&#x7684;BUG.&lt;br&gt;
&#x53EF;&#x4EE5;&#x6539;&#x4E3A; &#x9012;&#x589E;2^x, &#x8FD9;&#x6837;, &#x76F8;&#x5F53;&#x4E8E; &#x5404;&#x4E2A;cpu&#x7684;&#x4F4E;xbit  Dx-1~D0&#x4E0D;&#x53D8;, &#x53EA;&#x6709;&#x8F83;&#x9AD8;&#x4F4D;&#x5728;&#x53D8;.
&#x8FD9;&#x6837;&#x5C31;&#x53EF;&#x4EE5;&#x4FDD;&#x8BC1;&#x5404;cpu&#x7684;tid&#x6C38;&#x4E0D;&#x76F8;&#x540C;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x5E94;&#x7528;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=9aabf810a67cd97e2d1a48f0bab338b7680f1929"&gt;http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=9aabf810a67cd97e2d1a48f0bab338b7680f1929&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We had to insert a preempt enable/disable in the fastpath a while ago in order to guarantee that tid and kmem_cache_cpu are retrieved on the same cpu. It is the problem only for CONFIG_PREEMPT in which scheduler can move the process to other cpu during retrieving data. Now, I reach the solution to remove preempt enable/disable in the fastpath. If tid is matched with kmem_cache_cpu&amp;#39;s tid after tid and kmem_cache_cpu are retrieved by separate this_cpu operation, it means that they are retrieved on the same cpu. If not matched, we just have to retry it. With this guarantee, preemption enable/disable isn&amp;#39;t need at all even if CONFIG_PREEMPT, so this patch removes it.&lt;/p&gt;

&lt;p&gt;I saw roughly 5% win in a fast-path loop over kmem_cache_alloc/free in CONFIG_PREEMPT. (14.821 ns -&amp;gt; 14.049 ns)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x5C06;__kmalloc -&amp;gt; slab_alloc -&amp;gt; slab_alloc_node &#x4E2D;: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;preempt_disable();
c = __this_cpu_ptr(s-&amp;gt;cpu_slab);
tid = c-&amp;gt;tid;
preempt_enable();
object = c-&amp;gt;freelist;
page = c-&amp;gt;page;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6539;&#x4E3A;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; * We should guarantee that tid and kmem_cache are retrieved on
 * the same cpu. It could be different if CONFIG_PREEMPT so we need
 * to check if it is matched or not.
 */
do {
    tid = this_cpu_read(s-&amp;gt;cpu_slab-&amp;gt;tid);
    c = raw_cpu_ptr(s-&amp;gt;cpu_slab);
} while (IS_ENABLED(CONFIG_PREEMPT) &amp;amp;&amp;amp; unlikely(tid != c-&amp;gt;tid));

/*
 * Irqless object alloc/free algorithm used here depends on sequence
 * of fetching cpu_slab&amp;#39;s data. tid should be fetched before anything
 * on c to guarantee that object and page associated with previous tid
 * won&amp;#39;t be used with current tid. If we fetch tid first, object and
 * page could be one associated with next tid and our alloc/free
 * request will be failed. In this case, we will retry. So, no problem.
 */
barrier();
object = c-&amp;gt;freelist;
page = c-&amp;gt;page;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>SLUB 01:the SLUB allocator&#x7684;&#x76F8;&#x5173;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x548C;&#x4E3B;&#x8981;&#x6D41;&#x7A0B;</title>
      <link>https://awakening-fong.github.io/posts/mm/slub_slab_alloc</link>
      <pubDate>2017-01-12</pubDate>
      <description>&lt;p&gt;&#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x65E7;&#x535A;&#x5BA2;:  blog.163.com/awaken_ing/blog/static/1206131972016316114114855&lt;/p&gt;

&lt;p&gt;&#x5E73;&#x53F0; ARM Versatile Express for Cortex-A9 SMP&lt;br&gt;
&#x5185;&#x6838;&#x7248;&#x672C; 3.10.86 (&#x672A;&#x5B9A;&#x4E49; CONFIG_NUMA)  &lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x6982;&#x89C8;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;The SLUB allocator &#x76F8;&#x6BD4;SLAB, &#x8BD5;&#x56FE; remove the metadata overhead inside slabs, reduce the number of caches, and so on.
The only metadata present in the SLUB allocator is the in-object &#x201C;next-free-object&#x201D; pointer, which allows us to link free objects together. struct kmem_cache &#x7684;&#x6210;&#x5458; int offset &#x7528;&#x6765;&#x6307;&#x660E; &#x6307;&#x9488;&#x5728; object &#x4E2D;&#x7684;&#x504F;&#x79FB;&#x91CF;, &#x8FD9;&#x4E2A;&#x6307;&#x9488;&#x6307;&#x5411;&#x7684;&#x662F;&#x4E0B;&#x4E00;&#x4E2A;&#x53EF;&#x7528;&#x7684;object. How does the allocator manage to find the first free object? The answer lies in the approach of saving a pointer to such an object inside each page struct associated with the slab page.
SLUB allocator &#x6CA1;&#x6709;SLAB&#x7684;full list &#x548C; empty list.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/slub_01.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x56FE;&#x7247;&#x6765;&#x81EA; &lt;a href="http://events.linuxfoundation.org/sites/events/files/slides/slaballocators.pdf"&gt;http://events.linuxfoundation.org/sites/events/files/slides/slaballocators.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;linux-3.10.86/mm/slub.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;slab_alloc() -&amp;gt; slab_alloc_node()
slab_alloc_node(struct kmem_cache *s, ...
{
    struct kmem_cache_cpu *c=__this_cpu_ptr(s-&amp;gt;cpu_slab);
    object = c-&amp;gt;freelist;
    if fastpath {
        void *next_object = get_freepointer_safe(s, object);
        c-&amp;gt;freelist=next_object; //via  this_cpu_cmpxchg_double()
    }else
        ...
    return object;
}
static inline void *get_freepointer(struct kmem_cache *s, void *object)
{
    return *(void **)(object + s-&amp;gt;offset);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x4ECE;slowpath&#x770B;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x548C;&#x6D41;&#x7A0B;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;slab_alloc_node()&#x4E2D;&#x7684;slowpath&#x4E3A; __slab_alloc().&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct kmem_cache {
    struct kmem_cache_cpu __percpu *cpu_slab;
...
    struct list_head list;    /* List of slab caches */
...
    struct kmem_cache_node *node[MAX_NUMNODES];
};
struct kmem_cache_cpu {
    void **freelist;    /* Pointer to next available object */
...
    struct page *page;    /* The slab from which we are allocating */
    struct page *partial;    /* Partially allocated frozen slabs */
...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6267;&#x884C;__slab_alloc()&#x8FD9;&#x4E2A;slowpath&#x7684;&#x539F;&#x56E0;&#x662F; kmem_cache per cpu&#x7684;freelist&#x7684;object&#x7684;&#x5355;&#x5411;&#x94FE;&#x8868;&#x5F62;&#x5F0F;&#x7684;object &#x5DF2;&#x7528;&#x5B8C; ( kmem_cache-&amp;gt;cpu_slab-&amp;gt;freelist == NULL ).&lt;br&gt;
&lt;code&gt;__slab_alloc()&lt;/code&gt;&#x4E2D;&#x5148;&#x4F7F;&#x7528;kmem_cache per cpu&#x7684;page&#x7684;freelist: cpu_slab-&amp;gt;freelist=cpu_slab-&amp;gt;page-&amp;gt;freelist; cpu_slab-&amp;gt;page-&amp;gt;freelist=NULL;&lt;br&gt;
&#x5982;&#x679C;&#x4E5F;&#x7528;&#x5B8C;&#x4E86;, &#x5219;&#x5C1D;&#x8BD5; cpu_slab-&amp;gt;partial&#x53CA;&#x5176;&#x94FE;&#x8868;&#x4E0A;&#x7684;page&#x7684;object.&lt;br&gt;
&#x5982;&#x679C;&#x8FD8;&#x662F;&#x6CA1;&#x6709;object, &#x4E5F;&#x5C31;&#x662F;per cpu&#x4E0A;&#x7684;object&#x90FD;&#x8017;&#x5149;&#x4E86;, &#x5219;&#x6267;&#x884C;__slab_alloc()&#x4E2D;&#x7684;new_slab_objects():&lt;br&gt;
&#x4F7F;&#x7528; kmem_cache_node-&amp;gt;partial-&amp;gt;next (&#x6307;&#x5411;page&#x7684;lru)&#x6240;&#x5728;&#x7684;page, &#x603B;&#x5171;&#x6709;nr_partial&#x4E2A;&#x8FD9;&#x6837;&#x7684;page, &#x53D6;freelist&#x4E0D;&#x4E3A;&#x7A7A;&#x7684;page. &#x8FD9;&#x91CC;&#x91C7;&#x53D6;&#x7684;&#x662F;&#x6279;&#x91CF;&#x64CD;&#x4F5C;&#x65B9;&#x5F0F;, &#x53D6;&#x51FA;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;page&#x5212;&#x7ED9;c-&amp;gt;page, &#x5176;&#x4ED6;page&#x653E;&#x5165;cpu partial.
&#x5982;&#x679C;&#x4E5F;&#x6CA1;&#x6709;, &#x5219;&#x6267;&#x884C;new_slab(). &#x5982;&#x4E0B;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new_slab_objects
|--get_partial
|    |--//&#x4ECE;struct kmem_cache_node&#x7684;partial&#x8FD9;&#x4E2A;&#x53CC;&#x5411;&#x94FE;&#x8868;&#x4E2D;&#x627E;, &#x5982;&#x679C;&#x627E;&#x5230;, &#x5219;&#x5212;&#x5165; c-&amp;gt;page&#x548C;struct kmem_cache_cpu &#x7684;page&#x94FE;&#x8868; (&#x901A;&#x8FC7;struct page&#x7684;next)
|    |--get_partial_node  
|--fallback to new_slab()
|    |--allocate_slab
|    |    |--alloc_slab_page(..., struct kmem_cache&#x7684;oo)  &#x4ECE;buddy system&#x5206;&#x914D;, order&#x6839;&#x636E;oo&#x6765;
|    |    |--fallback to alloc_slab_page(..., struct kmem_cache&#x7684;min) order&#x6839;&#x636E;min&#x6765;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5173;&#x4E8E;struct kmem_cache_order_objects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allocate_slab
|--alloc_pages(..., oo_order(oo))
|--page-&amp;gt;objects = oo_objects(oo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6210;&#x5458;x&#x7684;&#x9AD8;16bit&#x4E3A;order, &#x4F4E;16bit&#x4E3A;struct page&#x7684;unsigned objects.&lt;br&gt;
struct kmem_cache_order_objects { unsigned long x; };&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x81EA;&#x95EE;&#x81EA;&#x7B54;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x95EE;:&#x6709;&#x4E9B;&#x60C5;&#x51B5;&#x4E0B;, &#x4E00;&#x4E2A;slabs&#x8981;&#x5360;&#x7528;&#x591A;&#x4E2A;pages, &#x8BF4;&#x8BF4;&#x6709;&#x5565;&#x4E0D;&#x540C;?&lt;br&gt;
&#x7B54;: new_slab() &#x4ECE;buddy system&#x4E2D;&#x5206;&#x914D;compound page, &#x6545;compound page&#x8BE5;&#x6709;&#x7684;&#x7279;&#x5F81;&#x90FD;&#x6709;, &#x5177;&#x4F53;&#x7279;&#x5F81;&#x89C1; linux-3.10.86/mm/page_alloc.c:prep_new_page().&lt;/p&gt;

&lt;p&gt;compound page&#x4E2D;&#x53EA;&#x6709;head page&#x8BBE;&#x7F6E;PG_Slab, tail pages&#x6CA1;&#x6709;&#x8BBE;&#x7F6E;PG_Slab.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new_slab
{
__SetPageSlab(page)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. &#x53C2;&#x8003;&#x8D44;&#x6599;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://lwn.net/Articles/229984/"&gt;https://lwn.net/Articles/229984/&lt;/a&gt;&lt;br&gt;
&lt;a href="http://events.linuxfoundation.org/sites/events/files/slides/slaballocators.pdf"&gt;http://events.linuxfoundation.org/sites/events/files/slides/slaballocators.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;h4 style="BACKGROUND-COLOR: rgb(204,255,255);"   &gt;5. &#x9644;SLUB&#x65F6;struct page&#x7ED3;&#x6784;&#x4F53;&lt;/h3&gt;&lt;pre&gt;&lt;p&gt;struct page {&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; /* First double word block&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned long flags;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct address_space &lt;em&gt;mapping;&lt;/p&gt;&lt;p&gt;/&lt;/em&gt; Second double word &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct {&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; union {&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; pgoff_t index;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; Our offset within mapping. &lt;em&gt;/&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; void *freelist;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; slub/slob first free object &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; bool pfmemalloc;&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; union {&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned counters;&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct {&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; union {&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; atomic_t _mapcount;&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct { /&lt;/em&gt; SLUB &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned inuse:16;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned objects:15;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned frozen:1;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; int units;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; SLOB &lt;em&gt;/&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; atomic_t _count;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; Usage count, see below. &lt;em&gt;/&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; }; /&lt;/em&gt; end of Second double word &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; Third double word block &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; union {&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct list_head lru;&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; slub per cpu partial pages &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct page *next;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; Next partial slab &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; short int pages;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; short int pobjects;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct list_head list;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; slobs list of pages &lt;em&gt;/&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct slab *slab_page; /&lt;/em&gt; slab fields &lt;em&gt;/&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&amp;nbsp; /&lt;/em&gt; end of Third double word block &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; Remainder is not double word aligned &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; union {&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsigned long private;&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; spinlock_t ptl;&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct kmem_cache *slab_cache;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; SL[AU]B: Pointer to slab &lt;em&gt;/&lt;/p&gt;&lt;p&gt;&lt;s&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; struct page *first_page;&amp;nbsp;&amp;nbsp;&amp;nbsp; /&lt;/em&gt; Compound tail pages */&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; };&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; ...&lt;/p&gt;&lt;p&gt;};&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>&#x8C03;&#x5EA6;&#x5668;, &#x4ECE;lost wake-up problem&#x8BF4;&#x8D77;</title>
      <link>https://awakening-fong.github.io/posts/scheduler/scheduler_01_lost_wake-up</link>
      <pubDate>2017-01-11</pubDate>
      <description>&lt;p&gt;&#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2; blog.163.com/awaken_ing/blog/static/1206131972016124113539444/&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;0. &#x5F15;&#x8A00;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;The lost wake-up problem &#x8BF7;&#x53C2;&#x8003; &lt;a href="http://www.linuxjournal.com/article/8144"&gt;http://www.linuxjournal.com/article/8144&lt;/a&gt;&lt;br&gt;
&#x672C;&#x7BC7;&#x4E3B;&#x8981;&#x89E3;&#x91CA;&#x4E3A;&#x4F55;&#x4FEE;&#x6539;&#x540E;&#x7684;&#x4EE3;&#x7801;&#x6CA1;&#x6709;&#x95EE;&#x9898;.
&#x4FEE;&#x6539;&#x540E;&#x7684;&#x4EE3;&#x7801;&#x4E3A;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1  set_current_state(TASK_INTERRUPTIBLE);
2  spin_lock(&amp;amp;list_lock);
3  if(list_empty(&amp;amp;list_head)) {
4         spin_unlock(&amp;amp;list_lock); //&#x5982;&#x679C;&#x8FD9;&#x91CC;&#x9762;&#x8BA9;&#x51FA;cpu?
//&#x5982;&#x679C;&#x5728;&#x8FD9;&#x4E2A;&#x70B9;&#x88AB;&#x751F;&#x4EA7;&#x8005;&#x5524;&#x9192;&#x4F1A;&#x5982;&#x4F55;?
5         schedule();
6         spin_lock(&amp;amp;list_lock);
7  }
8  set_current_state(TASK_RUNNING);
9
10 /* Rest of the code ... */
11 spin_unlock(&amp;amp;list_lock);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;1. &#x5148;&#x89E3;&#x91CA;linux journal&#x4E0A;&#x7684;&#x5185;&#x5BB9;&lt;/h4&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;The change is that whenever a wake_up_process is called for a process whose state is TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE, and the process has not yet called schedule(), the state of the process is changed back to TASK_RUNNING.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x672C;&#x6587;&#x5047;&#x5B9A;&#x8C03;&#x5EA6;&#x5668;&#x4F7F;&#x7528;&#x7684;&#x662F;CFS. &#x5047;&#x5B9A;&#x5728;&#x7B2C;4&#x884C;&#x548C;&#x7B2C;5&#x884C;&#x4E4B;&#x95F4; &#x8FDB;&#x7A0B;B&#x8C03;&#x7528; wake_up_process().&lt;br&gt;
linux-3.10.86/kernel/sched/core.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wake_up_process
{
return try_to_wake_up(p, TASK_NORMAL,0);
}

#define TASK_NORMAL        (TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)

try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)
{
    int success = 0;
    if (! (p-&amp;gt;state &amp;amp; state) )
        goto out; //not our case
    ...

    if (p-&amp;gt;on_rq &amp;amp;&amp;amp; ttwu_remote(p, wake_flags)) //our case
        goto stat;
    ...
out:
...
    return success;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ttwu_remote -&amp;gt; ttwu_do_wakeup -&amp;gt; p-&amp;gt;state = TASK_RUNNING;&lt;br&gt;
&#x8FDB;&#x7A0B;TASK_RUNNING&#x4E0B;&#x8C03;&#x7528;schedule() :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__schedule
{
if(prev-&amp;gt;state &amp;amp;&amp;amp;...)
    deactivate_task   //not our case
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0==TASK_RUNNING, &#x6240;&#x4EE5;,&lt;br&gt;
&#x8FD9;&#x4E2A;if (prev-&amp;gt;state)&#x7B49;&#x6548;&#x4E8E;if ( prev-&amp;gt;state != TASK_RUNNING )&lt;br&gt;
&#x6240;&#x4EE5;, TASK_RUNNING&#x8C03;&#x7528;schedule()&#x4E0D;&#x4F1A;&#x8C03;&#x7528;&#x5230;deactivate_task().&lt;/p&gt;

&lt;p&gt;deactivate_task &#x90FD;&#x5B8C;&#x6210;&#x5565;&#x52A8;&#x4F5C;???&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;2. &#x518D;&#x770B;&#x770B;&#x53E6;&#x5916;&#x4E00;&#x79CD;&#x60C5;&#x51B5;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5728;&#x7B2C;4&#x884C;spin_unlock()&#x4E2D;, &#x5982;&#x679C;&#x662F;&#x4E2A;&#x62A2;&#x5360;&#x7684;&#x65F6;&#x673A;, &#x90A3;&#x4E48;&#x4E0D;&#x662F;&#x76F4;&#x63A5;&#x8C03;&#x7528;schedule(), &#x800C;&#x662F;&#x8C03;&#x7528; preempt_schedule()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;preempt_schedule
{
...
    add_preempt_count_notrace(PREEMPT_ACTIVE);
    __schedule();
    sub_preempt_count_notrace(PREEMPT_ACTIVE);
...
}

__schedule
{
    if (prev-&amp;gt;state &amp;amp;&amp;amp; !( preempt_count() &amp;amp; PREEMPT_ACTIVE )) {
        if(...)
        {
            deactivate_task
            prev-&amp;gt;on_rq = 0;
        }

    }
    put_prev_task(rq, prev);    
    next = pick_next_task(rq);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x7684;!( preempt_count() &amp;amp; PREEMPT_ACTIVE )&#x5C31;&#x4E0D;&#x4F1A;&#x6EE1;&#x8DB3;, &#x5C31;&#x4E0D;&#x4F1A;&#x6267;&#x884C;deactivate_task().&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;3. &#x91CD;&#x65B0;&#x6302;&#x5230;&#x7EA2;&#x9ED1;&#x6811;&#x4E0A;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x7531;&#x4E8E;&#x5F53;&#x524D;&#x8FD0;&#x884C;&#x7684;&#x8FDB;&#x7A0B;&#x5728;&#x88AB;&#x9009;&#x4E2D;&#x8FD0;&#x884C;&#x65F6;, &#x5C31;&#x88AB;&#x79FB;&#x51FA;&#x7EA2;&#x9ED1;&#x6811;&#x4E86;. &#x4E0A;&#x9762;&#x4E24;&#x79CD;&#x60C5;&#x51B5;&#x4E2D;, se&#x8282;&#x70B9;&#x53C8;&#x662F;&#x5982;&#x4F55;&#x91CD;&#x65B0;&#x653E;&#x5230;rbtree&#x4E0A;&#x7684;&#x5462;? &#x770B;put_prev_entity() :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;put_prev_entity(...)
{
    if(prev-&amp;gt;on_rq){
        __enqueue_entity(cfs_rq, prev);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x662F;&#x8FD9;&#x91CC;&#x7684; put_prev_entity()&#x5C06;&#x8282;&#x70B9;&#x91CD;&#x65B0;&#x653E;&#x5230;rbtree&#x4E0A;.&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;4. &#x9632;&#x8303;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x65E2;&#x7136;&#x5BB9;&#x6613;&#x51FA;&#x73B0;&#x4E0A;&#x9762;&#x7684;&#x95EE;&#x9898;, &#x90A3;&#x4E48;, &#x5185;&#x6838;&#x662F;&#x5982;&#x4F55;&#x5904;&#x7406;&#x8FD9;&#x4E2A;&#x95EE;&#x9898;&#x7684;&#x5462;? &#x7B54;&#x6848;&#x662F;&#x5185;&#x6838;&#x63D0;&#x4F9B;&#x4E86;&#x5B8F;__wait_event, &#x53EF;&#x53C2;&#x8003;&#x5176;&#x5199;&#x6CD5;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define __wait_event(wq, condition)                     \
do{                                    \
    DEFINE_WAIT(__wait);                        \
                                    \
    for(;;){                            \
        prepare_to_wait(&amp;amp;wq,&amp;amp;__wait, TASK_UNINTERRUPTIBLE);    \
        if(condition)                        \
            break;                        \
        schedule();                        \
    }                                \
    finish_wait(&amp;amp;wq,&amp;amp;__wait);                    \
}while(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prepare_to_wait(... , TASK_UNINTERRUPTIBLE) &#x4F1A;&#x8BBE;&#x7F6E;&#x8FDB;&#x7A0B;&#x7684;&#x72B6;&#x6001;&#x4E3A;TASK_UNINTERRUPTIBLE,&lt;br&gt;
finish_wait()&#x8BBE;&#x7F6E;&#x72B6;&#x6001;&#x4E3A;TASK_RUNNING. &lt;/p&gt;
</description>
    </item>
    <item>
      <title>&#x4EC5;&#x68C0;&#x67E5;TIF_NEED_RESCHED,&#x4E0D;&#x68C0;&#x67E5;preempt_count?</title>
      <link>https://awakening-fong.github.io/posts/scheduler/scheduler_02_preempt</link>
      <pubDate>2017-01-11</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4F55;&#x65F6;&#x8BBE;&#x7F6E; TIF_NEED_RESCHED&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4EFB;&#x52A1;task01&#x8FD8;&#x6CA1;&#x6709;&#x5B8C;&#x6210;, &#x4F46;&#x8C03;&#x5EA6;&#x5668;&#x8BA4;&#x4E3A; &#x5176;&#x8FD0;&#x884C;&#x7684;&#x591F;&#x4E45;&#x4E86;, &#x5C31;&#x8BBE;&#x7F6E;TIF_NEED_RESCHED, &#x8FD9;&#x6837;, &#x5728;&#x5408;&#x9002;&#x7684;&#x65F6;&#x673A;, task01&#x5C31;&#x4F1A;&#x88AB;&#x8C03;&#x5EA6;&#x8D70;, &#x7531;&#x5176;&#x4ED6;task&#x4F7F;&#x7528;cpu.&lt;/p&gt;

&lt;p&gt;&#x9664;&#x4E86;scheduler_tick&#x4F1A;&#x8BBE;&#x7F6E;&#x5916;, &#x5F53;&#x4E00;&#x4E2A;&#x4F18;&#x5148;&#x7EA7;&#x9AD8;&#x7684;&#x8FDB;&#x7A0B;&#x8FDB;&#x5165;&#x53EF;&#x6267;&#x884C;&#x72B6;&#x6001;&#x7684;&#x65F6;&#x5019;, try_to_wake_up()&#x4E5F;&#x4F1A;&#x8BBE;&#x7F6E;&#x8FD9;&#x4E2A;&#x6807;&#x5FD7;&#x3002;&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x4E0D;&#x68C0;&#x67E5;preempt_count?&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4F8B; linux-3.10.86/arch/arm/kernel/entry-armv.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__vector_irq()
|--__irq_usr()  @entry-armv.S
|   |--usr_entry()
|   |--irq_handler()
|   |--ret_to_user_from_irq() @entry-common.S
|   |   |--work_pending()   
|   |   |   |--do_work_pending @signal.c

do_work_pending
{
    do {
        if (likely(thread_flags &amp;amp; _TIF_NEED_RESCHED))
            schedule();
        else
           ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x4EC5;&#x5224;&#x65AD;_TIF_NEED_RESCHED, &#x6CA1;&#x6709;&#x5224;&#x65AD; preempt_count, &#x4E3A;&#x5565;?&lt;br&gt;
&#x96BE;&#x9053;&#x8BF4;, &#x7981;&#x7528;&#x62A2;&#x5360;&#x4F9D;&#x65E7;&#x4F1A;&#x53D1;&#x751F;&#x62A2;&#x5360;?&lt;br&gt;
&#x7B54;: &#x5047;&#x5B9A;&#x8FD9;&#x4E2A;&#x65F6;&#x95F4;&#x70B9;&#x4E0A;, preempt_count&#x4E0D;&#x4E3A;0, &#x90A3;&#x4E48;, &#x4E4B;&#x540E;&#x5C31;&#x8FD4;&#x56DE;&#x7528;&#x6237;&#x6001;, &#x6CA1;&#x6709;&#x673A;&#x4F1A;&#x518D;&#x64CD;&#x4F5C; preempt_count&#x4E86;.&lt;br&gt;
&#x8FD9;&#x6837;&#x5C31;&#x76F8;&#x5F53;&#x4E8E; &#x5728;&#x5185;&#x6838;&#x6001;&#x8FC7;&#x7A0B;&#x4E2D; &#x5BF9;preempt count&#x8FDB;&#x884C;&#x7684;&#x52A0;&#x51CF;&#x4E0D;&#x5E73;&#x8861;, &#x8FD9;&#x4E8B;&#x4E0D;&#x8BE5;&#x53D1;&#x751F;, &#x6545;&#x5F53;&#x524D;&#x5207;&#x6362;&#x5230;&#x7528;&#x6237;&#x6001;&#x524D;, &#x5E76;&#x6CA1;&#x6709;&#x68C0;&#x67E5;preempt_count(). &#x6211;&#x4EEC;&#x8BA4;&#x4E3A;&#x5176;&#x7ED3;&#x679C;&#x662F;&#x53EF;&#x4EE5;&#x9884;&#x89C1;, &#x603B;&#x662F;0, &#x5141;&#x8BB8;&#x62A2;&#x5360;&#x53D1;&#x751F;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x7684;switch_to</title>
      <link>https://awakening-fong.github.io/posts/scheduler/scheduler_03_switch_to</link>
      <pubDate>2017-01-11</pubDate>
      <description>&lt;p&gt;&#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;: blog.163.com/awaken_ing/blog/static/12061319720158310574442/&lt;/p&gt;

&lt;p&gt;&amp;lt;&amp;lt; Professional Linux Kernel Architecture &amp;gt;&amp;gt; page105&#x6807;&#x9898;&#x4E3A; Intricacies of switch_to (intricacies:&#x9519;&#x7EFC;&#x590D;&#x6742;&#x7684;) , &#x7D6E;&#x7D6E;&#x53E8;&#x53E8;&#x7740;switch_to.&lt;/p&gt;

&lt;p&gt;&#x4E0B;&#x9762;&#x770B;&#x4E0B;arm linux&#x7684;&#x60C5;&#x51B5;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context_switch(struct rq *rq, struct task_struct *prev,
           struct task_struct *next)
{
...
switch_to(prev, next, prev);
barrier();
 /*
&#x5047;&#x5B9A;&#x8FDB;&#x7A0B;A&#x88AB;&#x8C03;&#x51FA;&#x53BB;, &#x8FDB;&#x7A0B;B&#x8FD0;&#x884C;, &#x5373;switch_to(A, B, A)
&#x90A3;&#x4E48;, &#x8FD9;&#x91CC;&#x662F;&#x521A;&#x624D;&#x88AB;&#x8C03;&#x5EA6;&#x8D70;&#x7684;&#x8FDB;&#x7A0B;A &#x6062;&#x590D;&#x8FD0;&#x884C;&#x540E;, &#x4F1A;&#x6267;&#x884C;&#x8FD9;&#x4E2A;&#x5730;&#x65B9;, 
&#x8981;&#x9A8C;&#x8BC1;&#x7684;&#x8BDD;, &#x53EF;&#x4EE5;&#x770B;&#x770B;&#x8FDB;&#x7A0B;A&#x8BA9;&#x51FA;CPU&#x524D;, &#x6700;&#x540E;&#x4E00;&#x6761;&#x4FEE;&#x6539;lr&#x7684;&#x6307;&#x4EE4;.
*/
 finish_task_switch(this_rq(), prev);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FDB;&#x7A0B;A&#x8BA9;&#x51FA;CPU&#x524D;, &#x6700;&#x540E;&#x4E00;&#x6761;&#x4FEE;&#x6539;lr&#x7684;&#x6307;&#x4EE4;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) disass schedule
...
0xc02b997c &amp;lt;+648&amp;gt;:  bl  0xc02bb514 &amp;lt;__switch_to&amp;gt;
0xc02b9980 &amp;lt;+652&amp;gt;:  bl  0xc0043524 &amp;lt;finish_task_switch&amp;gt;
...

(gdb) disass __switch_to
...
0xc02bb51c &amp;lt;+8&amp;gt;:    stmia   r12!, {r4, r5, r6, r7, r8, r9, r10, r11, sp, lr}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6700;&#x540E;&#x4E00;&#x6761;&#x4FEE;&#x6539;lr&#x7684;&#x6307;&#x4EE4;&#x4E3A;bl, &#x4E4B;&#x540E;__switch_to()&#x4E2D;&#x7684;stmia&#x6307;&#x4EE4;&#x5C06;lr&#x4FDD;&#x5B58;&#x5230;struct thread_info&#x7684;&#x6210;&#x5458;struct cpu_context_save    cpu_context&#x4E2D;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define switch_to(prev,next,last) \
do {    \
    last = __switch_to(prev,task_thread_info(prev), task_thread_info(next)); \
} while (0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="/assets/media/switch_to.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x4E66;&#x4E2D;&#x6709;&#x4E0A;&#x56FE;, &#x8FDB;&#x7A0B;A&#x88AB;&#x8C03;&#x5EA6;&#x51FA;&#x53BB;&#x540E;, &#x4E4B;&#x540E;&#x53C8;&#x51C6;&#x5907;&#x6295;&#x5165;&#x8FD0;&#x884C;, &#x4E5F;&#x5C31;&#x662F;&#x51C6;&#x5907;&#x6267;&#x884C;context_switch()&#x4E2D;&#x7684;switch_to(), &#x8FD9;&#x65F6;, &#x4E3A;&#x4F55;&#x4E0D;&#x662F; next==B, prev==A, &#x800C;&#x662F;prev==C.&lt;/p&gt;

&lt;p&gt;(__switch_to()&#x7684;&#x8FD4;&#x56DE;&#x503C;? &#x4ECE;&#x6C47;&#x7F16;&#x6765;&#x770B;, &#x6CA1;&#x6709;&#x7528;&#x5230;&#x8FD9;&#x4E2A;&#x8FD4;&#x56DE;&#x503C;.)&lt;br&gt;
&#x8FDB;&#x7A0B;A&#x6062;&#x590D;&#x8FD0;&#x884C;(&#x8FDB;&#x7A0B;C&#x8C03;&#x7528;switch_to( , &#x8FDB;&#x7A0B;A ,))&#x540E;, prev&#x8FD9;&#x4E2A;&#x8FDB;&#x7A0B;&#x6808;&#x5185;&#x7684;&#x53D8;&#x91CF;&#x53D8;&#x4E86;, &#x662F;&#x56E0;&#x4E3A;__switch_to&#x4E2D;&lt;/p&gt;

&lt;p&gt;linux-2.6.35.7/arch/arm/kernel/entry-armv.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ENTRY(__switch_to)
...
 ARM(    stmia    ip!, {r4 - sl, fp, sp, lr} )    @ Store most regs on stack
&#x2026;
 ARM(    ldmia    r4, {r4 - sl, fp, sp, pc}  )    @ Load all regs saved previously
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x5E76;&#x6CA1;&#x6709;&#x4FDD;&#x5B58;r0&#x6216;r1.&lt;/p&gt;

&lt;p&gt;switch_to()&#x7684;r0, &#x5728;  &#x8FDB;&#x7A0B;&#x5207;&#x6362;&#x524D;&#x540E; &#x8FDB;&#x884C;&#x4F20;&#x9012;, &#x7528;&#x6765;&#x544A;&#x8BC9; &#x5207;&#x6362;&#x540E;&#x7684;&#x8FDB;&#x7A0B;  &#x524D;&#x9762;&#x7684;struct task_struct &#x4FE1;&#x606F;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>&#x8C03;&#x5EA6;&#x5668;CFS&#x7684;&#x5B9E;&#x73B0;</title>
      <link>https://awakening-fong.github.io/posts/scheduler/scheduler_00_implementation</link>
      <pubDate>2017-01-10</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x6982;&#x8FF0;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4E3B;&#x8981;&#x89C6;&#x89D2;&#x662F;, &#x8003;&#x8651;&#x8981;&#x591A;&#x4E45;&#x624D;&#x80FD;&#x8F6E;&#x5230;&#x67D0;&#x4E2A;&#x8FDB;&#x7A0B;&#x7684;&#x8FD0;&#x884C;, (&#x79F0;&#x4E4B;&#x4E3A;targeted preemption latency) &#x800C;&#x4E0D;&#x662F;&#x6BCF;&#x4E2A;&#x8FDB;&#x7A0B;&#x5206;&#x914D;&#x591A;&#x5C11;&#x4EFD;&#x7684;&#x65F6;&#x95F4;&#x7247;.&lt;/p&gt;

&lt;p&gt;&#x5BF9;&#x5355;&#x4E2A;&#x8FDB;&#x7A0B; &#x8FBE;&#x5230; &#x65F6;&#x95F4;&#x6BB5;t1&#x5185;&#x88AB;&#x81F3;&#x5C11;&#x8C03;&#x5EA6;&#x4E00;&#x6B21;&#x5230;, &#x5BF9;&#x6240;&#x6709;&#x7684;&#x8FDB;&#x7A0B;&#x90FD;&#x8FBE;&#x5230;&#x7684;&#x8BDD;, &#x5C31;&#x662F;, &#x65F6;&#x95F4;&#x6BB5;t1&#x5185;&#x6240;&#x6709;&#x8FDB;&#x7A0B;&#x90FD;&#x8DD1;&#x4E00;&#x904D;.
the interval during which every runnable task should run at least once.
&#x8FD9;&#x4E2A;&#x65F6;&#x95F4;&#x6BB5;t1&#x6211;&#x4EEC;&#x6210;&#x4E3A; one latency period.&lt;/p&gt;

&lt;p&gt;&#x672C;&#x6587;&#x4EC5;&#x8BA8;&#x8BBA;SCHED_NORMAL.
&#x4E14;&#x6CA1;&#x6709;&#x4F7F;&#x80FD;CONFIG_FAIR_GROUP_SCHED. &#x5185;&#x6838;&#x7248;&#x672C;3.10.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x65F6;&#x95F4;&#x7684;&#x8BA1;&#x7B97;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x7B49;&#x4E86;&#x591A;&#x4E45;, &#x5177;&#x4F53;&#x5982;&#x4F55;&#x91CF;&#x5316;?&lt;br&gt;
&#x6BCF;&#x6B21;&#x8BA1;&#x7B97;&#x65F6;&#x95F4;, &#x82E5;&#x662F;&#x9010;&#x4E2A;&#x7ED9;&#x6BCF;&#x4E2A;TASK_RUNNING&#x8FDB;&#x7A0B;&#x8BA1;&#x7B97;, &#x8FD9;&#x6837;&#x52BF;&#x5FC5;&#x4F4E;&#x6548;,
&#x6240;&#x4EE5;, &#x5B9E;&#x73B0;&#x4E0A;, &#x4E0D;&#x5E94;&#x8BE5;&#x662F;&#x9010;&#x4E2A;&#x8FDB;&#x7A0B;&#x5224;&#x65AD;&#x7B49;&#x5F85;&#x7684;&#x65F6;&#x95F4;.&lt;br&gt;
&#x5F53;&#x524D;&#x7684;&#x5B9E;&#x73B0;&#x662F;, &#x8BB0;&#x5F55;&#x5404;&#x8FDB;&#x7A0B;&#x8FD0;&#x884C;&#x6240;&#x5360;&#x7528;&#x7684;&#x65F6;&#x95F4;, &#x8FD0;&#x884C;&#x5360;&#x7528;&#x65F6;&#x95F4;&#x7684;&#x53E6;&#x4E00;&#x9762;, &#x5C31;&#x662F; &#x6CA1;&#x6709;&#x8FD0;&#x884C;. &#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;&#x8FD0;&#x884C;&#x65F6;&#x95F4;&#x4E45;, &#x5176;&#x4ED6;&#x8FDB;&#x7A0B;&#x6CA1;&#x6709;&#x8FD0;&#x884C;&#x6216;&#x8005;&#x7B49;&#x5F85;&#x7684;&#x65F6;&#x95F4;&#x5C31;&#x4E45;. &#x6545;&#x53EF;&#x4EE5;&#x4EC5;&#x8BB0;&#x5F55;&#x8FD0;&#x884C;&#x65F6;&#x95F4;&#x6765;&#x53CD;&#x5E94;&#x7B49;&#x5F85;&#x65F6;&#x95F4;, &#x8FD9;&#x4E2A;&#x8FD0;&#x884C;&#x7684;&#x65F6;&#x95F4;&#x8BB0;&#x4E3A;vruntime.&lt;/p&gt;

&lt;h3 id="toc_2"&gt;&lt;h4&gt;2.1 vruntime&lt;/h4&gt;&lt;/h3&gt;

&lt;p&gt;virtual run time, &#x8FD0;&#x884C;&#x65F6;&#x95F4;&#x7ECF;&#x52A0;&#x6743;&#x540E;&#x7684;&#x6570;&#x636E;, &#x52A0;&#x6743;&#x65B9;&#x6CD5;&#x4E3A;&lt;/p&gt;

&lt;p&gt;update_curr -&amp;gt; __update_curr -&amp;gt; calc_delta_fair&lt;/p&gt;

&lt;p&gt;&#x5982;&#x4F55;&#x5904;&#x7406;overflow&#x95EE;&#x9898;?
...&lt;/p&gt;

&lt;h2 id="toc_3"&gt;&lt;h4&gt;2.2 &#x4F55;&#x65F6;&#x7EDF;&#x8BA1;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x7EDF;&#x8BA1;&#x5DF2;&#x4F7F;&#x7528;&#x7684;&#x65F6;&#x95F4;, &#x7531;update_curr()&#x5B8C;&#x6210;. &#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x6709;:  &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&#x6700;&#x5E38;&#x89C1;&#x7684;&#x662F;&#x5468;&#x671F;&#x6027;&#x7684;&#x65F6;&#x949F;&#x4E2D;&#x65AD;, scheduler_tick -&amp;gt; curr-&amp;gt;sched_class-&amp;gt;task_tick(...);  =&amp;gt; task_tick_fair  -&amp;gt; entity_tick -&amp;gt; update_curr&lt;/li&gt;
&lt;li&gt;&#x5176;&#x4ED6;&#x7684;&#x672C;&#x6587;&#x4E0D;&#x8BA8;&#x8BBA;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;3. &#x7B56;&#x7565;/&#x673A;&#x5236;&lt;/h4&gt;&lt;/h1&gt;

&lt;h2 id="toc_5"&gt;&lt;h4&gt;3.1 &#x5206;&#x914D;&#x591A;&#x5C11;&#x5408;&#x9002;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x82E5;&#x5206;&#x914D;&#x7684;&#x592A;&#x5C11;, &#x5219;&#x9891;&#x7E41;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;, &#x5F15;&#x8D77;&#x4E0D;&#x5FC5;&#x8981;overhead, &#x6545;&#x7ED9;&#x6BCF;&#x4E2A;&#x8FDB;&#x7A0B;&#x8FD0;&#x884C;&#x7684;&#x65F6;&#x95F4;&#x4E0D;&#x5B9C;&#x592A;&#x77ED;, &#x6240;&#x4EE5;, &#x5B9A;&#x4E49;&#x4E86;&lt;code&gt;sysctl_sched_min_granularity&lt;/code&gt;, &#x8FD9;&#x6837;, &#x60F3;&#x8981;&#x5728;&lt;code&gt;sysctl_sched_latency&lt;/code&gt;&#x5185;&#x88AB;&#x8C03;&#x5EA6;&#x4E00;&#x904D;&#x7684;&#x8BDD;, &#x90A3;&#x4E48; &#x60F3;&#x8981;&#x8FD0;&#x884C;&#x7684;&#x8FDB;&#x7A0B;&#x7684;&#x91CF; &amp;lt;= &lt;code&gt;sched_nr_latency&lt;/code&gt;.  &amp;gt;= &lt;code&gt;sysctl_sched_latency&lt;/code&gt;&#x7684;&#x8BDD;, &lt;code&gt;sysctl_sched_latency&lt;/code&gt;&#x8FD9;&#x4E2A;&#x5EF6;&#x8FDF;&#x5C31;&#x65E0;&#x6CD5;&#x4FDD;&#x8BC1;.&lt;/p&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x5982;&#x679C;&#x7CFB;&#x7EDF;&#x6709;nr_running&#x4E2A;&#x8FDB;&#x7A0B;, &#x90A3;&#x4E48;, &#x6BCF;&#x4E2A;&#x8FDB;&#x7A0B;&#x5206;&#x914D;&#x5230;&#x7684;&#x65F6;&#x95F4;&#x4E3A;: sysctl_sched_latency &#xD7; nr_running/sched_nr_latency&lt;/p&gt;

&lt;p&gt;&#x5B9E;&#x9645;&#x8BA1;&#x7B97;&#x65F6;, &#x8FD8;&#x8981;&#x7ED3;&#x5408;&#x4F18;&#x5148;&#x7EA7;, &#x4EE3;&#x7801;&#x5728; sched_slice()&lt;/p&gt;

&lt;p&gt;timeslices in CFS are of variable length. &lt;/p&gt;

&lt;h2 id="toc_6"&gt;&lt;h4&gt;3.2 &#x4F55;&#x65F6;&#x8F6E;&#x5230;&#x4E0B;&#x4E00;&#x4E2A;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x5982;&#x4F55;&#x77E5;&#x9053; &#x8FDB;&#x7A0B;&#x8FD0;&#x884C;&#x5F97;&#x5DEE;&#x4E0D;&#x591A;&#x4E86;, &#x8BE5;&#x8F6E;&#x5230;&#x4E0B;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;&#x4E86;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scheduler_tick
|--curr-&amp;gt;sched_class-&amp;gt;task_tick(...);  =&amp;gt; task_tick_fair
|   |--entity_tick
|   |   |--update_curr
|   |   |--check_preempt_tick
|   |   |   |-- if (delta_exec &amp;gt; ideal_runtime) resched_task
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x200B;&#x8FD9;&#x91CC;&#x6CA1;&#x6709;&#x770B;&#x5230;&#x4E0D;&#x8BA9;&#x8FD0;&#x884C;.&lt;br&gt;
linux-3.10.86/kernel/sched/core.c  &lt;code&gt;__schedule()&lt;/code&gt;&#x4E0A;&#x65B9;&#x7684;&#x6CE8;&#x91CA;, &#x8C03;&#x7528;&lt;code&gt;__schedule&lt;/code&gt;&#x7684;&#x65F6;&#x673A;&#x5305;&#x62EC;  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;return from syscall or exception to user-space&lt;/li&gt;
&lt;li&gt;...&#x7565;, &#x4E0D;&#x8BA8;&#x8BBA;...&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;linux-3.10.86/arch/arm/kernel/entry-common.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ENTRY(ret_to_user)
ret_slow_syscall:
    disable_irq             @ disable interrupts
ENTRY(ret_to_user_from_irq)
    @entry-header.S&#x4E2D;  tsk .req    r9      @ current thread_info
    ldr r1, [tsk, #TI_FLAGS]
    @#define _TIF_WORK_MASK     (_TIF_NEED_RESCHED | _TIF_SIGPENDING | _TIF_NOTIFY_RESUME)
    tst r1, #_TIF_WORK_MASK
    bne work_pending


work_pending:
    mov r0, sp              @ &amp;#39;regs&amp;#39;
    mov r2, why             @ &amp;#39;syscall&amp;#39;
    bl  do_work_pending
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/kernel/signal.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_work_pending
{
    if (likely(thread_flags &amp;amp; _TIF_NEED_RESCHED)) {
        schedule();
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/kernel/sched/core.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__schedule
{

    if (prev-&amp;gt;state &amp;amp;&amp;amp; ...){  //&#x4E0D;&#x6EE1;&#x8DB3;

    }

    put_prev_task
    pick_next_task
    clear_tsk_need_resched
    context_switch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x6311;&#x9009;&#x5176;&#x4ED6;&#x8FDB;&#x7A0B;, &#x7136;&#x540E;&#x542F;&#x52A8;&#x4E4B;.&lt;/p&gt;

&lt;h1 id="toc_7"&gt;&lt;h4&gt;4 &#x6570;&#x636E;&#x7ED3;&#x6784;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;Each CPU has its own run queue (struct rq).&lt;/p&gt;

&lt;p&gt;&#x6B63;&#x5728;&#x8FD0;&#x884C;&#x7684;&#x8FDB;&#x7A0B; &#x5E76;&#x4E0D;&#x5728;&#x7EA2;&#x9ED1;&#x6811;&#x4E0A;:&lt;br&gt;
see __schedule -&amp;gt; pick_next_task -&amp;gt; pick_next_task_fair -&amp;gt; set_next_entity -&amp;gt; __dequeue_entity&lt;/p&gt;

&lt;p&gt;&#x4F55;&#x5904;&#x8C03;&#x6574; &#x6811;&#x4E0A;node&#x7684;&#x4F4D;&#x7F6E;?&lt;br&gt;
&#x7B54;:&#x5728;&#x91CD;&#x65B0;&#x653E;&#x5165;&#x7EA2;&#x9ED1;&#x6811;&#x65F6;&#x8C03;&#x6574;&#x4F4D;&#x7F6E;, &#x91CD;&#x65B0;&#x653E;&#x56DE;&#x7EA2;&#x9ED1;&#x6811;&#x662F;&#x4E3A;&#x4E86;&#x540E;&#x7EED;&#x88AB;&#x8C03;&#x5EA6;&#x5230;:
put_prev_task -&amp;gt; put_prev_task_fair -&amp;gt; put_prev_entity -&amp;gt; if (prev-&amp;gt;on_rq) __enqueue_entity&lt;/p&gt;

&lt;p&gt;&#x8FD9;&#x6837;&#x5904;&#x7406;&#x7684;&#x4F18;&#x70B9;:&lt;br&gt;
&#x8FD0;&#x884C;&#x7684;&#x8FDB;&#x7A0B;&#x5E76;&#x4E0D;&#x5728;&#x6811;&#x4E0A;, &#x8FD9;&#x6837; update_curr&#x65F6;, &#x4E5F;&#x5C31;&#x4E0D;&#x5FC5;&#x8C03;&#x6574;&#x5728;&#x6811;&#x4E0A;&#x7684;&#x4F4D;&#x7F6E;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>deadline-iosched</title>
      <link>https://awakening-fong.github.io/posts/io/deadline-iosched</link>
      <pubDate>2017-01-06</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x80CC;&#x666F;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6D3E;&#x53D1;&#x961F;&#x5217;(q-&amp;gt;queue_head)(the block device dispatch queue) &#x4E3A;&#x7A7A;&#x65F6;&#xFF0C;&#x5C06;request&#x4ECE; I/O&#x8C03;&#x5EA6;&#x961F;&#x5217;(io scheduler queue) &#x8F6C;&#x79FB;&#x5230; &#x6D3E;&#x53D1;&#x961F;&#x5217;, 
&#x5177;&#x4F53;&#x662F; &#x901A;&#x8FC7; &#x8C03;&#x7528;I/O&#x8C03;&#x5EA6;&#x7B97;&#x6CD5;&#x7684;elevator_dispatch_fn&#x6765;&#x5B8C;&#x6210;&#x7684;:&lt;br&gt;
linux-3.10.86/block/blk.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__elv_next_request
{
    while (1) {
        if (!list_empty(&amp;amp;q-&amp;gt;queue_head)) {
            rq = list_entry_rq(q-&amp;gt;queue_head.next);
            return rq;
        }
        ...
        if ( ... || !q-&amp;gt;elevator-&amp;gt;type-&amp;gt;ops.elevator_dispatch_fn(q, 0))//&#x6BD4;&#x5982;deadline_dispatch_requests
            return NULL;
    }       
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5177;&#x4F53;&#x8C03;&#x5EA6;&#x7B56;&#x7565;&#x6709; cfq-iosched, deadline-iosched&#x7B49;.&lt;/p&gt;

&lt;p&gt;I/O&#x8C03;&#x5EA6;&#x961F;&#x5217; &#x662F;&#x8C03;&#x5EA6;&#x5668;&#x7684;&#x961F;&#x5217;, &#x6240;&#x4EE5;&#x662F;&#x7279;&#x5B9A;&#x4E8E;io&#x8C03;&#x5EA6;&#x7B56;&#x7565;&#x7684; &#x961F;&#x5217;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x6DFB;&#x52A0;&#x5230;I/O&#x8C03;&#x5EA6;&#x961F;&#x5217;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/block/deadline-iosched.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static struct elevator_type iosched_deadline = {
    .ops = {
        .elevator_add_req_fn =      deadline_add_request,
        ...
    },
    ...
};  


deadline_add_request
{

    deadline_add_rq_rb
    list_add_tail
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rq&#x4F1A;&#x88AB;&#x540C;&#x65F6;&#x6DFB;&#x52A0;&#x5230; rb&#x6811;, &#x548C; &#x94FE;&#x8868;fifo_list&#x4E2D;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct deadline_data {
    /*
     * run time data
     */

    /*
     * requests (deadline_rq s) are present on both sort_list and fifo_list
    request&#x65E2;&#x5728;sort_list, &#x53C8;&#x5728;fifo_list, see deadline_add_request()

    see deadline_merge(), &#x6839;&#x636E;__sector (&#x800C;&#x4E0D;&#x662F;__sector+ bi_size&amp;gt;&amp;gt;9)&#x5728;&#x6811;&#x4E0A;&#x653E;&#x7F6E;&#x5404;request.

    __sector+ bi_size&amp;gt;&amp;gt;9&#x662F;&#x7528;&#x6765;&#x5B9E;&#x73B0;back merge, &#x5728;&#x72EC;&#x7ACB;&#x4E8E;io&#x8C03;&#x5EA6;&#x7B56;&#x7565;&#x7684;&#x5C42; &#x7528;&#x6765;hash&#x7684;, 
    see struct elevator_queue&#x7684;hash, 
    and see blk_queue_bio -&amp;gt; elv_merge -&amp;gt; elv_rqhash_find
     */
    struct rb_root sort_list[2];
    /*&#x7531;&#x4E8E;&#x662F;fifo, &#x6240;&#x4EE5;, &#x81EA;&#x7136;&#x65F6;&#x95F4;&#x4E0A;&#x9012;&#x589E;, &#x65B0;&#x6DFB;&#x52A0;&#x7684;&#x653E;&#x5728;&#x540E;&#x9762;*/
    struct list_head fifo_list[2]; //fong:see deadline_add_request()

    /*
     * next in sort order. read, write or both are NULL

    &#x95EE;&#x9898;:&#x8FD9;&#x4E2A;&#x6709;&#x5565;&#x7528;?
    &#x7B54;:batch&#x6A21;&#x5F0F;&#x4E0B;, &#x8BE5;rq&#x4F1A;&#x88AB;dispatch.

     &#x8C01;&#x4FEE;&#x6539;&#x8BE5;&#x6307;&#x9488;?
     deadline_latter_request()&#x4FEE;&#x6539;&#x6307;&#x9488;, see deadline_move_request()
     &#x95EE;&#x9898;:&#x6309;&#x4EC0;&#x4E48;&#x6392;&#x5E8F;? 
     &#x7B54;:&#x6247;&#x533A;&#x7F16;&#x53F7;&#x9012;&#x589E;, see deadline_add_request -&amp;gt; deadline_add_rq_rb
     */
    struct request *next_rq[2];
    /*
    &#x5982;&#x679C;batching&amp;lt;fifo_batch, &#x5219;&#x4E0D;&#x6309; &#x8FC7;&#x671F;&#x65F6;&#x95F4;&#x6765;dispatch.
    fifo_batch&#x662F;setting, batching&#x662F;run time data.
    */
    unsigned int batching;      /* number of sequential requests made */
    sector_t last_sector;       /* head position  &#x8FD9;&#x4E2A;&#x6CE8;&#x91CA;&#x5982;&#x4F55;&#x7406;&#x89E3;??? &#x88AB;&#x5F15;&#x7528;&#x6BD4;&#x5982;deadline_move_request()*/
    unsigned int starved;       /* times reads have starved writes */

    /*
     * settings that change how the i/o scheduler behaves

     &#x8FD9;&#x51E0;&#x4E2A;&#x503C;&#x662F;&#x4E0D;&#x968F;&#x8FDB;&#x5EA6;&#x800C;&#x53D8;&#x5316;&#x7684;.
     */
    int fifo_expire[2];
    /*&#x6512;&#x591F;&#x8FD9;&#x4E2A;&#x6570; &#x624D; &#x5F00;&#x59CB;&#x8003;&#x8651; fifo_list*/
    int fifo_batch;
    int writes_starved;
    int front_merges;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x200B; &lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x79FB;&#x52A8;&#x5230;&#x6D3E;&#x53D1;&#x961F;&#x5217;&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;/*
&#x4ECE;&#x961F;&#x5217;&#x4E2D;&#x6311;&#x9009;&#x51FA;&#x4E00;&#x4E2A;&#x5408;&#x9002;&#x7684;request, &#x6D3E;&#x53D1;&#x4E4B;
*/
deadline_dispatch_requests
{

    if (rq &amp;amp;&amp;amp; dd-&amp;gt;batching &amp;lt; dd-&amp;gt;fifo_batch)
        goto dispatch_request;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E3A;&#x7B80;&#x5316;&#x8BA8;&#x8BBA;, &#x5982;&#x679C;&#x7CFB;&#x7EDF;&#x7684;&#x8BFB;&#x5199;&#x90FD;&#x6BD4;&#x8F83;&#x591A;, &#x901A;&#x5E38;&#x5728;&#x6BCF;&#x6B21;dispatch fifo_batch&#x4E2A; (&#x51C6;&#x786E;&#x5730;&#x8BF4;, &#x662F;&#x9664;&#x9996;&#x6B21;&#x5916;, &#x5176;&#x4ED6; &#x662F;&#x6BCF;fifo_batch-1&#x4E2A;) rq&#x540E;, &#x624D;&#x6709;&#x4E00;&#x4E2A;&#x6839;&#x636E; &#x8FC7;&#x671F;&#x65F6;&#x95F4;&#x6765;&#x9009;&#x62E9;rq&#x7684;&#x673A;&#x4F1A; , batch&#x6A21;&#x5F0F;&#x4E0B;&#x90FD;&#x662F;&#x6839;&#x636E;sector&#x6765;&#x9009;&#x62E9;rq.
&#x5047;&#x5B9A;fifo_batch&#x4E3A;1, &#x5219;&#x6548;&#x679C;&#x662F;first-come first-served.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. &#x8C03;&#x7528;&#x8DEF;&#x5F84;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4F1A;&#x5230;&#x6807;&#x9898;2&#x7684;&#x5185;&#x5BB9;, &#x6DFB;&#x52A0;&#x5230;io&#x8C03;&#x5EA6;&#x961F;&#x5217;&#x7684;&#x8DEF;&#x5F84;/&#x56DE;&#x6EAF;:&lt;/p&gt;

&lt;p&gt;&#x5047;&#x5B9A;&#x6CA1;&#x6709;plug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;blk_queue_bio
|--elv_merge &#x4E4B;&#x7C7B;&#x7684; bio&#x5408;&#x5E76;&#x5230;rq
|   |-- -&amp;gt;elevator_merged_fn
|--&#x4E3A;io&#x5206;&#x914D;rq, &#x7136;&#x540E;init_request_from_bio
|--add_acct_request -&amp;gt; __elv_add_request(, ELEVATOR_INSERT_SORT)
|   |--elv_rqhash_add  //&#x4E0D;&#x4F9D;&#x8D56; &#x5177;&#x4F53;&#x7684;iosched
|   |--q-&amp;gt;elevator-&amp;gt;type-&amp;gt;ops.elevator_add_req_fn  //&#x4F9D;&#x8D56; &#x5177;&#x4F53;&#x7684;iosched
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8C03;&#x7528;&#x5408;&#x5E76;&#x7684;&#x8DEF;&#x5F84;:&lt;br&gt;
linux-3.10.86/block/deadline-iosched.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static struct elevator_type iosched_deadline = {
    .ops = {
        .elevator_merge_fn =        deadline_merge,
        .elevator_merged_fn =       deadline_merged_request,
        .elevator_merge_req_fn =    deadline_merged_requests,
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;elevator_merge_fn, elevator_merged_fn, elevator_merge_req_fn &#x7684;&#x533A;&#x522B;&#x662F;&#x5565;?&lt;br&gt;
&#x7B54;: linux-3.10.86/include/linux/elevator.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct elevator_ops
{
    //&#x6BD4;&#x5982;deadline_merge
    elevator_merge_fn *elevator_merge_fn; /*&#x4EC5;&#x68C0;&#x67E5;, &#x4E0D;&#x505A;&#x5408;&#x5E76;, &#x5408;&#x5E76;&#x7531;elevator_merge_req_fn&#x6267;&#x884C;*/
    /*&#x8FD9;&#x4E2A;&#x662F;merge*d*, &#x5728;&#x5408;&#x5E76; *&#x540E;* &#x8C03;&#x7528;, &#x6BD4;&#x5982;&#x5BF9;&#x4E8E;deadline-iosched, &#x8981;&#x4FEE;&#x6539;rb&#x6811;*/
    elevator_merged_fn *elevator_merged_fn;
    /*&#x548C;elevator_merge_fn&#x7684;&#x533A;&#x522B;?
    &#x7B54;:
    typedef int (elevator_merge_fn) (struct request_queue *, struct request **,
                     struct bio *);
    &#x8FD9;&#x4E2A;&#x539F;&#x578B;&#x4E2D;&#x6709;bio, &#x662F;&#x67E5;&#x627E;&#x53EF;&#x4EE5;&#x548C;bio&#x5408;&#x5E76;&#x7684;request.

    typedef void (elevator_merge_req_fn) (struct request_queue *, struct request *, struct request *);
    &#x8FD9;&#x4E2A;&#x540D;&#x5B57;&#x4E2D;&#x7ED9;&#x51FA;&#x4E86; &#x8C13;&#x5BBE;, &#x7528;&#x6765;&#x5408;&#x5E76;&#x4E24;struct request.
    */
    elevator_merge_req_fn *elevator_merge_req_fn;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x4F55;&#x65F6;&#x8C03;&#x7528; deadline_merged_requests?&lt;br&gt;
&#x7B54;:
    attempt_back_merge -&amp;gt; attempt_merge -&amp;gt; elv_merge_requests -&amp;gt;  elevator_merge_req_fn -&amp;gt; deadline_merged_requests&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;blk_queue_bio
{

    el_ret = elv_merge(q, &amp;amp;req, bio);
    if (el_ret == ELEVATOR_BACK_MERGE) {
        if (bio_attempt_back_merge(q, req, bio)) {
            elv_bio_merged(q, req, bio);
            /*
            &#x4E0A;&#x9762;&#x662F;&#x628A;bio&#x5408;&#x5E76;&#x5230;request&#x4E2D;, &#x56FE;&#x793A;&#x7684;[b, c]&#x662F;&#x521A;&#x5408;&#x5E76;&#x7684;bio, &#x5408;&#x5E76;&#x4E3A;[a&amp;#39;, c]&#x8FD9;&#x4E2A;request,
            ---| |---| |---
            a&amp;#39; a b   c d

            &#x73B0;&#x5728;&#x8003;&#x8651;request [a&amp;#39;, c]&#x662F;&#x5426;&#x80FD;&#x591F;&#x548C;request [d, ]&#x5408;&#x5E76;.
            */
            if (!attempt_back_merge(q, req))
                elv_merged_request(q, req, el_ret);
            goto out_unlock;
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:struct elevator_queue()&#x548C;io&#x8C03;&#x5EA6;&#x5668;&#x7684;&#x5173;&#x7CFB;?&lt;br&gt;
&#x7B54;:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;submit_bio() -&amp;gt; generic_make_request -&amp;gt; blk_queue_bio
|--&#x65E0;&#x9501; attempt_plug_merge
|--spin_lock_irq(q-&amp;gt;queue_lock);
|--elv_merge(struct request_queue *q, ...) /*&#x6CA1;&#x6709;&#x8FDB;&#x884C;&#x961F;&#x5217;&#x7684;&#x63D2;&#x5165;&#x64CD;&#x4F5C;, &#x4EC5;&#x5224;&#x65AD;&#x662F;&#x5426;&#x80FD;&#x591F;&#x5B8C;&#x6210;merge.*/
|   |--struct elevator_queue *e = q-&amp;gt;elevator;
|   |--e-&amp;gt;type-&amp;gt;ops.elevator_merge_fn  -&amp;gt; deadline_merge(struct request_queue *q, ...)
|   |   |--struct deadline_data *dd = q-&amp;gt;elevator-&amp;gt;elevator_data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;elevator_queue&#x662F; &#x5404;&#x8C03;&#x5EA6;&#x7B56;&#x7565;&#x901A;&#x7528;&#x7684;&#x7ED3;&#x6784;&#x4F53;.
&#x518D;&#x901A;&#x8FC7; elevator-&amp;gt;elevator_data &#x8F6C;&#x5230;  &#x5404;&#x8C03;&#x5EA6;&#x7B56;&#x7565; &#x7279;&#x5B9A;&#x7684;&#x7ED3;&#x6784;&#x4F53;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>generic_make_request</title>
      <link>https://awakening-fong.github.io/posts/io/generic_make_request</link>
      <pubDate>2017-01-04</pubDate>
      <description>&lt;p&gt;linux-3.10.86/block/blk-core.c&lt;/p&gt;

&lt;p&gt;&#x5148;&#x65AD;&#x7AE0;&#x53D6;&#x4E49;&#x4E0B;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;void generic_make_request(struct bio *bio)
{

    bio_list_init(&amp;amp;bio_list_on_stack);
    current-&amp;gt;bio_list = &amp;amp;bio_list_on_stack;
    ...
        /*
        &#x4ECE;&#x8FD9;&#x91CC;&#x6765;&#x770B;, q-&amp;gt;make_request_fn()&#x53EF;&#x80FD;&#x4F1A;&#x5F80;current-&amp;gt;bio_list&#x4E2D;&#x6DFB;&#x52A0;bio,
        &#x5426;&#x5219;, &#x4ECE;&#x54EA;&#x91CC;pop&#x5462;?
        */
    q-&amp;gt;make_request_fn(q, bio);
    bio = bio_list_pop(current-&amp;gt;bio_list);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E0A;&#x9762;&#x7684;&#x731C;&#x60F3;&#x662F;&#x7247;&#x9762;&#x7684;, &#x8FD8;&#x662F;&#x6765;&#x4E2A;&#x5168;&#x8C8C;&#x7684;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;void generic_make_request(struct bio *bio)
{
    struct bio_list bio_list_on_stack;

    if (!generic_make_request_checks(bio))
        return;

    if (current-&amp;gt;bio_list) {
        bio_list_add(current-&amp;gt;bio_list, bio);
        return;
    }

    BUG_ON(bio-&amp;gt;bi_next);
    bio_list_init(&amp;amp;bio_list_on_stack);
    current-&amp;gt;bio_list = &amp;amp;bio_list_on_stack;
    do {
        /*
        while&#x518D;&#x6B21;&#x6267;&#x884C;&#x65F6;, q (struct request_queue *)&#x53EF;&#x80FD;&#x548C;&#x4E0A;&#x6B21;&#x5FAA;&#x73AF;&#x65F6;&#x7684;q&#x4E0D;&#x4E00;&#x6837;&#x4E86;,
        &#x6240;&#x4EE5;, &#x5B9E;&#x73B0;&#x4ECE;&#x4E00;&#x79CD;&#x8BBE;&#x5907;&#x5230;&#x53E6;&#x4E00;&#x79CD;&#x8BBE;&#x5907;&#x7684;&#x6620;&#x5C04;, &#x63D0;&#x4EA4;&#x7ED9;&#x65B0;&#x7684;&#x5757;&#x8BBE;&#x5907;&#x6267;&#x884C;.
        */
        struct request_queue *q = bdev_get_queue(bio-&amp;gt;bi_bdev);
        q-&amp;gt;make_request_fn(q, bio);
        /*
        &#x4ECE;&#x8FD9;&#x91CC;&#x6765;&#x770B;, q-&amp;gt;make_request_fn()&#x53EF;&#x80FD;&#x4F1A;&#x5F80;current-&amp;gt;bio_list&#x4E2D;&#x6DFB;&#x52A0;bio,
        &#x5426;&#x5219;, &#x4ECE;&#x54EA;&#x91CC;pop&#x5462;?
        &#x5F53;&#x7136;&#x4E5F;&#x53EF;&#x4EE5;&#x4E0D;&#x5F80;current-&amp;gt;bio_list&#x6DFB;&#x52A0;bio, &#x8868;&#x793A;&#x65E0;&#x9700;&#x518D;&#x7ECF;&#x8FC7;&#x8F6C;&#x6362;&#x4E86;, 
        &#x8FD9;&#x6837;, while&#x4E5F;&#x5C31;&#x7ED3;&#x675F;&#x4E86;.
        */
        bio = bio_list_pop(current-&amp;gt;bio_list);
    } while (bio);
    current-&amp;gt;bio_list = NULL; /* deactivate */
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5047;&#x5B9A;&#x7ECF;&#x8FC7;1&#x6B21;&#x8F6C;&#x6362;, &#x90A3;&#x4E48;, &#x8C03;&#x7528;&#x5927;&#x6982;&#x662F;&#x8FD9;&#x6837;&#x7684;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;generic_make_request
|-- q-&amp;gt;make_request_fn
|   |--...
|   |--generic_make_request
|   |   |--if (current-&amp;gt;bio_list) { bio_list_add(current-&amp;gt;bio_list, bio); return; }
|-- bio = bio_list_pop(current-&amp;gt;bio_list);
|-- q-&amp;gt;make_request_fn(q, bio);
|   |--no call generic_make_request
|--return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x65E0;&#x9700;&#x8F6C;&#x6362;&#x662F;&#x8FD9;&#x6837;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;generic_make_request
|-- q-&amp;gt;make_request_fn  &#x6BD4;&#x5982;&#x4E3A; blk_queue_bio
|   |--no call generic_make_request
|--return
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>do_generic_file_read&#x4E2D;&#x7684;readahead</title>
      <link>https://awakening-fong.github.io/posts/io/readahead</link>
      <pubDate>2017-01-03</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. readahead&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;do_generic_file_read &#x4E2D;&#x6709;&#x4E24;&#x4E2A;ahead&#x76F8;&#x5173;&#x7684;&#x51FD;&#x6570;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_generic_file_read -&amp;gt; page_cache_sync_readahead 
generic_file_aio_read -&amp;gt; do_generic_file_read -&amp;gt;  page_cache_async_readahead
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;:page_cache_sync_readahead &#x548C; page_cache_async_readahead  &#x7684;&#x5DEE;&#x522B;&#x5728;&#x54EA;&#x91CC;? sync&#x548C;async&#x4F53;&#x73B0;&#x5728;&#x54EA;?&lt;br&gt;
&#x7B54;: &#x4E00;&#x4E2A;&#x5F53;&#x524D;page cache&#x4E2D;&#x6CA1;&#x6709;&#x6240;&#x9700;&#x7684;&#x6570;&#x636E;, &#x53D1;&#x8D77;&#x7684;&#x662F;&#x5BF9;&#x5F53;&#x4E0B;&#x8981;&#x7528;&#x7684;&#x6570;&#x636E;&#x7684;&#x8BFB;&#x53D6;;&lt;br&gt;
&#x53E6;&#x4E00;&#x4E2A;&#x662F;page cache&#x4E2D;&#x6709;&#x6240;&#x9700;&#x7684;&#x6570;&#x636E;, &#x53D1;&#x8D77;&#x5BF9;&#x540E;&#x9762;&#x53EF;&#x80FD;&#x8981;&#x7528;&#x7684;&#x6570;&#x636E;&#x7684;&#x8BFB;&#x53D6;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/mm/filemap.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_generic_file_read
{
        page = find_get_page(mapping, index);
        if (!page){
            page_cache_sync_readahead(...)
            ...
        }
        if (PageReadahead(page)) {
            page_cache_async_readahead(...)
        }
        ...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sync&#x4F53;&#x73B0;&#x5728;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_generic_file_read
{

            page = find_get_page(mapping, index);
            if (!page){
                page_cache_sync_readahead(...)
                ...
            }
            if (!PageUptodate(page)) {
                if (!trylock_page(page)) //&#x9501;&#x5931;&#x8D25;
                    goto page_not_up_to_date;
                ...
            }

page_not_up_to_date:
        /*&#x8FD9;&#x91CC;&#x7B49;&#x5F85;io complete handler&#x91CA;&#x653E;&#x9501;.*/
        /* Get exclusive access to the page ... */
        error = lock_page_killable(page);
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. how readahead works&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;ondemand_readahead -&amp;gt; __do_page_cache_readahead -&amp;gt; read_pages&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;read_pages
{
    ...
    blk_start_plug(&amp;amp;plug);
    mapping-&amp;gt;a_ops-&amp;gt;readpages()
    blk_finish_plug(&amp;amp;plug);
}


blk_start_plug(struct blk_plug *plug)
{
    ...
    if (!tsk-&amp;gt;plug)
        tsk-&amp;gt;plug = plug;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x200B; 
linux-3.10.86/include/linux/sched.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct task_struct {
    ...
    /* stacked block device info */
    struct bio_list *bio_list;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/include/linux/blkdev.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct blk_plug {
    unsigned long magic; /* detect uninitialized use-cases */
    /* &#x5148;&#x5C1D;&#x8BD5;&#x548C;current-&amp;gt;plug&#x8FD9;&#x4E2A;struct blk_plug&#x4E2D;&#x7684;struct request&#x5408;&#x5E76;
    &#x5931;&#x8D25;&#x540E;, &#x624D;&#x5C1D;&#x8BD5;&#x7535;&#x68AF;&#x8C03;&#x5EA6;.
    see blk_queue_bio -&amp;gt; attempt_plug_merge()*/
    struct list_head list; /* requests */
    /*entry&#x4E3A;struct blk_plug_cb, see flush_plug_callbacks()*/
    struct list_head cb_list; /* md requires an unplug callback */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&lt;br&gt;
1. &#x82E5;&#x4E0D;&#x7ECF;&#x8FC7;struct blk_plug, &#x76F4;&#x63A5;&#x653E;&#x5165;&#x7535;&#x68AF;&#x8C03;&#x5EA6;, &#x4E5F;&#x80FD;&#x591F;&#x987A;&#x5229;&#x5408;&#x5E76;&#x554A;, &#x4E3A;&#x4F55;&#x975E;&#x8981;&#x5F15;&#x5165;struct blk_plug&#x5462;?&lt;br&gt;
2. struct blk_plug&#x5982;&#x4F55; &#x4E0E; &#x7535;&#x68AF; &#x8854;&#x63A5;&#x7684;?&lt;br&gt;
&#x7B54;:&#x4EE5;&#x4E0A;&#x9762;&#x7684;read_pages()&#x4E3A;&#x4F8B;, blk_start_plug()&#x540E;, : &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-&amp;gt;readpages -&amp;gt; submit_bio -&amp;gt; generic_make_request -&amp;gt; blk_queue_bio
|--(&#x65E0;&#x9501;) attempt_plug_merge
|--fall back  to
|   |--spin_lock_irq(q-&amp;gt;queue_lock);
|   |--elv_merge /*&#x6CA1;&#x6709;&#x8FDB;&#x884C;&#x961F;&#x5217;&#x7684;&#x63D2;&#x5165;&#x64CD;&#x4F5C;, &#x4EC5;&#x5224;&#x65AD;&#x662F;&#x5426;&#x80FD;&#x591F;&#x5B8C;&#x6210;merge.*/
|   |   |--elv_rqhash_find  //&#x5C1D;&#x8BD5;back merge, &#x4E0D;&#x4F9D;&#x8D56;&#x4E8E; &#x5177;&#x4F53;&#x7684;iosched.
|   |   |--fall back:  e-&amp;gt;type-&amp;gt;ops.elevator_merge_fn  //&#x4F9D;&#x8D56;&#x4E8E; &#x5177;&#x4F53;&#x7684;iosched
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;blk_finish_plug -&amp;gt; blk_flush_plug_list
&#x8FD9;&#x91CC;&#x5BF9;struct blk_plug&#x7684;&#x64CD;&#x4F5C;&#x65E0;&#x9700;&#x52A0;&#x9501;, &#x56E0;&#x4E3A;&#x662F;&#x5C5E;&#x4E8E;current&#x7684;, &#x5E76;&#x4E0D;&#x4F1A;&#x591A;&#x4EBA;&#x540C;&#x65F6;&#x64CD;&#x4F5C;.&lt;/p&gt;

&lt;p&gt;elv_merge&#x8981;&#x52A0;&#x9501;, &#x4E14;&#x8981;&#x5224;&#x65AD;&#x7684;&#x5185;&#x5BB9; &#x6BD4; attempt_plug_merge &#x591A;&#x4E0D;&#x5C11;. &#x6240;&#x4EE5;, attempt_plug_merge&#x6BD4;&#x8F83;&#x5FEB;.&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>
