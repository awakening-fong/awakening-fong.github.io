<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>HOMEPAGE</title>
    <description>HOMEPAGE</description>
    <link>https://awakening-fong.github.io</link>
    <pubDate>2017-02-24</pubDate>
    <item>
      <title>__vmalloc_area_node</title>
      <link>https://awakening-fong.github.io/posts/mm/vmalloc</link>
      <pubDate>2017-02-24</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1.__vmalloc_node()&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;__vmalloc_node -&amp;gt; __vmalloc_node_range
 *  Allocate enough pages to cover @size from the page level
 *  allocator with @gfp_mask flags.  Map them into contiguous
 *  kernel virtual space, using a pagetable protection of @prot.
 &#x6240;&#x4EE5;, &#x6211;&#x4EEC;&#x9700;&#x8981;
1. &#x627E;&#x4E00;&#x4E2A;&#x53EF;&#x7528;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x7A7A;&#x95F4;
2. &#x628A; &#x591F;&#x5206;&#x91CF;&#x7684;@size, &#x53EF;&#x4EE5;&#x7269;&#x7406;&#x5730;&#x5740;&#x4E0A;&#x975E;&#x8FDE;&#x7EED;&#x7684;, &#x7B26;&#x5408;@gfp_mask&#x7684; page &#x5206;&#x914D;&#x51FA;&#x6765;
3. &#x865A;&#x62DF;&#x5730;&#x5740;&#x548C; &#x7269;&#x7406;&#x5730;&#x5740; &#x5173;&#x8054;&#x4E0A;, &#x5E76;&#x8BBE;&#x7F6E;&#x76F8;&#x5E94;&#x7684; &#x6743;&#x9650;@prot.

__vmalloc_node_range
|--struct vm_struct *area=__get_vm_area_node
|--__vmalloc_area_node
|   |--alloc_page
|   |--map_vm_area
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;map_vm_area()&#x5C06;struct vm_struct&#x548C;struct page&#x5173;&#x8054;&#x8D77;&#x6765;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;map_vm_area ==&amp;gt; vmap_page_range
|--vmap_page_range_noflush  &#x6539;&#x5199;&#x9875;&#x8868;, &#x4F46;&#x5982;&#x51FD;&#x6570;&#x540D;&#x6240;&#x8BF4;&#x7684;, &#x4E0D;&#x6267;&#x884C;flush
|--flush_cache_vmap

vmap_page_range_noflush
|...
|--vmap_pte_range



__vmalloc_area_node
{
    /*&#x95EE;&#x9898;:&#x4E3A;&#x4F55;&#x8FD9;&#x91CC;&#x662F; &#x51CF;&#x53BB;PAGE_SIZE ? */
    nr_pages = (area-&amp;gt;size - PAGE_SIZE) &amp;gt;&amp;gt; PAGE_SHIFT;
    ...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x4E3A;&#x4F55;&#x8FD9;&#x91CC;&#x662F; &#x51CF;&#x53BB;PAGE_SIZE ?&lt;br&gt;
&#x7B54;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__get_vm_area_node
{
    size = PAGE_ALIGN(size);
    /*
     * We always allocate a guard page.
     */
    size += PAGE_SIZE;

    alloc_vmap_area(size, ...);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x51CF;&#x53BB;&#x7684;&#x662F;  guard page.&lt;br&gt;
&#x6240;&#x4EE5;,  &#x4F5C;&#x4E3A;guard&#x7684;page&#x662F;&#x865A;&#x62DF;&#x5730;&#x5740;&#x662F;&#x5360;&#x7528;&#x4E86;, &#x4E0D;&#x8FC7;page frame&#x5C31;&#x4E0D;&#x5FC5;&#x5206;&#x914D;&#x4E86;, &#x53CD;&#x6B63;&#x6211;&#x4EEC;&#x4E0D;&#x662F;&#x60F3;&#x5B58;&#x5230;guard page&#x4E2D;&#x53BB;&#x7684;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x9012;&#x5F52;&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;__vmalloc_area_node
{

    array_size = (nr_pages * sizeof(struct page *)); 

    if (array_size &amp;gt; PAGE_SIZE) {
        pages = __vmalloc_node(array_size, 1, nested_gfp|__GFP_HIGHMEM,
                PAGE_KERNEL, node, caller);
        area-&amp;gt;flags |= VM_VPAGES;
    } else {
        pages = kmalloc_node(array_size, nested_gfp, node);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x5206;&#x914D;&#x7684;&#x5185;&#x5B58;&#x662F;&#x7528;&#x6765;&#x5B58;&#x653E; &#x6210;&#x5458;&#x4E3A;struct page *&#x7684;&#x6570;&#x7EC4;.
&#x6211;&#x4EEC;&#x5F88;&#x7231;&#x60DC;&#x7269;&#x7406;&#x5730;&#x5740;&#x8FDE;&#x7EED;&#x7684;&#x5185;&#x5B58;, &#x5982;&#x679C; &#x7528;&#x6765;&#x5B58;&#x50A8;struct page *&#x7684;&#x8D85;&#x8FC7;&#x4E00;&#x4E2A;&#x7269;&#x7406;&#x9875;, &#x90A3;&#x4E48;, &#x6211;&#x4EEC;&#x8FD8;&#x662F;&#x575A;&#x6301;&#x5C3D;&#x91CF;&#x4ECE;order==0&#x4E2D;&#x6765;&#x5206;&#x914D;.&lt;/p&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x9012;&#x5F52;&#x4E86;, &#x56E0;&#x4E3A;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vmalloc
|--__vmalloc_node_flags -&amp;gt; __vmalloc_node -&amp;gt; __vmalloc_node_range
|   |--__get_vm_area_node
|   |--__vmalloc_area_node
|   |   |--__vmalloc_node
|   |   |   |--kmalloc_node
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;__vmalloc_node()&#x8C03;&#x7528;&#x4E86; __vmalloc_node().&lt;/p&gt;

&lt;p&gt;&#x91CA;&#x653E;&#x4E2D;&#x5BF9;&#x5E94;&#x5730;, &#x4E5F;&#x6709;&#x9012;&#x5F52;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__vunmap
{
    if (area-&amp;gt;flags &amp;amp; VM_VPAGES)
        vfree(area-&amp;gt;pages); //&#x8FD9;&#x91CC;&#x662F;&#x9012;&#x5F52; (&#x5148;&#x91CA;&#x653E;&#x91CC;&#x9762;&#x7684;, &#x518D;&#x91CA;&#x653E;&#x5916;&#x9762;&#x7684;)
    else
        kfree(area-&amp;gt;pages);

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>do_fork&#x548C;COW</title>
      <link>https://awakening-fong.github.io/posts/mm/do_fork_cow</link>
      <pubDate>2017-02-24</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6458;&#x81EA;APUE:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&#x7531;&#x4E8E;&#x5728;fork&#x4E4B;&#x540E;&#x8FDB;&#x7A0B;&#x8DDF;&#x968F;&#x7740;exec, &#x6240;&#x4EE5;&#x73B0;&#x5728;&#x7684;&#x5F88;&#x591A;&#x5B9E;&#x73B0;&#x5E76;&#x4E0D;&#x6267;&#x884C;&#x4E00;&#x4E2A;&#x7236;&#x8FDB;&#x7A0B;&#x6570;&#x636E;&#x6BB5;, &#x6808;&#x548C;&#x5806;&#x7684;&#x5B8C;&#x5168;&#x590D;&#x5236;. &#x4F5C;&#x4E3A;&#x66FF;&#x4EE3;, &#x4F7F;&#x7528;&#x4E86;COW&#x6280;&#x672F;. &#x8FD9;&#x4E9B;&#x533A;&#x57DF;&#x7531;&#x7236;&#x5B50;&#x8FDB;&#x7A0B;&#x5171;&#x4EAB;, &#x800C;&#x4E14;&#x5185;&#x6838;&#x5C06;&#x5B83;&#x4EEC;&#x7684;&#x8BBF;&#x95EE;&#x6743;&#x9650;&#x6539;&#x53D8;&#x4E3A;&#x53EA;&#x8BFB;&#x7684;. &#x5982;&#x679C;&#x7236;&#x5B50;&#x8FDB;&#x7A0B;&#x4E2D;&#x7684;&#x4EFB;&#x4E00;&#x4E2A;&#x8BD5;&#x56FE;&#x4FEE;&#x6539;&#x8FD9;&#x4E9B;&#x533A;&#x57DF;, &#x5219;&#x5185;&#x6838;&#x53EA;&#x4E3A;&#x4FEE;&#x6539;&#x533A;&#x57DF;&#x7684;&#x90A3;&#x5757;&#x5185;&#x5B58;&#x5236;&#x4F5C;&#x4E00;&#x4E2A;&#x526F;&#x672C;, &#x901A;&#x5E38;&#x662F;&#x865A;&#x62DF;&#x5B58;&#x50A8;&#x7CFB;&#x7EDF;&#x4E2D;&#x7684;&#x4E00;&amp;quot;&#x9875;&amp;quot;.  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x54EA;&#x91CC;&#x8BBE;&#x7F6E;&#x53EA;&#x8BFB;, &#x5982;&#x4F55;&#x77E5;&#x9053;&#x53EA;&#x8BFB;?&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x89E3;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5FEB;&#x901F;tips:&lt;br&gt;
PTE entry is marked as un-writeable.&lt;br&gt;
But VMA is marked as writeable.  &lt;/p&gt;

&lt;p&gt;copy_one_pte()&#x4F1A;&#x8C03;&#x7528; ptep_set_wrprotect()&lt;/p&gt;

&lt;p&gt;&#x8FD8;&#x662F;&#x5148;&#x4ECE;dup_mm()&#x5F00;&#x59CB;&#x770B;&#x5427;.&lt;br&gt;
linux-3.10.86/kernel/fork.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct mm_struct *dup_mm(struct task_struct *tsk)
{
    struct mm_struct *mm, *oldmm = current-&amp;gt;mm;
    mm = allocate_mm();
    memcpy(mm, oldmm, sizeof(*mm)); 

    mm_init(mm, tsk)); //&#x91CC;&#x9762;&#x6D89;&#x53CA;&#x9875;&#x8868;
    err = dup_mmap(mm, oldmm);

}

static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p)
|-- mm_alloc_pgd(mm)
|   |--mm-&amp;gt;pgd = pgd_alloc(mm); //&#x5206;&#x914D;&#x9875;&#x8868;


pgd_alloc
{
    new_pgd = __pgd_alloc();
    memset(new_pgd, 0, USER_PTRS_PER_PGD * sizeof(pgd_t));  //&#x6E05;&#x7A7A;&#x9875;&#x8868;

    /*
     * Copy over the kernel and IO PGD entries  &#x62F7;&#x8D1D;&#x5185;&#x6838;&#x7684;&#x9875;&#x8868;, &#x4E14;&#x662F;first level&#x9875;&#x8868;
     */
    init_pgd = pgd_offset_k(0);  //&#x5185;&#x6838;&#x7684;&#x9875;&#x8868;
    memcpy(new_pgd + USER_PTRS_PER_PGD, init_pgd + USER_PTRS_PER_PGD,
               (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t)); 

}


static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
{
    struct vm_area_struct *mpnt;
    //&#x8FD9;&#x4E2A;&#x662F;&#x8FDB;&#x7A0B;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x533A;&#x57DF;, &#x975E;&#x5185;&#x6838;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x533A;&#x57DF;
    for (mpnt = oldmm-&amp;gt;mmap; mpnt; mpnt = mpnt-&amp;gt;vm_next) { 
        copy_page_range(mm, oldmm, mpnt);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x5C31;&#x662F;&#x6211;&#x4EEC;&#x8981;&#x4E13;&#x6CE8;&#x7684;&#x90E8;&#x5206;&#x4E86;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;copy_page_range
|--copy_pud_range
|   |--copy_pmd_range
|   |   |--copy_pte_range
|   |   |   |--copy_one_pte

copy_one_pte
{
    /*
     * If it&amp;#39;s a COW mapping, write protect it both
     * in the parent and the child
     */
    if (is_cow_mapping(vm_flags)) {
        ptep_set_wrprotect(src_mm, addr, src_pte);
        pte = pte_wrprotect(pte);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x5173;&#x4E8E;THREAD_START_SP</title>
      <link>https://awakening-fong.github.io/posts/mm/thread_start_sp</link>
      <pubDate>2017-02-23</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://awakening-fong.github.io/posts/arm/arm_qemu_02"&gt;https://awakening-fong.github.io/posts/arm/arm_qemu_02&lt;/a&gt;
&#x4E2D;&#x8BF4;&#x5230; start_kernel&#x524D;&#x8BBE;&#x7F6E;sp&#x4E3A; init_thread_union + THREAD_START_SP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define THREAD_START_SP (THREAD_SIZE - 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E3A;&#x4F55;&#x8981;-8?  &lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x89E3;&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;static inline struct thread_info *current_thread_info(void)
{
    register unsigned long sp asm (&amp;quot;sp&amp;quot;);
    return (struct thread_info *)(sp &amp;amp; ~(THREAD_SIZE - 1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(&#x56FE;&#x793A;&#x4E2D;A&#x70B9;&#x5230;B&#x70B9;  &#x5927;&#x5C0F;&#x662F;8&#x5B57;&#x8282;)&lt;br&gt;
&#x5982;&#x679C;sp&#x662F;SP0, &#x90A3;&#x4E48;,(sp &amp;amp; ~(THREAD_SIZE - 1)) &#x540E;&#x8FD8;&#x662F;&#x6307;&#x5411;SP0 (A&#x70B9;);&lt;br&gt;
&#x5982;&#x679C;sp&#x662F;SP1, &#x90A3;&#x4E48;, (sp &amp;amp; ~(THREAD_SIZE - 1)) &#x540E;&#x6307;&#x5411;&#x7684;&#x662F;thread_info (C&#x70B9;).&lt;br&gt;
&#x6240;&#x4EE5;, &#x9700;&#x8981;-8.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          SP0 ----&amp;gt;  +.------------+   --.--        &#x9AD8;&#x5730;&#x5740;  
                |    | A           |     |                  
                8    |             |     |            ^     
                |    |             |                  |     
          SP1 ----&amp;gt;  |.B           |  THREAD_SIZE     |     
                     |             |     .            |     
                     |             |     |            |     
                     |             |     |            |     
                     |             |     |            |     
  thread_info ---&amp;gt;   |.C           |  ------          |     
                     |             |                  |     
                     |             |                  |     
                     |             |                  |      
                     |             |                        
                     +-------------+                 &#x4F4E;&#x5730;&#x5740; 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x5185;&#x6838;&#x4E2D;&#x5E38;&#x89C1;&#x7684;&#x4F18;&#x5316;&#x65B9;&#x6CD5;</title>
      <link>https://awakening-fong.github.io/posts/other/optimize</link>
      <pubDate>2017-02-23</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x6279;&#x91CF;&#x5904;&#x7406;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;add_to_page_cache_lru,  &#x64CD;&#x4F5C;lru&#x7684;&#x8BDD;, &#x5148;&#x653E;&#x5230;per cpu&#x7684;lru cache (struct pagevec), &#x5F85;lru cache&#x5B58;&#x6EE1;&#x540E;drain.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x541E;&#x5410;&#x91CF;&#xFF08;Throughput&#xFF09;&#x548C;&#x65F6;&#x5EF6;&#xFF08;Latency&#xFF09;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;2.1   HZ &#x8BBE;&#x7F6E;&#x4E3A; 250, 1000&#x7B49;.&lt;/p&gt;

&lt;p&gt;2.2 
&#x4E2D;&#x65AD;&#x7EBF;&#x7A0B;&#x5316;&#x540E;, &#x541E;&#x5410;&#x91CF;&#x53EF;&#x80FD;&#x4E0B;&#x964D;, &#x4F46;&#x7CFB;&#x7EDF;&#x5176;&#x5B83;&#x5730;&#x65B9;&#x7684;&#x65F6;&#x5EF6;&#x53EF;&#x80FD;&#x6539;&#x5584;.&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x7528;&#x7A7A;&#x95F4;&#x6362;&#x65F6;&#x95F4;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x8BA1;&#x7B97;&#x7ED3;&#x679C;&#x7F13;&#x5B58;&#x4E4B;&#x7C7B;&#x7684;, &#x6BD4;&#x5982; &#x4E00;&#x4E9B;&#x6570;&#x503C;&#x8BA1;&#x7B97;, &#x5F00;&#x6839;&#x53F7;&#x4EC0;&#x4E48;&#x7684;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. &#x6536;&#x655B;?&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;radix tree&#x7684;tag, &#x4E0D;&#x5FC5;&#x9010;&#x4E2A;&#x5224;&#x65AD;&#x8BE5;&#x8282;&#x70B9; &#x5B50;&#x6811; &#x4E0B;&#x7684;&#x53F6;&#x5B50;. &#x8FD9;&#x4E2A;&#x53EF;&#x80FD;&#x4E5F;&#x53EF;&#x4EE5;&#x5F52;&#x5230;  &#x7F13;&#x5B58; &#x4E2D;.&lt;/p&gt;

&lt;p&gt;hash&#x5E94;&#x8BE5;&#x4E5F;&#x7B97;&#x8FD9;&#x4E2A;&#x7C7B;&#x522B;.&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;5. &#x7F13;&#x5B58;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;buddy system &#x4E00;&#x5F00;&#x59CB;&#x4ECE;zone&#x7684;&#x94FE;&#x8868;&#x4E2D;&#x5206;&#x914D;, &#x91CA;&#x653E;&#x65F6;&#x653E;&#x5230;per cpu&#x7684;pcp, &#x540E;&#x7EED;&#x4ECE;pcp&#x4E2D;&#x53D6;, &#x51CF;&#x5C11;&#x4E86;&#x9501;&#x7684;&#x95EE;&#x9898;.&lt;/p&gt;

&lt;h1 id="toc_5"&gt;&lt;h4&gt;6. &#x9501;&#x7684;&#x95EE;&#x9898;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;6.1 &#x4F7F;&#x7528;per cpu.
&#x6BD4;&#x5982; lru&#x95EE;&#x9898; per cpu&#x7684; pagevec.&lt;/p&gt;

&lt;p&gt;6.2&lt;br&gt;
1. lock&#x5168;&#x5C40;&#x7684;&#x94FE;&#x8868;,&lt;br&gt;
2. &#x4ECE;&#x5168;&#x5C40;&#x7684;&#x94FE;&#x8868;&#x4E2D;&#x6311;&#x9009;&#x653E;&#x5165;on a local list,&lt;br&gt;
3. unlock &#x5168;&#x5C40;&#x7684;&#x94FE;&#x8868;&lt;br&gt;
4. &#x5BF9; local list&#x8FDB;&#x884C;&#x76F8;&#x5BF9;&#x6BD4;&#x8F83;&#x8017;&#x65F6;&#x7684;&#x64CD;&#x4F5C;&lt;/p&gt;

&lt;p&gt;&#x8FD9;&#x4E2A;&#x6BD4;&#x8F83;&#x5E38;&#x89C1;, &#x6BD4;&#x5982; ...&lt;/p&gt;

&lt;p&gt;6.3 RCU&#x7684;&#x9002;&#x7528;&#x8303;&#x56F4;
...&lt;/p&gt;

&lt;p&gt;6.4 &#x628A;&#x76F8;&#x5173;&#x4FE1;&#x606F; &#x6324;&#x5230;  int &#x4E2D;, &#x66F4;&#x65B0;int&#x662F;&#x539F;&#x5B50;&#x7684;, &#x5C31;&#x7701;&#x6389;&#x4E86;&#x9501;.
&#x6BD4;&#x5982;, 
strct page&#x4E2D;&#x6709;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct { /* SLUB */
    unsigned inuse:16;
    unsigned objects:15;
    unsigned frozen:1; 
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x5185;&#x6838;&#x4E2D; &#x901A;&#x8FC7; struct pt_regs &#x6765;&#x83B7;&#x53D6;  &#x7528;&#x6237;&#x4F20;&#x9012;&#x7684;&#x53C2;&#x6570;</title>
      <link>https://awakening-fong.github.io/posts/other/pt_regs_for_debug</link>
      <pubDate>2017-02-23</pubDate>
      <description>&lt;p&gt;&#x57FA;&#x4E8E; linux-2.6.35.7/drivers/char/mem.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;asm/ptrace.h&amp;gt;
#include &amp;lt;asm/uaccess.h&amp;gt;

static ssize_t kmsg_write(struct file *file, const char __user *buf,
              size_t count, loff_t *ppos)
{
    char *tmp;
    ssize_t ret;

    tmp = kmalloc(count + 1, GFP_KERNEL);
    if (tmp == NULL)
        return -ENOMEM;
    ret = -EFAULT;
    if (!copy_from_user(tmp, buf, count)) {
        tmp[count] = 0;
        //add
        #define STR_FOUND &amp;quot;sth_will_show_in_dmesg&amp;quot;
        if(NULL!=strstr(tmp,STR_FOUND))
        {
            struct pt_regs *usr_regs; 
            usr_regs=task_pt_regs(current); 
            if(valid_user_regs(usr_regs))
            {
                int fd=usr_regs-&amp;gt;ARM_r0;
                char *write_buf=usr_regs-&amp;gt;ARM_r1;
                int len=usr_regs-&amp;gt;ARM_r2;
                /*&#x7528;&#x6237;&#x6001;&#x7A0B;&#x5E8F;:
                #define STR_TMP &amp;quot;sth_will_show_in_dmesg&amp;quot;
                int fd=open(&amp;quot;/dev/kmsg&amp;quot;, O_WRONLY);
                write(fd,STR_TMP,strlen(STR_TMP));
                */

                /*
                &#x5185;&#x6838;&#x6253;&#x5370;:
                kmsg_write(),969:3 0x6fee0 22
                kmsg_write(),971:buf:sth_will_show_in_dmesg
                &#x4E5F;&#x5C31;&#x662F;&#x6253;&#x5370;&#x51FA;&#x4E86; &#x7528;&#x6237;&#x6001;&#x4F20;&#x9012;&#x7684;&#x53C2;&#x6570;
                */
                tmp_print(&amp;quot;%d 0x%x %d&amp;quot;,fd,write_buf,len);
                if(access_ok(VERIFY_READ, (void *) write_buf,strlen(write_buf)))
                    tmp_print(&amp;quot;buf:%s\n&amp;quot;,write_buf);
            }
            else
            {
                tmp_print(&amp;quot;not valid_user_regs\n&amp;quot;);
            }


        }
        //end add
        ret = printk(&amp;quot;%s&amp;quot;, tmp);
        if (ret &amp;gt; count)
            /* printk can add a prefix */
            ret = count;
    }
    kfree(tmp);
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>IIC&#x76F8;&#x5173;&#x5185;&#x5BB9;&#x7684;&#x8BB0;&#x5FC6;</title>
      <link>https://awakening-fong.github.io/posts/hw/iic</link>
      <pubDate>2017-02-15</pubDate>
      <description>&lt;p&gt;&#x672C;&#x6587;&#x7684;&#x5185;&#x5BB9; &#x4EC5;&#x4EC5;&#x662F;&#x4E3A;&#x4E86;&#x80FD;&#x591F;&#x56DE;&#x60F3;&#x8D77;IIC&#x76F8;&#x5173;&#x5185;&#x5BB9;, &#x5E76;&#x4E0D;&#x6C42;&#x4E25;&#x8C28;&#x548C;&#x51C6;&#x786E;.&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x8D77;&#x59CB;&#x548C;&#x505C;&#x6B62;&#x4FE1;&#x53F7;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x56E0;&#x4E3A;&#x4E0A;&#x62C9;&#x7701;&#x7535;, &#x6240;&#x4EE5;, &#x7A7A;&#x95F2;&#x65F6;, SDA&#x662F;&#x4E0A;&#x62C9;&#x7684;.&lt;br&gt;
SCL&#x548C;SDA&#x662F;&#x7EBF;&#x4E0E;&#x903B;&#x8F91;. &#x4E3A;&#x68C0;&#x6D4B;&#x8D77;&#x59CB;&#x4FE1;&#x53F7;, &#x7EBF;&#x4E0E;&#x7684;&#x7ED3;&#x679C;&#x53EF;&#x80FD;&#x662F;&#x63A5;&#x5230;&#x4E09;&#x6781;&#x7BA1;&#x4E0A;, &#x5047;&#x5B9A;&#x662F;NPN&#x578B;, &#x63A5;&#x5230;&#x53D1;&#x5C04;&#x6781;e, &#x903B;&#x8F91;&#x503C;&#x4E3A;0&#x65F6;&#x5BFC;&#x901A;&#x72B6;&#x6001;,&#x903B;&#x8F91;&#x503C;&#x4E3A;1&#x65F6;&#x622A;&#x6B62;&#x72B6;&#x6001;.&lt;br&gt;
&#x4E09;&#x6781;&#x7BA1;&#x622A;&#x6B62;&#x72B6;&#x6001;&#x4E0B;, 1 &amp;amp; SCL == 1, &#x6545;SCL&#x4E3A;1, &#x4E5F;&#x5C31;&#x662F;IIC&#x505C;&#x6B62;&#x65F6;, SCL&#x4E3A;&#x9AD8;&#x7535;&#x5E73;.&lt;br&gt;
IIC&#x8D77;&#x59CB;&#x65F6;, SDA&#x7531;&#x9AD8;&#x8F6C;&#x4F4E;, &#x4E09;&#x6781;&#x7BA1;&#x5BFC;&#x901A;.&lt;br&gt;
&#x6240;&#x4EE5;&#x6709;&#x4E0B;&#x56FE;:  &lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/IIC_start_stop.jpg"&gt;&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x6570;&#x636E;&#x7684;&#x7EC4;&#x7EC7; &#x548C; &#x8868;&#x793A;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5047;&#x5B9A;&#x662F;7bit&#x5730;&#x5740;&#x7684;&#x60C5;&#x51B5;.
&#x5148;&#x53D1;&#x9001;&#x9AD8;&#x4F4D;&#x8FD8;&#x662F;&#x4F4E;&#x4F4D;?&lt;br&gt;
&#x53EF;&#x4EE5;&#x8003;&#x8651;/&#x56DE;&#x5FC6;&#x4E0B; 7bit&#x5730;&#x5740;+1bit&#x8BFB;&#x5199; &#x65F6;&#x7684;&#x60C5;&#x51B5;, &#x6211;&#x4EEC;&#x662F;&#x5148;&#x53D1;&#x9001;&#x5730;&#x5740;&#x7684;, &#x6240;&#x4EE5;, &#x662F;&#x5148;&#x53D1;&#x9001;&#x9AD8;&#x4F4D;, &#x540E;&#x53D1;&#x9001;&#x4F4E;&#x4F4D;&#x7684;.&lt;/p&gt;

&lt;p&gt;&#x6700;&#x5E38;&#x89C1;&#x7684;&#x662F;r/w# &#x6240;&#x4EE5;,&#x8BFB;&#x4E3A;1, &#x5199;&#x4E3A;0.  &lt;/p&gt;

&lt;p&gt;&#x65F6;&#x949F;&#x6709;, &#x4EE3;&#x8868;&#x5FC3;&#x810F;&#x8FD8;&#x5728;&#x8DF3;, &#x5668;&#x4EF6;&#x8FD8;&#x5728;&#x5DE5;&#x4F5C;, &#x6240;&#x4EE5;, &#x5728;SCL&#x9AD8;&#x7535;&#x5E73;&#x65F6;&#x5BF9;SDA&#x91C7;&#x6837;&#x4F5C;&#x4E3A;&#x6570;&#x636E;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/IIC_SCL_high_SDA_valid.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x5982;SCL&#x9AD8;&#x7535;&#x5E73;&#x65F6;, SDA&#x53D1;&#x751F;&#x4E86;&#x8F6C;&#x6362;, &#x90A3;&#x4E48;, &#x5C31;&#x4E0D;&#x662F;&#x5728;&#x4F20;&#x9001;&#x6570;&#x636E;, &#x800C;&#x662F;&#x8868;&#x793A;&#x8D77;&#x59CB;&#x6216;&#x505C;&#x6B62;.&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x5F02;&#x5E38;&#x5904;&#x7406;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;ACK: &#x63A5;&#x6536;&#x5230;8bit&#x6570;&#x636E;&#x7684;&#x8981;&#x56DE;&#x590D;ACK, &#x8FD9;&#x6837;&#x662F;9bit. master&#x7AEF;&#x53D1;&#x9001;7bit&#x5730;&#x5740;+1bit&#x8BFB;&#x5199;, slave&#x56DE;&#x590D;ACK, &#x4E5F;&#x662F;9bit, &#x5F62;&#x5F0F;&#x4E0A;&#x7EDF;&#x4E00;.&lt;/p&gt;

&lt;p&gt;ACK&#x8981;&#x80FD;&#x591F;&#x88AB;&#x68C0;&#x6D4B;&#x5230;, &#x6545;&#x4E0D;&#x53D1;&#x9001;ACK&#x7684;&#x90A3;&#x65B9;&#x4E0D;&#x80FD;&#x53BB;&#x5E72;&#x6270;SDA, &#x6545;&#x4FDD;&#x6301;&#x9AD8;&#x7535;&#x4F4D;, &#x53D1;&#x9001;ACK&#x7684;&#x90A3;&#x65B9;&#x62C9;&#x4F4E;SDA.&lt;/p&gt;

&lt;p&gt;&#x5982;&#x679C; &#x4ECE;&#x673A;&#x63A5;&#x6536;&#x597D;&#x5B8C;&#x6574;&#x7684;&#x6570;&#x636E;&#x5B57;&#x8282;(&#x542B;&#x54CD;&#x5E94;&#x4F4D;) &#x540E;,  &#x8981;&#x5B8C;&#x6210;&#x4E00;&#x4E9B;&#x5176;&#x4ED6;&#x529F;&#x80FD;&#x540E; (&#x4F8B;&#x5982;&#x4E00;&#x4E2A;&#x5185;&#x90E8;&#x4E2D;&#x65AD;&#x670D;&#x52A1;&#x7A0B;&#x5E8F;), &#x624D;&#x80FD;&#x63A5;&#x6536;&#x6216;&#x53D1;&#x9001;&#x4E0B;&#x4E00;&#x4E2A;&#x5B8C;&#x6574;&#x7684;&#x6570;&#x636E;&#x5B57;&#x8282;, &#x53EF;&#x4EE5;&#x4F7F;&#x65F6;&#x949F;&#x7EBF; SCL &#x4FDD;&#x6301;&#x4F4E;&#x7535;&#x5E73;&#x8FEB;&#x4F7F;&#x4E3B;&#x673A;&#x8FDB;&#x5165;&#x7B49;&#x5F85;&#x72B6;&#x6001;. &lt;/p&gt;
</description>
    </item>
    <item>
      <title>page reclaim 06:ARM&#x548C;L_PTE_YOUNG</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_06_arm_l_pte_young</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. page_referenced_one&#x5BF9;&#x786C;&#x4EF6;&#x9875;&#x8868;&#x7684;&#x5F71;&#x54CD;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/include/asm-generic/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;page_referenced_one -&amp;gt; ptep_clear_flush_young_notify -&amp;gt; ptep_clear_flush_young -&amp;gt; ptep_test_and_clear_young
{
//pte_mkold &#x5B9E;&#x73B0;&#x4E0A;&#x662F;:PTE_BIT_FUNC(mkold,     &amp;amp;= ~L_PTE_YOUNG);
set_pte_at(vma-&amp;gt;vm_mm, address, ptep, pte_mkold(pte));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,
                  pte_t *ptep, pte_t pteval)
{
    unsigned long ext = 0;

    if (addr &amp;lt; TASK_SIZE &amp;amp;&amp;amp; pte_present_user(pteval)) {
        __sync_icache_dcache(pteval);
        ext |= PTE_EXT_NG;
    }
    /*
    @pteval &#x662F;linux&#x7248;&#x7684;pte
    &#x786C;&#x4EF6;&#x7248;&#x7684;&#x4F1A;&#x6839;&#x636E;ext&#x6765;&#x751F;&#x6210;
    */
    set_pte_ext(ptep, pteval, ext);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable-2level-hwdef.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PTE_EXT_NG      (_AT(pteval_t, 1) &amp;lt;&amp;lt; 11)    /* v6 */    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x4E2A;&#x540E;&#x7EED;&#x6CA1;&#x6709;&#x7528;&#x5230;, &#x5FFD;&#x7565;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable-2level.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define set_pte_ext(ptep,pte,ext) cpu_set_pte_ext(ptep,pte,ext)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set_pte_at -&amp;gt; set_pte_ext -&amp;gt; cpu_set_pte_ext -&amp;gt; cpu_v7_set_pte_ext&lt;/p&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x60F3;&#x77E5;&#x9053;&#x7684;&#x662F;: ext&#x4E2D; L_PTE_YOUNG&#x6CA1;&#x6709;&#x7F6E;&#x4F4D;&#x65F6;, &#x786C;&#x4EF6;&#x9875;&#x8868;&#x7684;&#x53D8;&#x5316;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/arch/arm/mm/proc-v7-2level.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ENTRY(cpu_v7_set_pte_ext)
...
@r1&#x662F;linux&#x7248;
tst r1, #L_PTE_YOUNG
tstne   r1, #L_PTE_VALID
@#define L_PTE_NONE     (_AT(pteval_t, 1) &amp;lt;&amp;lt; 11)
eorne   r1, r1, #L_PTE_NONE
tstne   r1, #L_PTE_NONE
moveq   r3, #0
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5F53;L_PTE_YOUNG&#x6CA1;&#x6709;&#x7F6E;&#x4F4D;&#x65F6;, &#x8FD9;&#x91CC;&#x4F1A;&#x6267;&#x884C;moveq r3, #0, 
&#x4E5F;&#x5C31;&#x662F;&#x9875;&#x8868;&#x9879;&#x4FEE;&#x6539;&#x4E3A;0, &#x7136;&#x540E;&#x5B58;&#x50A8;&#x5230;&#x786C;&#x4EF6;&#x7248;&#x9875;&#x8868;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x540E;&#x7EED;&#x8BBF;&#x95EE;&#x76F8;&#x5173;page&#x4F1A;&#x5982;&#x4F55;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6267;&#x884C;page_referenced_one&#x4E4B;&#x540E;, &#x7531;&#x4E8E;&#x786C;&#x4EF6;&#x9875;&#x8868;&#x88AB;&#x6E05;&#x96F6;, &#x540E;&#x7EED;&#x8BBF;&#x95EE;&#x5F15;&#x53D1;&#x5F02;&#x5E38;, &#x4F1A;&#x6267;&#x884C;&#x5230;handle_pte_fault.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/mm/memory.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handle_pte_fault
{
    if (!pte_present(entry)) {

        return ...
    }
    ...
    entry = pte_mkyoung(entry);
    ptep_set_access_flags() -&amp;gt;  set_pte_at()

}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E0A;&#x9762;&#x786C;&#x4EF6;&#x9875;&#x8868;&#x88AB;&#x6E05;&#x96F6;&#x4E86;, &#x4F46;&#x662F;linux&#x7248;&#x9875;&#x8868;&#x5E76;&#x6CA1;&#x6709;&#x6E05;&#x96F6;, &#x53EA;&#x6E05;&#x6389;L_PTE_YOUNG.
&#x8FD9;&#x91CC;&#x9700;&#x8981;&#x77E5;&#x9053;, if (!pte_present(entry))&#x662F;&#x5426;&#x4F1A;&#x6210;&#x7ACB;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define pte_present(pte)    (pte_isset((pte), L_PTE_PRESENT))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable-2level.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define L_PTE_PRESENT       (_AT(pteval_t, 1) &amp;lt;&amp;lt; 0)
#define L_PTE_YOUNG     (_AT(pteval_t, 1) &amp;lt;&amp;lt; 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4EE5;&#x901A;&#x8FC7;mmap&#x6765;&#x8BBF;&#x95EE;&#x6587;&#x4EF6;&#x4E3A;&#x4F8B;, &#x770B;&#x770B;&#x521B;&#x5EFA;&#x7684;linux&#x7684;pte.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mmap_region
|--vma-&amp;gt;vm_flags = vm_flags;
|--vma-&amp;gt;vm_page_prot = vm_get_page_prot(vm_flags);

vm_get_page_prot -&amp;gt; protection_map -&amp;gt; __PAGE_NONE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define __PAGE_NONE     __pgprot(_L_PTE_DEFAULT | ...&#x7701;&#x7565;...  )
#define _L_PTE_DEFAULT  L_PTE_PRESENT | L_PTE_YOUNG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;__PAGE_NONE &#x548C;&#x5176;&#x4ED6;&#x7684;__PAGE_xx &#x90FD;&#x542B;_L_PTE_DEFAULT.
&#x4E5F;&#x5C31;&#x662F;&#x8BF4;, &#x521B;&#x5EFA;&#x7684;linux&#x7248;pte&#x542B;&#x6709;L_PTE_PRESENT.&lt;/p&gt;

&lt;p&gt;set_pte_at -&amp;gt; set_pte_ext -&amp;gt; cpu_set_pte_ext -&amp;gt; cpu_v7_set_pte_ext&lt;br&gt;
cpu_v7_set_pte_ext&#x4E0D;&#x4F1A;&#x4FEE;&#x6539;&#x5230;L_PTE_PRESENT.&lt;br&gt;
&#x4E5F;&#x5C31;&#x662F;&#x8BF4;, &#x540E;&#x7EED;&#x5F02;&#x5E38;&#x65F6;, L_PTE_PRESENT&#x662F;&#x7F6E;&#x4F4D;&#x72B6;&#x6001;&#x4E86;, &#x540E;&#x7EED;&#x82E5;&#x56E0;reclaim&#x7684;&#x626B;&#x63CF;, L_PTE_YOUNG&#x4F1A;&#x88AB;&#x6E05;&#x6389;, &#x786C;&#x4EF6;&#x9875;&#x8868;&#x4E5F;&#x88AB;&#x6E05;&#x96F6;, &#x82E5;&#x8BBF;&#x95EE;&#x8BE5;&#x9875;&#x8868;&#x76F8;&#x5173;&#x7684;page, &#x4E0D;&#x8D70;if (!pte_present(entry)), &#x800C;&#x662F;&#x4F1A;&#x7F6E;&#x4F4D;L_PTE_YOUNG, &#x5E76;&#x6839;&#x636E;&#x8FD9;&#x4E2A;&#x542B;&#x6709;L_PTE_YOUNG&#x7684;linux&#x9875;&#x8868; &#x91CD;&#x65B0;&#x8BBE;&#x7F6E;&#x786C;&#x4EF6;&#x9875;&#x8868;.&lt;/p&gt;

&lt;p&gt;&#x7531;&#x4E8E;&#x8FD9;&#x4E2A;&#x5F02;&#x5E38;&#x53EA;&#x6709;&#x5728;&#x8BE5;page&#x88AB;reclaim&#x626B;&#x63CF;&#x5230;&#x540E;&#x624D;&#x4F1A;&#x53D1;&#x751F;, &#x6545;overhead&#x5E76;&#x4E0D;&#x4E25;&#x91CD;.  &lt;/p&gt;
</description>
    </item>
    <item>
      <title>page reclaim 03:&#x6D3B;&#x8DC3;&#x5EA6;&#x7684;&#x8868;&#x793A;&#x548C;&#x72B6;&#x6001;&#x8F6C;&#x6362;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_03_activity</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. page_referenced&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/rmap.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; * Quick test_and_clear_referenced for all mappings to a page,
 * returns the number of ptes which referenced the page.
&#x8FD9;&#x4E2A;&#x6CE8;&#x91CA;&#x8FC7;&#x65F6;&#x4E86;, &#x5B9E;&#x9645;&#x529F;&#x80FD;&#x5E76;&#x4E0D;&#x662F;&#x8FD4;&#x56DE;&#x6307;&#x5411;&#x8BE5;page&#x7684;pte&#x7684;&#x4E2A;&#x6570;. 

 &#x95EE;&#x9898;:&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x7684;&#x7528;&#x9014;?
 &#x7B54;:&#x7528;&#x6765;&#x53CD;&#x5E94;&#x5728;inactive list&#x4E2D;&#x7684;page&#x7684;&#x6D3B;&#x8DC3;&#x7A0B;&#x5EA6;.
 &#x8FD4;&#x56DE;&#x6570;&#x503C;1&#x548C;&#x8FD4;&#x56DE;&#x6570;&#x503C;2&#x662F;&#x6709;&#x533A;&#x522B;&#x7684;, see page_check_references
 {
     referenced_ptes = page_referenced(...);
     if (... || referenced_ptes &amp;gt; 1)
        return PAGEREF_ACTIVATE;

 }
 */
int page_referenced(struct page *page,
        int is_locked,
        struct mem_cgroup *memcg,
        unsigned long *vm_flags)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. L_PTE_YOUNG&#x548C; mark_page_accessed, &#x7528;&#x54EA;&#x4E2A;&#x5462;?&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6709;&#x4E9B;page&#x662F;&#x5148;kmap, &#x63A5;&#x7740; __copy_to_user, &#x6700;&#x540E;kunmap, &#x8FD9;&#x79CD;&#x4F7F;&#x7528;&#x4E4B;&#x540E; page&#x5C31;&#x88AB; unmap &#x6389;, &#x5982;&#x679C;&#x662F;highmem, &#x901A;&#x8FC7;pte young&#x6807;&#x8BB0;&#x5C31;&#x6CA1;&#x6709;&#x610F;&#x4E49;, &#x6545;&#x91C7;&#x7528;mark page accessed&#x6765;&#x63D0;&#x5347;&#x6D3B;&#x8DC3;&#x5EA6;.
&#x8FD9;&#x79CD;&#x7C7B;&#x578B;&#x7684;page, &#x6CA1;&#x6709;&#x88AB;&#x8FDB;&#x7A0B;&#x5F15;&#x7528;, &#x56DE;&#x6536;&#x65F6;&#x4E5F;&#x65E0;&#x9700;&#x4FEE;&#x6539;&#x9875;&#x8868;.
&#x6216;&#x8005;&#x8BF4;, &#x8BE5;page&#x6CA1;&#x6709;&#x548C;&#x8FDB;&#x7A0B;&#x5173;&#x8054;, &#x6545;&#x4E0D;&#x901A;&#x8FC7;&#x9875;&#x8868;&#x6765;&#x6807;&#x8BB0;&#x6D3B;&#x8DC3;&#x5EA6;.&lt;/p&gt;

&lt;p&gt;&#x5BF9;&#x4E8E;&#x548C;&#x8FDB;&#x7A0B;&#x5173;&#x8054;&#x7684;page, L_PTE_YOUNG&#x6CA1;&#x6709;&#x7F6E;&#x4F4D;&#x65F6;, &#x8BBF;&#x95EE;&#x4F1A;&#x53D1;&#x751F;&#x5F02;&#x5E38;, &#x5728;fault handler&#x4E2D;&#x4F1A;&#x7F6E;&#x4F4D;L_PTE_YOUNG, &#x5B8C;&#x6210;&#x6D3B;&#x8DC3;&#x5EA6;&#x7684;&#x6807;&#x8BB0;.
&#x88AB;&#x626B;&#x63CF;&#x5230;&#x65F6;, &#x5224;&#x65AD;&#x6D3B;&#x8DC3;&#x5EA6;&#x4FE1;&#x606F;&#x540E;, &#x603B;&#x662F;&#x4F1A;&#x88AB;&#x6E05;&#x6389;L_PTE_YOUNG, &#x5982;&#x679C;&#x6709;L_PTE_YOUNG&#x7684;&#x8BDD;.&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. page_check_references&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6D3B;&#x8DC3;&#x7A0B;&#x5EA6; &#x4F53;&#x73B0;&#x5728; &#x4E24;&#x4E2A;&#x65B9;&#x9762;, 
&#x4E00;&#x4E2A;&#x662F;  &#x8BE5;page&#x53EF;&#x80FD;&#x5728;&#x591A;&#x4E2A;&#x8FDB;&#x7A0B;/&#x7EBF;&#x7A0B;&#x4E2D;&#x88AB;&#x5F15;&#x7528;, &#x8FD9;&#x4E9B;&#x8FDB;&#x7A0B;&#x4E2D;&#x8BE5;page&#x7684;pte&#x7684;young&#x6709;&#x6240;&#x4F53;&#x73B0;,&lt;br&gt;
&#x53E6;&#x4E00;&#x4E2A;&#x662F; struct page&#x7684;flag PG_referenced, PG_active.&lt;/p&gt;

&lt;p&gt;shrink_inactive_list -&amp;gt; shrink_page_list -&amp;gt; page_check_references&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static enum page_references page_check_references(struct page *page,
                      struct scan_control *sc)
{
    int referenced_ptes, referenced_page;
    unsigned long vm_flags;

    referenced_ptes = page_referenced(page, 1, sc-&amp;gt;target_mem_cgroup,
                      &amp;amp;vm_flags);
    referenced_page = TestClearPageReferenced(page);


    if (referenced_ptes) {
            SetPageReferenced(page);

        if (referenced_page || referenced_ptes &amp;gt; 1)
            return PAGEREF_ACTIVATE;
        ...
        return PAGEREF_KEEP;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x5982;&#x4F55;&#x7406;&#x89E3;&#x8FD9;&#x91CC;&#x7684; SetPageReferenced?&lt;br&gt;
&#x7B54;: page_referenced()&#x603B;&#x662F;&#x4F1A;&#x6E05;&#x6389;pte&#x7684;young, &#x5982;&#x679C;&#x8FD9;&#x91CC;(shrink_inactive_list -&amp;gt; .. -&amp;gt; page_check_references)&#x4E0D;SetPageReferenced, 
&#x76F8;&#x5F53;&#x4E8E;&#x4E00;&#x4E0B;&#x5B50;&#x628A;&#x8F83;&#x6D3B;&#x8DC3;&#x7684;page&#x7684;&#x6D3B;&#x8DC3;&#x5EA6;&#x5168;&#x90E8;&#x62B9;&#x6389;, &#x4F3C;&#x4E4E;&#x5E76;&#x4E0D;&#x5408;&#x9002;, &#x6545;&#x8FD9;&#x91CC;SetPageReferenced&#x7ED9;page&#x4FDD;&#x7559;&#x4E00;&#x70B9;&#x6D3B;&#x8DC3;&#x5EA6;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. mm: don&amp;#39;t mark_page_accessed in fault path&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/filemap.c&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;filemap_fault() is invoked via the vma operations vector for a
mapped memory region to read in file data during a page fault.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;filemap_fault  
|--count_vm_event(PGMAJFAULT);  
|--no_cached_page: page_cache_read(file, offset);  
|   |--page_cache_alloc_cold  
|   |--add_to_page_cache_lru -&amp;gt; lru_cache_add_file  
|   |   |--__lru_cache_add(page, LRU_INACTIVE_FILE)  
|   |--mapping-&amp;gt;a_ops-&amp;gt;readpage  
|--retry_find:  page = find_get_page(mapping, offset)  
|--&lt;del&gt;mark_page_accessed&lt;/del&gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mm: don&amp;#39;t mark_page_accessed in fault path 
&lt;a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=bf3f3bc5e734706730c12a323f9b2068052aa1f0"&gt;https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=bf3f3bc5e734706730c12a323f9b2068052aa1f0&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Doing a mark_page_accessed at fault-time, then doing SetPageReferenced at unmap-time if the pte is young       has a number of problems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x672C;&#x8865;&#x4E01;&#x4E4B;&#x524D;&#x7684;&#x65B9;&#x5F0F;&#x662F;, &#x5982;&#x679C;
fault&#x65F6;mark_page_accessed, &#x7136;&#x540E;, unmap&#x65F6;&#x82E5;pte young&#x5219;SetPageReferenced, 
&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x4F1A;&#x5BFC;&#x81F4;&#x4E00;&#x4E9B;&#x95EE;&#x9898;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;So calling mark_page_accessed not only adds extra lru or PG_referenced manipulations for pages that are already going to have pte_young ptes anyway, but it also adds these references which are difficult to work with from the context of vma specific references (eg. MADV_SEQUENTIAL pte_young may not wish to contribute to the page being referenced).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x53CD;&#x6B63;&#x5C31;&#x8981;&#x7ED9;pte&#x7F6E;&#x4F4D;young&#x4E86;, &#x5C31;&#x4E0D;&#x8981;&#x518D;&#x5F04;&#x4E2A;&#x989D;&#x5916;&#x7684;page flag&#x4E86;. &#x800C;&#x4E14;&#x8FD8;&#x4F1A;&#x7ED9; &#x8C01;&#x8C01;&#x8C01; &#x6DFB;&#x5835;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Then, simply doing SetPageReferenced when zapping a pte and finding it is young, is not a really good solution either. SetPageReferenced does not correctly promote the page to the active list for example. So after removing mark_page_accessed from the fault path, several mmap()+touch+munmap() would have a very different result from several read(2) calls for example, which is not really desirable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x4E4B;&#x524D;&#x7684;&#x5904;&#x7406;, &#x5728;&#x7B2C;2&#x56DE;&#x7684; munmap&#x4F1A;&#x628A;&#x4E0A;&#x56DE;&#x7684;&#x4FE1;&#x606F;&#x4E22;&#x5931;&#x6389;, &#x6545;&#x6D3B;&#x8DC3;&#x5EA6;&#x548C; read&#x7684;&#x7ED3;&#x679C;&#x4E0D;&#x540C;.&lt;/p&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;4.1 unmap&#x65F6;&#x7684;&#x5904;&#x7406;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;linux-3.10.86/mm/memory.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zap_pte_range
{
    if (PageAnon(page))
        ...
    else{
        if (pte_present(ptent)) {
                if (pte_young(ptent) &amp;amp;&amp;amp;
                    likely(!VM_SequentialReadHint(vma)))
                    /*&#x95EE;&#x9898;:&#x6211;&#x4EEC;&#x662F;&#x5728;unmap, &#x4E3A;&#x4F55;&#x8981;mark accessed?*/
                    mark_page_accessed(page);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x6211;&#x4EEC;&#x662F;&#x5728;unmap, &#x4E3A;&#x4F55;&#x8981;mark accessed?&lt;br&gt;
&#x7B54;:&#x7531;&#x4E8E;unmap, &#x5BFC;&#x81F4;&#x539F;&#x5148;&#x901A;&#x8FC7;young&#x6807;&#x8BB0;&#x7684;&#x6D3B;&#x8DC3;&#x5EA6;&#x4FE1;&#x606F;&#x5C06;&#x4F1A;&#x6D88;&#x5931;, &#x6545;&#x6539;&#x7528;mark_page_accessed&#x6765;&#x53CD;&#x6620;&#x8BE5;&#x4FE1;&#x606F;.&lt;/p&gt;

&lt;p&gt;&#x8FD9;&#x662F; &#x975E;if (PageAnon(page))&#x7684;&#x60C5;&#x51B5;, &#x8FD9;&#x6837;&#x5373;&#x4F7F;&#x8131;&#x79BB;pte, &#x8FD8;&#x53EF;&#x901A;&#x8FC7;radix tree&#x627E;&#x5230;&#x8BE5;page,  &#x8FDB;&#x800C;&#x4F7F;&#x7528;&#x4E4B;&#x524D;&#x7684;page&#x5185;&#x5BB9;, &#x8FD9;&#x6837;, &#x6807;&#x8BB0;&#x6D3B;&#x8DC3;&#x5EA6;&#x624D;&#x6709;&#x610F;&#x4E49;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>page reclaim 05:page count</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_05_page_count</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/vmscan.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline int is_page_cache_freeable(struct page *page)
{

    /*
     * A freeable page cache page is referenced only by the caller
     * that isolated the page, the page cache radix tree and
     * optional buffer heads at page-&amp;gt;private.
     */
    return page_count(page) - page_has_private(page) == 2;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E3A;&#x4F55;&#x662F;== 2?&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x89E3;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x8C03;&#x7528;&#x8DEF;&#x5F84;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_inactive_list
|--lru_add_drain
|--isolate_lru_pages
|   |--get_page_unless_zero  //&#x5F15;&#x7528;&#x8BA1;&#x6570;
|--shrink_page_list   (shrink_page_list&#x4E0D;&#x4F1A;&#x88AB;shrink_active_list&#x8C03;&#x7528;.)
|   |--pageout
|   |   |--is_page_cache_freeable
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_2"&gt;&lt;h4&gt;2.1 isolated the page&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x7565;&lt;/p&gt;

&lt;h2 id="toc_3"&gt;&lt;h4&gt;2.2 buddy system&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x6CE8;&#x91CA;&#x4E2D;&#x63D0;&#x5230;&amp;quot;the page cache radix tree&amp;quot;&#x7684;&#x5F15;&#x7528;&#x8BA1;&#x6570;, &#x8FD9;&#x4E2A;&#x6CE8;&#x91CA;&#x5E76;&#x4E0D;&#x51C6;&#x786E;, &#x5E94;&#x8BE5;&#x662F;&#x4ECE;buddy system&#x5206;&#x914D;&#x4EA7;&#x751F;&#x7684;&#x5F15;&#x7528;&#x8BA1;&#x6570;.&lt;/p&gt;

&lt;p&gt;buddy system&#x7684;get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;page_cache_alloc_cold -&amp;gt; __alloc_pages_nodemask
|   |--get_page_from_freelist
|   |   |--buffered_rmqueue 
|   |   |   |--prep_new_page
|   |   |   |   |--set_page_refcounted -&amp;gt; set_page_count(page, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5E76;&#x4E0D;&#x662F;radix tree&#x7684;get&#x7684;&#x7406;&#x7531;&#x5982;&#x4E0B;:&lt;br&gt;
&#x4EE5;do_generic_file_read &#x4E3A;&#x4F8B;, &#x770B;&#x4E0B;page cache&#x7684;get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_generic_file_read
|--no_cached_page: page_cache_alloc_cold -&amp;gt; __alloc_pages_nodemask
|   |--get_page_from_freelist
|   |   |--buffered_rmqueue 
|   |   |   |--prep_new_page
|   |   |   |   |--set_page_refcounted -&amp;gt; set_page_count(page, 1);
|--add_to_page_cache_lru
|   |--add_to_page_cache -&amp;gt; add_to_page_cache_locked
|   |   |   |--page_cache_get //&#x5F15;&#x7528;&#x8BA1;&#x6570;A
|   |   |   |--radix_tree_insert
|   |--lru_cache_add_file -&amp;gt; __lru_cache_add
|--readpage: mapping-&amp;gt;a_ops-&amp;gt;readpage(filp, page)
|--ret = actor(desc, page, offset, nr);//&#x6BD4;&#x5982;file_read_actor()
|--page_cache_release(page); //&#x5F15;&#x7528;&#x8BA1;&#x6570;B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4F7F;&#x7528;&#x5B8C;&#x540E;, &#x4FEE;&#x6539;&#x5F15;&#x7528;&#x8BA1;&#x6570;, &#x6545;&#x8FD9;&#x91CC;&#x5BF9;&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x6CA1;&#x6709;&#x5F71;&#x54CD;.&lt;/p&gt;

&lt;p&gt;lru&#x7684;&#x8BA1;&#x6570;&#x5462;?&lt;br&gt;
&#x7B54;:&#x52A0;&#x5165;pagevec&#x4E2D;&#x4F1A;get page, &#x6E05;&#x7A7A;pagevec&#x653E;&#x5165;lru&#x65F6;, &#x4F1A;put page.&lt;/p&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;2.3 buffer_head&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x82E5;page_has_private()&#x8FD4;&#x56DE;1, &#x5219;page_count&#x4E3A;3&lt;/p&gt;

&lt;p&gt;buffer_head&#x65F6;&#x7684;get page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grow_dev_page
|--find_or_create_page
|--alloc_page_buffers
|--link_dev_buffers(page, bh) -&amp;gt; attach_page_buffers
|   |--page_cache_get
|   |--set_page_private
|--page_cache_release(page);  //&#x548C;find_or_create_page&#x4E2D;&#x7684;get &#x5BF9;&#x5E94;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>page reclaim 00:&#x76F8;&#x5173;&#x8D44;&#x6599;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_00_references</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[Professional Linux Kernel Architecture]&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reducing Memory Access Latency by Satoru Moriya
&lt;a href="http://events.linuxfoundation.org/sites/events/files/lcjp13_moriya.pdf"&gt;http://events.linuxfoundation.org/sites/events/files/lcjp13_moriya.pdf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/"&gt;https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[Understanding the Linux Kernel, 3rd Edition]&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>page reclaim 01:&#x6982;&#x8FF0;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_01_overview</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x80CC;&#x666F;/&#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x672C;&#x6587;&#x4E0D;&#x8BA8;&#x8BBA; swapping (swap out to disk).  &lt;/p&gt;

&lt;p&gt;If a seldom-used page is backed by a block device (e.g., memory mappings
of files) then the modified pages need not be swapped out, but can be directly synchronized with the block device. The page frame can be reused, and if the data are required again, it can be reconstructed from the source. If a page is backed by a file but cannot be modified in memory (e.g., binary executable data), then it can be discarded if it is currently not required.
&#x901A;&#x8FC7;Writing back cached data&#x5373;&#x53EF;&#x5C06;&#x8FD9;&#x4E9B;page&#x91CA;&#x653E;.&lt;/p&gt;

&lt;p&gt;If a page is backed by a file but cannot be modified in memory (e.g., binary executable data), then it can be discarded if it is currently not required. &lt;/p&gt;

&lt;p&gt;&#x5C06; &#x6682;&#x65F6;&#x4E0D;&#x7528;&#x7684; &#x6216; &#x5F88;&#x5C11;&#x4F7F;&#x7528;&#x7684;  &#x5185;&#x5B58;&#x56DE;&#x7B3C;/&#x56DE;&#x6536;, &#x7ED9;&#x540E;&#x7EED;&#x5176;&#x4ED6;&#x4EBA;&#x4F7F;&#x7528;. &#x90A3;&#x4E48;, &#x5982;&#x4F55;&#x754C;&#x5B9A; &#x6682;&#x65F6;&#x4E0D;&#x7528; &#x6216; &#x5F88;&#x5C11;&#x4F7F;&#x7528; &#x5462;? &#x8FD9;&#x4E9B;&#x5DF2;&#x5206;&#x914D;&#x51FA;&#x53BB;&#x7684;&#x5185;&#x5B58;&#x90FD;&#x6563;&#x843D;&#x5728;&#x54EA;&#x91CC;?&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x6563;&#x843D;&#x5728;&#x54EA;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5982;&#x4F55;&#x627E;&#x5230;&#x8FD9;&#x4E9B;&#x5185;&#x5B58;&#x5462;? &#x5565;&#x94FE;&#x8868;&#x5417;?&lt;br&gt;
&#x7B54;:see add_to_page_cache_lru(), page_add_new_anon_rmap()&lt;/p&gt;

&lt;p&gt;&#x65B9;&#x5F0F;1:
add_to_page_cache_lru &#x628A;page&#x6DFB;&#x52A0;&#x5230; both the page cache and the LRU cache. 
Most importantly, it is used by mpage_readpages and do_generic_mapping_read, the standard functions in which the block layer ends up when reading data from a file or mapping.
&#x5F53;&#x7136;, &#x5B9E;&#x9645;&#x662F;&#x5148;&#x6DFB;&#x52A0;&#x5230;per cpu&#x7684;struct pagevec&#x4E2D;, &#x7B49;&#x6EE1;&#x4E86;&#x518D;&#x8F6C;&#x79FB;&#x5230;global&#x7684;lru&#x4E2D;.&lt;/p&gt;

&lt;p&gt;&#x65B9;&#x5F0F;2:
add_to_page_cache_lru &#x5C06;page&#x52A0;&#x5165;tree, &#x6545;&#x53EF;&#x8003;&#x8651;&#x4ECE;&#x5404;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;inode&#x904D;&#x5386;&#x5404;page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drop_caches_sysctl_handler -&amp;gt; iterate_supers(drop_pagecache_sb, NULL)
|--list_for_each_entry(inode, &amp;amp;sb-&amp;gt;s_inodes, i_sb_list)
|   |--invalidate_mapping_pages(inode-&amp;gt;i_mapping, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x5982;&#x4F55;&#x5224;&#x65AD;rarely used&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5982;&#x4E0A;&#x6240;&#x8FF0;, page&#x7EC4;&#x7EC7;&#x5728;&#x94FE;&#x8868;lru&#x4E2D;. &#x9996;&#x6B21;&#x8BBF;&#x95EE;page&#x4F1A;&#x5C06;page&#x653E;&#x5230;&#x94FE;&#x8868;&#x5F00;&#x5934;,  &#x4E0D;&#x8FC7;, &#x540E;&#x7EED;&#x8BBF;&#x95EE;page, &#x5E76;&#x4E0D;&#x4F1A;&#x628A;page&#x8C03;&#x6574;&#x5230;&#x94FE;&#x8868;lru&#x7684;&#x5F00;&#x5934;.
&#x4E3A;&#x4E86;&#x533A;&#x5206;&#x4F7F;&#x7528;&#x9891;&#x7387;, &#x5185;&#x6838;&#x5C06;&#x8F83;&#x5C11;&#x4F7F;&#x7528;&#x7684;page&#x653E;&#x5165;inactive list&#x4E2D;. &#x5982;&#x679C;&#x4F7F;&#x7528;&#x76F8;&#x5BF9;&#x9891;&#x7E41;, &#x5219;&#x79FB;&#x52A8;&#x5230;active list&#x4E2D;.&lt;br&gt;
&#x8FD9;&#x6837;, &#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x4ECE;&#x7279;&#x5B9A;&#x94FE;&#x8868;&#x4E2D;&#x5C1D;&#x8BD5;&#x5BF9;page&#x8FDB;&#x884C;&#x56DE;&#x6536;, &#x56E0;&#x4E3A;&#x8FD9;&#x4E9B;&#x94FE;&#x8868;&#x4E2D;&#x7684;page&#x76F8;&#x5BF9;&#x8F83;&#x5C11;&#x4F7F;&#x7528;.&lt;/p&gt;

&lt;p&gt;&#x9996;&#x6B21;&#x6DFB;&#x52A0;&#x5230;lru&#x7684;&#x8BDD;, &#x901A;&#x5E38;&#x662F;&#x6DFB;&#x52A0;&#x5230;inactive&#x90A3;&#x8FB9;, &#x5BF9;&#x4E8E;&#x533F;&#x540D;&#x9875;&#x6DFB;&#x52A0;&#x5230;active list, see  __do_fault, do_anonymous_page, do_wp_page&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. PG_referenced&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;page&#x5728;active list&#x548C;inactive list&#x4E4B;&#x95F4;&#x8FC1;&#x79FB;, &#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A;page&#x7684;&#x72B6;&#x6001;&#x8FC1;&#x79FB;&#x4E86;, &#x800C;&#x8FD9;&#x4E24;&#x8005;&#x7684;&#x8FC1;&#x79FB;&#x4EC5;&#x9700;&#x4E00;&#x6B65;, &#x5185;&#x6838;&#x8BA4;&#x4E3A;&#x8FD9;&#x4E2A;&#x4E0D;&#x5408;&#x9002;, &#x5F15;&#x5165;&#x4E86; PG_referenced. &lt;/p&gt;

&lt;p&gt;PG_referenced &#x548C; PG_active &#x7684;&#x533A;&#x522B;&lt;br&gt;
&#x5728;&#x5F15;&#x5165;PG_referenced&#x4E4B;&#x524D;, When the page is accessed, the flag is set, but when is it going to be removed again? Either the kernel does not remove it automatically, but then the page would remain in the active state forever even if it would only be used very little, or not at all anymore.   &lt;/p&gt;

&lt;p&gt;&#x4E3A;&#x6B64;, &#x6211;&#x4EEC;&#x9700;&#x8981;&#x80FD;&#x591F;&#x8BA4;&#x51FA; &#x6807;&#x8BB0;&#x4E86;PG_active&#x4F46;&#x4E0D;&#x5E38;&#x8BBF;&#x95EE;&#x7684;page.
&#x5F53;&#x524D;&#x7684;&#x65B9;&#x6CD5;&#x662F;&#x5F15;&#x5165;&#x4E86; PG_referenced &#x8FD9;&#x4E2A;&#x6807;&#x8BB0;.&lt;/p&gt;

&lt;p&gt;page fault&#x4F1A;&#x5C06;page &#x8BBE;&#x7F6E;&#x4E3A;active, &#x90A3;&#x4E48;, &#x662F;&#x5426;&#x4F1A;&#x4E00;&#x76F4;&#x5446;&#x5728;&#x67D0;&#x4E2A;list&#x4E2D;&#x5462;?&lt;br&gt;
&#x7B54;:&#x4E0D;&#x4F1A;, page_check_references &#x548C; mark_page_accessed &#x53CC;&#x65B9;&#x8FDB;&#x884C;&#x89D2;&#x9010;.&lt;/p&gt;

&lt;p&gt;inactive&#x4E0D;&#x4F1A;&#x76F4;&#x63A5;&#x8F6C;&#x53D8;&#x4E3A;active, &#x8981;&#x5148;unreferenced&#x8F6C;&#x53D8;&#x4E3A;referenced.&lt;br&gt;
&#x5982;&#x679C;D0&#x8868;&#x793A; PG_referenced , D1&#x8868;&#x793A; PG_active, &#x90A3;&#x4E48;, &#x72B6;&#x6001;&#x8F6C;&#x6362;&#x5373;&#x4E3A;:&lt;br&gt;
0b00-&amp;gt;0b01-&amp;gt;0b10-&amp;gt;0b11&lt;/p&gt;

&lt;p&gt;&#x5F15;&#x5165;&#x4E4B;&#x540E;, A highly active page has both PG_active and PG_referenced set.&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;5. &#x4F55;&#x5904;&#x8C03;&#x7528; page_check_references &#x548C; mark_page_accessed&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x8C03;&#x7528;page_check_references&#x7684;&#x8DEF;&#x5F84;:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_inactive_list -&amp;gt; shrink_page_list -&amp;gt; page_check_references
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5E38;&#x89C1;&#x7684;&#x8C03;&#x7528; mark_page_accessed&#x7684;&#x8DEF;&#x5F84;: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch_buffer -&amp;gt; mark_page_accessed(bh-&amp;gt;b_page)
do_generic_file_read -&amp;gt; mark_page_accessed(page)
generic_perform_write -&amp;gt; mark_page_accessed(page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4F55;&#x65F6; shrink   PG_referenced, PG_active?&lt;br&gt;
&#x7B54;: &#x5E38;&#x89C1;&#x7684;&#x6709;direct reclaim &#x548C; kswapd, &#x4EE5;&#x53CA;truncate&#x7B49;.&lt;/p&gt;

&lt;h1 id="toc_5"&gt;&lt;h4&gt;6. &#x5982;&#x4F55;&#x56DE;&#x6536;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5982;&#x6807;&#x9898;1&#x4E2D;&#x7684;&#x5185;&#x5BB9;&#x6240;&#x8FF0;, &#x5BF9;&#x4E8E;&#x6709;&#x5757;&#x8BBE;&#x5907;&#x540E;&#x5907;&#x7684;page, &#x5728;reclaim&#x540E;, &#x82E5;&#x540E;&#x7EED;&#x9700;&#x8981;, &#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x91CD;&#x65B0;&#x8BFB;&#x5165;&#x6765;&#x6062;&#x590D;, &#x6240;&#x4EE5;, &#x53EF;&#x5C06;page&#x7684;&#x5185;&#x5BB9;&#x56DE;&#x5199;&#x5230;&#x540E;&#x5907;&#x8BBE;&#x5907;&#x4E2D;, &#x7136;&#x540E;&#x5F52;&#x8FD8;&#x7ED9;buddy system, see shrink_inactive_list().&lt;/p&gt;

&lt;h1 id="toc_6"&gt;&lt;h4&gt;7. &#x6570;&#x636E;&#x7ED3;&#x6784;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;per zone : active list, inactive list&lt;br&gt;
per node :kswapd&lt;br&gt;
per cpu  :lru cache, &#x4E5F;&#x5C31;&#x662F; pagevec  &lt;/p&gt;
</description>
    </item>
    <item>
      <title>page reclaim 02:&#x5B9E;&#x73B0;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_02_implement</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;p&gt;&#x672C;&#x6587;&#x7B80;&#x5316;&#x63CF;&#x8FF0;, &#x5FFD;&#x7565;compound page, &#x5FFD;&#x7565;HUGEPAGE, &#x672A;&#x5F00;&#x542F;CONFIG_MEMCG, &#x672A;&#x5F00;&#x542F;CONFIG_SWAP.
&#x82E5;&#x65E0;&#x7279;&#x522B;&#x8BF4;&#x660E;, &#x672C;&#x6587;&#x4EC5;&#x8BA8;&#x8BBA;ARM&#x4F53;&#x7CFB;&#x7684;&#x60C5;&#x51B5;.&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x6570;&#x636E;&#x7ED3;&#x6784;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;per zone : active list, inactive list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct zone {
    struct lruvec       lruvec;
};

struct lruvec {
    struct list_head lists[NR_LRU_LISTS];
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;per node :kswapd  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kswapd_init -&amp;gt; for_each_node_state(nid, N_MEMORY) kswapd_run(nid)
kswapd_run -&amp;gt; pgdat-&amp;gt;kswapd = kthread_run(kswapd, pgdat, &amp;quot;kswapd%d&amp;quot;, nid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;per cpu  :lru cache, &#x4E5F;&#x5C31;&#x662F;struct pagevec&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x8C03;&#x7528;&#x903B;&#x8F91;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4F55;&#x65F6;&#x8C03;&#x7528;  shrink_active_list, &#x4F55;&#x65F6;&#x8C03;&#x7528; shrink_inactive_list ?&lt;/p&gt;

&lt;p&gt;&#x8C03;&#x7528;&#x8DEF;&#x5F84;:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_zones
|--shrink_zone -&amp;gt; shrink_lruvec
|    |--for_each_evictable_lru //&#x987A;&#x5E8F;&#x662F;INACTIVE_xx, ACTIVE_xx, ..
|    |  |--shrink_list
|    |  |   |--if active list, shrink_active_list 
|    |  |   |--else shrink_inactive_list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7531;&#x4E8E; shrink_active_list &#x5B58;&#x5728;&#x5C06;page&#x6DFB;&#x52A0;&#x5230;inactive list&#x7684;&#x60C5;&#x51B5; , &#x82E5;&#x4E4B;&#x540E;&#x518D; shrink_inactive_list &#x7684;&#x8BDD;, &#x5C31;&#x662F;&#x53CC;&#x91CD;&#x6253;&#x51FB;&#x4E86;,  &#x6545;shrink_lruvec()&#x4F1A; &#x5148;&#x8C03;&#x7528; shrink_inactive_list, &#x540E;&#x8C03;&#x7528;shrink_active_list.   &lt;/p&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x5E76;&#x4E0D;&#x4F1A;&#x603B;&#x662F;shrink_active_list, &#x53EA;&#x6709;&#x5728;inactive list&#x7684;page&#x76F8;&#x5BF9;&#x6BD4;&#x8F83;&#x5C11;&#x65F6;&#x624D;&#x4F1A;shrink_active_list.&lt;/p&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x5982;&#x679C;shrink_inactive_list&#x4E2D;&#x628A;page&#x79FB;&#x5230;active list, &#x90A3;&#x4E48;, shrink_active_list&#x4F1A;&#x4E0D;&#x4F1A;&#x53C8;&#x628A;&#x8BE5;page&#x632A;&#x5230; inactive list?&lt;br&gt;
&#x7B54;:&#x6211;&#x4EEC;&#x662F;&#x65B0;&#x6DFB;&#x52A0;&#x5230;active list&#x7684;, &#x961F;&#x5217;&#x662F;FIFO&#x7684;&#x65B9;&#x5F0F;, &#x6240;&#x4EE5;, &#x53EA;&#x8981;nr_to_scan&#x4E0D;&#x662F;&#x5F88;&#x5927;, &#x5C31;&#x53EF;&#x4EE5;&#x907F;&#x514D;&#x77ED;&#x65F6;&#x95F4;&#x5185;&#x88AB;&#x626B;&#x63CF;&#x5230;.&lt;/p&gt;

&lt;p&gt;&#x7531;&#x4E8E;page&#x88AB;&#x56DE;&#x6536;, &#x76F8;&#x5173;&#x9875;&#x8868;&#x9879;&#x9700;&#x8981;&#x5904;&#x7406;, &#x8FD9;&#x90E8;&#x5206;&#x9700;&#x8981;rmap, &#x672C;&#x6587;&#x7565;&#x53BB;.&lt;/p&gt;

&lt;h2 id="toc_2"&gt;&lt;h4&gt;3. shrink_active_list&lt;/h4&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;shrink_active_list
|--lru_add_drain
|--isolate_lru_pages(, , &amp;amp;l_hold, )
|    |--__isolate_lru_page  isolate&#x662F;&#x8BA9;page&#x8FD8;&#x5446;&#x5728;lru&#x4E0A;, &#x4F46;&#x6E05;&#x6389;PG_lru
|    |--list_move(&amp;amp;page-&amp;gt;lru, l_hold);  &#x632A;&#x5230;&#x94FE;&#x8868;(list_head) l_hold
|--for each page in struct list_head l_hold
|    |--page_referenced
|    |    |--page_referenced_file -&amp;gt; page_referenced_one -&amp;gt; ptep_clear_flush_young_notify -&amp;gt; pte_mkold
|    |    |--page_test_and_clear_young  ARM&#x4F53;&#x7CFB;&#x662F;&#x7A7A;&#x64CD;&#x4F5C;
|    |--ClearPageActive  and  list_add(&amp;amp;page-&amp;gt;lru, &amp;amp;l_inactive);
|    |--or list_add(&amp;amp;page-&amp;gt;lru, &amp;amp;l_active) //&#x4E0D;&#x8BA8;&#x8BBA;
|--move_active_pages_to_lru(lruvec, &amp;amp;l_active, &amp;amp;l_hold, lru);
|--move_active_pages_to_lru(lruvec, &amp;amp;l_inactive, &amp;amp;l_hold, lru - LRU_ACTIVE);
|    |--&#x5C06;l_inactive&#x7684;page move&#x5230; lruvec-&amp;gt;lists[lru - LRU_ACTIVE]&#x4E2D;,
|    |--put page, &#x5982;&#x679C;&#x4E3A;zero, &#x5219;__ClearPageActive + &#x4ECE;lru&#x4E2D;&#x79FB;&#x9664; + &#x6DFB;&#x52A0;&#x5230;l_hold&#x4E2D;, &#x5F85;&#x540E;&#x7EED;&#x6267;&#x884C;free 
|--free_hot_cold_page_list(&amp;amp;l_hold, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E0A;&#x9762;&#x7684;&#x6D41;&#x7A0B;&#x5FFD;&#x7565;Compound page. 
&#x6240;&#x4EE5;, &#x5E38;&#x89C1;&#x7684;&#x6D41;&#x7A0B;&#x662F;: &#x4ECE;active list&#x4E2D;&#x79FB;&#x9664;, &#x6DFB;&#x52A0;&#x5230;inactive list&#x4E2D;. &#x5982;&#x679C;page count&#x4E3A;0, &#x5C31;&#x4E0D;&#x5FC5;&#x6DFB;&#x52A0;&#x5230;list&#x4E2D;, &#x800C;&#x662F;free&#x6389;page.
&#x5BF9;&#x4E8E;&#x53EF;&#x6267;&#x884C;&#x6587;&#x4EF6;&#x7684;page, &#x6839;&#x636E;&#x60C5;&#x51B5;&#x53EF;&#x91CD;&#x65B0;&#x653E;&#x5165;active list.&lt;/p&gt;

&lt;p&gt;&#x5173;&#x4E8E;move_active_pages_to_lru&#x4E2D;put&#x540E;, page count&#x4E3A;0:&lt;br&gt;
linux-3.10.86/mm/vmscan.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;move_active_pages_to_lru
{

        /*
        &#x5728;buddy system&#x4E2D;&#x7684;page&#x7684;_count&#x4E3A;0.
        &#x4ECE;buddy system&#x53D6;&#x4E0B;, page&#x4E3A;1.
        &#x5F53;&#x524D;page&#x8FD8;&#x88AB;isolate_lru_pages get.
        &#x6240;&#x4EE5;, &#x5982;&#x679C;if (put_page_testzero(page))&#x6210;&#x7ACB;, &#x90A3;&#x5C31;&#x53EF;&#x80FD;&#x53D1;&#x751F;&#x4E0B;&#x9762;&#x7684;&#x5E8F;&#x5217;:
        alloc page
        isolate_lru_pages
        free page
        put_page_testzero
        */
        if (put_page_testzero(page)) {

            list_add(&amp;amp;page-&amp;gt;lru, pages_to_free);

        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. shrink_inactive_list&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;//&#x5FFD;&#x7565;Compound Page&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_inactive_list(..., enum lru_list lru)
|--lru_add_drain
|--isolate_lru_pages(, &amp;amp;page_list, ) //&#x6311;&#x51FA;&#x7684;page&#x653E;&#x5165;&#x94FE;&#x8868;page_list
|--shrink_page_list(&amp;amp;page_list, ) //&#x5C1D;&#x8BD5;reclaim, &#x6839;&#x636E;&#x60C5;&#x51B5;&#x53EF;&#x80FD;&#x7ED9;page&#x8BBE;&#x7F6E;PG_active.
|    |--VM_BUG_ON(PageActive(page));
|    |--page_check_references //&#x5224;&#x65AD;&#x662F;&#x5426;&#x8FDB;&#x884C;reclaim, &#x662F;&#x5426;&#x8BBE;&#x7F6E;active&#x7B49;
|    |  |--page_referenced
|    |--case PAGEREF_ACTIVATE:  ...
|    |--case PAGEREF_KEEP: ...
|    |--case PAGEREF_RECLAIM or PAGEREF_RECLAIM_CLEAN: ...
|--/*&#x5BF9;page_list&#x4E2D;&#x7684;page, &#x6839;&#x636E;page flag, &#x5C06;&#x5176;&#x653E;&#x5165;&#x5BF9;&#x5E94;lru. &#x82E5;-&amp;gt;_count put&#x540E;&#x4E3A;0, &#x5219;&#x653E;&#x5165;&#x94FE;&#x8868;, &#x540E;&#x7EED;free&#x6389;*/
|--putback_inactive_pages(, &amp;amp;page_list);
|-- /*&#x73B0;page_list&#x4E2D;&#x5B58;&#x653E;&#x7684;&#x662F; putback_inactive_pages()&#x68C0;&#x6D4B;put_page_testzero()&#x6210;&#x7ACB;&#x7684;page*/
|--free_hot_cold_page_list(&amp;amp;page_list, )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;4.1 shrink_page_list&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;[Professional Linux Kernel Architecture] p1072&lt;br&gt;
shrink_page_list sends the page to the associated backing store (which means the page is synchronized, swapped out, or discarded)&lt;/p&gt;

&lt;p&gt;[Professional Linux Kernel Architecture]p1074&lt;br&gt;
shrink_page_list returns the number of pages for which it succeeded to initiate writeout.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_page_list
{

    if (PageWriteback(page)) {

        &#x5982;&#x679C;&#x5141;&#x8BB8;&#x7B49;&#x5F85;&#x7684;&#x8BDD;, wait_on_page_writeback(page);
    }

    &#x82E5;&#x53EF;&#x56DE;&#x6536;, try_to_unmap

    if (PageDirty(page)) {
    //&#x8F83;&#x5C11;&#x53D1;&#x751F;, &#x8FD9;&#x91CC;&#x4E0D;&#x8BA8;&#x8BBA;
    }

    if (page_has_private(page)) {
    //&#x4E0D;&#x662F;&#x91CD;&#x70B9;, &#x8FD9;&#x91CC;&#x4E0D;&#x8BA8;&#x8BBA;
    }

    free_hot_cold_page

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_5"&gt;&lt;h4&gt;5. &#x5E38;&#x89C1;&#x95EE;&#x9898;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;direct reclaim&#x53EF;&#x80FD;&#x5BFC;&#x81F4;&#x5806;&#x6808;overflow&#x7684;&#x95EE;&#x9898;&lt;br&gt;
mm: vmscan: do not writeback filesystem pages in direct reclaim
&lt;a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ee72886d8ed5d9de3fa0ed3b99a7ca7702576a96"&gt;https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ee72886d8ed5d9de3fa0ed3b99a7ca7702576a96&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>page reclaim 04:&#x53C2;&#x6570;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_04_parameter</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;p&gt;&#x672A;&#x5F00;&#x542F;CONFIG_MEMCG, CONFIG_SWAP.&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. scan_control&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/vmscan.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct scan_control {

    /* Incremented by the number of inactive pages that were scanned */
    unsigned long nr_scanned;

    /* How many pages shrink_list() should reclaim 
    &#x95EE;&#x9898;:nr_to_reclaim&#x548C;nr_scanned&#x7684;&#x5173;&#x7CFB;?
    &#x7B54;:nr_to_reclaim&#x662F;&#x4E2A;setting data, nr_reclaimed&#x662F;runtime date.
    &#x901A;&#x5E38;&#x662F;&#x5148;&#x7ED9;struct scan_control sc&#x8BBE;&#x7F6E;&#x597D;&#x8FD9;&#x4E2A;&#x76EE;&#x6807;, 
    &#x7136;&#x540E;&#x542F;&#x52A8;&#x56DE;&#x6536;. 
    &#x5728; sum of shrink_list() &amp;gt; nr_to_reclaim&#x540E;&#x4E2D;&#x65AD;&#x56DE;&#x6536;, see shrink_lruvec() or do_try_to_free_pages().
    */
    unsigned long nr_to_reclaim;

    /*
    &#x8FD9;&#x91CC;&#x7684;may&#x7C7B;&#x4F3C;may I ..., may&#x7684;&#x610F;&#x601D;&#x662F; &#x662F;&#x5426;&#x53EF;&#x4EE5;, &#x662F;&#x5426;&#x5141;&#x8BB8;
    */
    int may_writepage;

    /*
    [Understanding the Linux Kernel, 3rd Edition]p695
    Lower priority implies scanning more pages.
    */
    int priority;

};

get_scan_count
{
        size = get_lru_size(lruvec, lru);
        scan = size &amp;gt;&amp;gt; sc-&amp;gt;priority;
        //&#x626B;&#x63CF;&#x7684;&#x91CF; &#x4E0E; list&#x7684;&#x5927;&#x5C0F; &#x6210;&#x6BD4;&#x4F8B;
}

shrink_lruvec
|--//1. &#x6839;&#x636E;&#x4F18;&#x5148;&#x7EA7;&#x7B49; &#x7ED9;&#x6570;&#x7EC4;nr[]&#x8D4B;&#x503C;
|--get_scan_count(lruvec, sc, nr); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. watermark &lt;/h4&gt;&lt;/h1&gt;

&lt;h2 id="toc_2"&gt;&lt;h4&gt;2.1 low watermark&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x53D1;&#x73B0;&#x4F4E;&#x4E8E;low watermark&#x65F6;, &#x5524;&#x9192;kswapd:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__alloc_pages_nodemask
|-- int alloc_flags = ALLOC_WMARK_LOW|ALLOC_CPUSET;
|--page = get_page_from_freelist(,alloc_flags,)
|--if (unlikely(!page)) 
|   |--__alloc_pages_slowpath()
|   |   |--if (!(gfp_mask &amp;amp; __GFP_NO_KSWAPD))
|   |   |   |--wake_all_kswapd(order, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_3"&gt;&lt;h4&gt;2.2 high watermark&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x8FBE;&#x5230;high watermark&#x65F6;&#x505C;&#x6B62;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zone_balanced(, balance_gap:0,)  //&#x7B80;&#x5316;&#x95EE;&#x9898;, &#x5FFD;&#x7565;CONFIG_COMPACTION
|--free &amp;gt; high_wmark_pages+balance_gap 
|-- and ...

pgdat_balanced //&#x7B80;&#x5316;&#x95EE;&#x9898;, &#x53EA;&#x770B;order&#x4E3A;0&#x7684;&#x60C5;&#x51B5;
{
    if (zone_balanced(..,balance_gap:0, ))
        return true
}


kswapd -&amp;gt; balance_pgdat
{
    ...
            shrink_zone
            shrink_slab

    if (pgdat_balanced(...))
        break;      /* kswapd: all done */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;2.3 min_free_kbytes&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;linux-3.10.86/Documentation/sysctl/vm.txt&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;min_free_kbytes:&lt;/p&gt;

&lt;p&gt;This is used to force the Linux VM to keep a minimum number of kilobytes free.  The VM uses this number to compute a watermark[WMARK_MIN] value for each lowmem zone in the system. Each lowmem zone gets a number of reserved free pages based proportionally on its size.&lt;/p&gt;

&lt;p&gt;Some minimal amount of memory is needed to satisfy PF_MEMALLOC allocations; if you set this to lower than 1024KB, your system will become subtly broken, and prone to deadlock under high loads.&lt;/p&gt;

&lt;p&gt;Setting this too high will OOM your machine instantly. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;linux-3.10.86/mm/vmscan.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pfmemalloc_watermark_ok
{
    pfmemalloc_reserve += min_wmark_pages(zone);
    wmark_ok = free_pages &amp;gt; pfmemalloc_reserve / 2;

    if (!wmark_ok &amp;amp;&amp;amp; waitqueue_active(&amp;amp;pgdat-&amp;gt;kswapd_wait)) {
        ...
        /*&#x5982;&#x679C;&#x7761;&#x7720;&#x4E2D;(waitqueue_active()), &#x5219;&#x5524;&#x9192;kswapd*/
        wake_up_interruptible(&amp;amp;pgdat-&amp;gt;kswapd_wait);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="https://lwn.net/Articles/422291/"&gt;https://lwn.net/Articles/422291/&lt;/a&gt;&lt;br&gt;
The thresholds kswapd/direct reclaim starts(ends) depend on
watermark[min,low,high] and currently all watermarks are set
based on min_free_kbytes. min_free_kbytes is the amount of
free memory that Linux VM should keep at least.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/mm/page_alloc.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__setup_per_zone_wmarks
{

    zone-&amp;gt;watermark[WMARK_MIN] = ...
    zone-&amp;gt;watermark[WMARK_LOW]  = min_wmark_pages(zone) + (tmp &amp;gt;&amp;gt; 2);
    zone-&amp;gt;watermark[WMARK_HIGH] = min_wmark_pages(zone) + (tmp &amp;gt;&amp;gt; 1);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x7684;ASID (Address Space ID)</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_asid</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;
&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2; http://blog.163.com/awaken_ing/blog/static/1206131972015112011286335
&lt;/p&gt;

&lt;p&gt;&#x5E73;&#x53F0;:ARM Versatile Express for Cortex-A9 (ARMv7)&lt;br&gt;
 # CONFIG_ARM_LPAE is not set, &#x4E5F;&#x5C31;&#x662F;&#x4F7F;&#x7528;Short-descriptor&#x683C;&#x5F0F;, ASID&#x5B58;&#x50A8;&#x5728;CONTEXTIDR&#x7684;&#x4F4E;8 bit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;31                         7          0
+-------------------------+-----------+
|      PROCID             |   ASID    |
+-------------------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x9875;&#x8868;&#x9879;&#x4E2D; nG == 1&#x65F6;, &#x8FD9;&#x4E2A;&#x9875;&#x8868;&#x9879;&#x4FE1;&#x606F;&#x5C31;&#x662F; non-global, &#x6216;&#x8005;&#x8BF4; process-specific, &#x5BF9;&#x5E94;&#x7684;TLB&#x4E2D;&#x5C31;&#x4F1A;&#x6709;ASID&#x4FE1;&#x606F;, &#x6267;&#x884C;&#x865A;&#x62DF;&#x5730;&#x5740;&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;&#x8F6C;&#x6362;&#x65F6;, ASID&#x4E5F;&#x9700;&#x8981;&#x53C2;&#x4E0E;&#x8BE5;&#x8FC7;&#x7A0B;.&lt;/p&gt;

&lt;p&gt;&#x7528;&#x6237;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x7684;&#x9875;&#x8868;&#x624D;&#x4F1A;&#x8BBE;&#x7F6E;nG&#x6807;&#x5FD7; (&#x5185;&#x6838;&#x5730;&#x5740;&#x7684;&#x4E00;&#x90E8;&#x5206;&#x5730;&#x5740;&#x8303;&#x56F4;&#x4F7F;&#x7528;TLB lockdown&#x6BD4;&#x8F83;&#x5408;&#x9002;):
linux-3.10.86/arch/arm/include/asm/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void set_pte_at(struct mm_struct *mm, unsigned long addr, 
                  pte_t *ptep, pte_t pteval) 
{ 
...
    if (addr &amp;lt; TASK_SIZE &amp;amp;&amp;amp; pte_present_user(pteval)) { 
... 
        ext |= PTE_EXT_NG; 
    } 
... 
    set_pte_ext(ptep, pteval, ext); 
}

set_pte_at -&amp;gt; set_pte_ext -&amp;gt; cpu_v7_set_pte_ext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;arm linux&#x4E2D;&#x901A;&#x8FC7;&#x8BBE;&#x7F6E;CONTEXTIDR, &#x8FDB;&#x800C;&#x8BBE;&#x7F6E;ASID, &#x76F8;&#x5173;&#x4EE3;&#x7801;&#x4E3A;:
linux-3.10.86/arch/arm/mm/proc-v7-2level.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ENTRY(cpu_v7_switch_mm) 
... 
mcr    p15, 0, r1, c13, c0, 1        @ set context ID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8C03;&#x7528;&#x5173;&#x7CFB;&#x4E3A;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context_switch() -&amp;gt;switch_mm() -&amp;gt; check_and_switch_context(struct mm_struct *mm, struct task_struct *tsk) -&amp;gt; cpu_switch_mm() -&amp;gt; cpu_v7_switch_mm(pgd_t * pgd, struct mm_struct *mm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux&#x628A;ASID&#x5B58;&#x50A8;&#x5728;mm-&amp;gt;context.id&#x7684;&#x4F4E;8&#x4F4D; (D7:D0).&lt;/p&gt;

&lt;p&gt;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x975E;&#x5185;&#x6838;&#x7EBF;&#x7A0B; (&#x5185;&#x6838;&#x7EBF;&#x7A0B;&#x4E0D;&#x4F1A;&#x8C03;&#x7528;&#x5230;dup_mm), &#x521D;&#x59CB;&#x5316;ASID&#x4E3A;0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;copy_mm -&amp;gt; dup_mm -&amp;gt; init_new_context
#define init_new_context(tsk,mm)   ({ atomic64_set(&amp;amp;mm-&amp;gt;context.id, 0); 0; })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5230;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#x7684;&#x65F6;&#x5019;&#x624D;&#x771F;&#x6B63;&#x5F00;&#x59CB;&#x7ED9;ASID&#x8D4B;&#x503C;, &#x5E76;&#x8BBE;&#x7F6E;CONTEXTIDR&#x5BC4;&#x5B58;&#x5668;.&lt;/p&gt;

&lt;p&gt;&#x6709;&#x5206;&#x914D;, &#x5C31;&#x8BE5;&#x6709;&#x56DE;&#x6536;, &#x8FD9;&#x4E5F;&#x662F;&#x4F7F;&#x7528;bitmap&#x6765;&#x7BA1;&#x7406;ASID, &#x800C;&#x4E0D;&#x662F;asid++&#x7684;&#x65B9;&#x5F0F;&#x7684;&#x539F;&#x56E0;. ASID&#x7684;&#x5206;&#x914D;&#x662F;&#x901A;&#x8FC7;bitmap&#x53D8;&#x91CF;asid_map&#x6765;&#x8BB0;&#x5F55;&#x7684;. set bit&#x7684;&#x64CD;&#x4F5C;&#x5728;new_context()&#x4E2D;&#x53EF;&#x4EE5;&#x627E;&#x5230;. &#x67E5;&#x627E;&#x5BF9;&#x8BE5;&#x53D8;&#x91CF;&#x7684;clear bit&#x64CD;&#x4F5C;, &#x8FDB;&#x7A0B;&#x9000;&#x51FA;&#x65F6;, &#x672C;&#x5E94;&#x6709;&#x8BE5;&#x52A8;&#x4F5C;(&#x6E05;asid_map&#x4E2D;&#x8BE5;&#x8FDB;&#x7A0B;&#x6240;&#x5BF9;&#x5E94;&#x7684;bit), &#x4F46;&#x5F88;&#x9057;&#x61BE;, &#x6CA1;&#x6709;&#x627E;&#x5230;, &#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x5077;&#x61D2;&#x4E86;?&lt;/p&gt;

&lt;p&gt;&#x7531;&#x4E8E;ASID&#x53EA;&#x6709;8bit, &#x8303;&#x56F4;&#x4E3A;0~0xff, &#x5F53;&#x8FD9;&#x4E9B;&#x503C;&#x5206;&#x914D;&#x5B8C;&#x540E;, &#x5C31;&#x9700;&#x8981;flush TLB, &#x540C;&#x65F6;&#x5BF9;generation&#x52A0;1, &#x7136;&#x540E;&#x91CD;&#x65B0;&#x5F00;&#x59CB;&#x5206;&#x914D;ASID. generation&#x4E3A;mm-&amp;gt;context.id&#x7684;&#x9AD8;24+32&#x4F4D;(D63:D8), &#x8FD9;&#x6837;, &#x540E;&#x7EED;&#x518D;&#x8C03;&#x5EA6;&#x5230;&#x8FD9;&#x4E2A;&#x8FDB;&#x7A0B;&#x65F6;, &#x5C31;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5224;&#x65AD;generation&#x662F;&#x5426;&#x53D8;&#x5316;&#x4E86;, &#x6765;&#x77E5;&#x9053; mm-&amp;gt;context.id&#x4E2D;&#x7684;ASID&#x662F;&#x5426;&#x8FD8;&#x6709;&#x6548;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>&#x4E2D;&#x65AD;, softirq, tasklet&#x7684;&#x533A;&#x522B;</title>
      <link>https://awakening-fong.github.io/posts/arm/interrupt_softirq_in_arm</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4E2D;&#x65AD;&#x6D41;&#x7A0B;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5047;&#x5B9A; CONFIG_MULTI_IRQ_HANDLER=y, handle_arch_irq &#x4E3A; gic_handle_irq.&lt;br&gt;
linux-3.10.86/arch/arm/kernel/setup.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__irq_svc @entry-armv.S
|   |--svc_entry    &#x4FDD;&#x5B58;spsr_&amp;lt;exception&amp;gt; &#x5230;r5
|   |--irq_handler
|   |   |--handle_arch_irq =&amp;gt; gic_handle_irq
|   |   |   |--irq_find_mapping  &#x5B8C;&#x6210; an hw irq number&#x5230;a linux irq&#x7684;&#x8F6C;&#x6362;
|   |   |   |--handle_IRQ(irqnr, regs) if not IPI 
|   |   |   |       |--generic_handle_irq  -&amp;gt; generic_handle_irq_desc -&amp;gt; handle_fasteoi_irq
|   |   |   |       |   |--raw_spin_lock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |   |--handle_irq_event
|   |   |   |       |   |   |--raw_spin_unlock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |   |   |--handle_irq_event_percpu -&amp;gt; action-&amp;gt;handler
|   |   |   |       |   |   |--raw_spin_lock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |   |--chip-&amp;gt;irq_eoi
|   |   |   |       |   |--raw_spin_unlock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |--irq_exit();  &#x8FD9;&#x91CC;&#x4E2D;&#x65AD;&#x8FD8;&#x662F;&#x7981;&#x7528;&#x7684;&#x5417;? &#x7B54;:&#x662F;&#x7684;, ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED
|   |   |   |       |   |--WARN_ON_ONCE(!irqs_disabled());
|   |   |   |       |   |--if( ... ) invoke_softirq() 
|   |   |   |       |   |    |--do_softirq -&amp;gt; __do_softirq
|   |   |   |       |   |    |    |--local_irq_enable   //&#x4FEE;&#x6539;CPSR I bit, &#x6253;&#x5F00;&#x4E2D;&#x65AD;
|   |   |   |       |   |    |    |--h-&amp;gt;action(h)
|   |   |   |       |   |    |    |--local_irq_disable  //&#x8FD9;&#x91CC;&#x4E3A;&#x4F55;&#x53C8;&#x7981;&#x6B62;&#x4E2D;&#x65AD;???
|   |   |   |       |--set_irq_regs(old_regs)  &#x8FD9;&#x91CC;&#x5F00;&#x542F;&#x4E2D;&#x65AD;? &#x7B54;:&#x4E0D;&#x662F;.
|   |--svc_exit r5, irq = 1  @entry-header.S
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5047;&#x5B9A;&#x53D1;&#x751F;&#x4E2D;&#x65AD;&#x524D;, &#x662F;&#x5904;&#x4E8E;svc&#x6A21;&#x5F0F;&#x7684;, &#x6240;&#x4EE5;, &#x4E0A;&#x9762;&#x6D41;&#x7A0B;&#x4E3A;__irq_svc.
&#x4E2D;&#x65AD;&#x4E0A;&#x534A;&#x90E8;&#x5206; &#x4E2D;&#x65AD;&#x662F;&#x5173;&#x95ED;&#x7684;, &#x4F55;&#x65F6;&#x91CD;&#x65B0;&#x4F7F;&#x80FD;&#x4E2D;&#x65AD;, &#x4E0A;&#x9762;&#x90FD;&#x4EE5;&#x6807;&#x51FA;. &#x4F7F;&#x80FD;&#x4E4B;&#x540E;, &#x5C31;&#x5F00;&#x59CB;&#x5904;&#x7406;&#x8F6F;&#x4E2D;&#x65AD;&#x4E86;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. tasklet&#x7684;&#x7279;&#x70B9;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4E24;&#x4E2A;&#x7C7B;&#x578B;&#x76F8;&#x540C;&#x7684;tasklet&#x4E0D;&#x80FD;&#x540C;&#x65F6;&#x8FD0;&#x884C;, &#x5373;&#x4F7F;&#x5728;&#x4E0D;&#x540C;&#x7684;&#x5904;&#x7406;&#x5668;&#x4E0A;&#x4E5F;&#x662F;&#x5982;&#x6B64;, &#x56E0;&#x4E3A;&#x4EE3;&#x7801;&#x4E0A;&#x68C0;&#x67E5;&#x7684;&#x5E76;&#x4E0D;&#x662F;per cpu&#x7684;&#x53D8;&#x91CF;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void __init softirq_init(void)
{
...
    open_softirq(TASKLET_SOFTIRQ, tasklet_action);
    open_softirq(HI_SOFTIRQ, tasklet_hi_action);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4EE3;&#x7801;:linux-3.10/kernel/softirq.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void tasklet_action(struct softirq_action *a)
{
        struct tasklet_struct *t
        ...
        if (tasklet_trylock(t)) {
            ...
            t-&amp;gt;func(t-&amp;gt;data);
        }

}

#ifdef CONFIG_SMP
static inline int tasklet_trylock(struct tasklet_struct *t)
{
    return !test_and_set_bit(TASKLET_STATE_RUN, &amp;amp;(t)-&amp;gt;state);
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. softirq&#x7684;&#x7279;&#x70B9;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;softirq&#x7684;pending&#x53D8;&#x91CF;&#x662F;per-cpu&#x7684;, &#x5E76;&#x4E0D;&#x4F1A;&#x963B;&#x6B62;&#x76F8;&#x540C;&#x7684;handler&#x540C;&#x65F6;&#x8FD0;&#x884C;&#x5728;&#x4E0D;&#x540C;&#x7684;cpu&#x4E0A;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/kernel/softirq.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__do_softirq
{

    pending = local_softirq_pending();
    set_softirq_pending(0);

    do {
        if (pending &amp;amp; 1) {

            -&amp;gt;action
        }

        pending &amp;gt;&amp;gt;= 1;
    }while (pending);

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x591A;&#x6838;&#x540C;&#x65F6;&#x83B7;&#x53D6;&#x8BFB;&#x5199;&#x9501;, &#x4F1A;&#x6B7B;&#x5FAA;&#x73AF;&#x5417;, &#x8FD8;&#x662F;&#x90FD;&#x5F97;&#x5230;&#x5199;&#x9501;</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_smp_rwlock</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;&#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;: http://blog.163.com/awaken_ing/blog/static/120613197201631133058159&lt;/p&gt;

&lt;p&gt;&#x672C;&#x7BC7;&#x53EA;&#x63D0;&#x95EE;, &#x4E0D;&#x89E3;&#x7B54;, &#x795D;&#x5F00;&#x5FC3;.&lt;/p&gt;

&lt;p&gt;&#x5982;&#x679C;&#x8BFB;&#x5199;&#x9501;&#x662F;unlocked, &#x7136;&#x540E;cpu 0&#x548C;cpu 1&#x90FD;&#x60F3;&#x83B7;&#x53D6;&#x5199;&#x9501;,
&#x5982;&#x8868;&#x683C;&#x6240;&#x793A;, CPU 0&#x5728;t2&#x65F6;&#x523B;&#x6267;&#x884C;&#x7684;&#x662F;wfene, &#x8FD9;&#x65F6;, CPU 1&#x6267;&#x884C;&#x7684;&#x662F;ldrex, &#x7136;&#x540E;&#x662F;&#x5426;&#x4F1A;&#x6709;cpu&#x80FD;&#x591F;&#x83B7;&#x53D6;&#x5230;&#x9501;?
&#x6E90;&#x7801;&#x6765;&#x81EA;
linux-3.10.86/arch/arm/include/asm/spinlock.h
arch_write_lock()&lt;/p&gt;

&lt;!--
&#x67E5;&#x770B;&#x6E90;&#x7801;&#x540E;, &#x5C06;&#x7B2C;1&#x4E2A;&lt;table&gt;&#x6539;&#x4E3A;
&lt;table class="table table-bordered table-striped table-condensed"&gt;

&#x65F6;&#x95F4; | CPU0                      |&#x65F6;&#x95F4;  |CPU1
-----|---------------------------|------|----
t0/t6| 1:    ldrex    %0, [%1]   |      |
t1/t7| teq    %0, #0             |      |
t2   |WFE("ne")                  |t2    |1:    ldrex    %0, [%1]
t3   |strexeq    %0, %2, [%1]    |t3    |teq    %0, #0
t4   |teq    %0, #0              |t4    |WFE("ne")
t5   |bne    1b                  |t5    |strexeq    %0, %2, [%1]
t6   |                           |t6    |teq    %0, #0
t7   |                           |t7    |bne    1b
--&gt;

&lt;table class="table table-bordered table-striped table-condensed"&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&#x65F6;&#x95F4;&lt;/th&gt;
&lt;th&gt;CPU0&lt;/th&gt;
&lt;th&gt;&#x65F6;&#x95F4;&lt;/th&gt;
&lt;th&gt;CPU1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;t0/t6&lt;/td&gt;
&lt;td&gt;1:    ldrex    %0, [%1]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t1/t7&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t2&lt;/td&gt;
&lt;td&gt;WFE(&amp;quot;ne&amp;quot;)&lt;/td&gt;
&lt;td&gt;t2&lt;/td&gt;
&lt;td&gt;1:    ldrex    %0, [%1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t3&lt;/td&gt;
&lt;td&gt;strexeq    %0, %2, [%1]&lt;/td&gt;
&lt;td&gt;t3&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t4&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;td&gt;t4&lt;/td&gt;
&lt;td&gt;WFE(&amp;quot;ne&amp;quot;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t5&lt;/td&gt;
&lt;td&gt;bne    1b&lt;/td&gt;
&lt;td&gt;t5&lt;/td&gt;
&lt;td&gt;strexeq    %0, %2, [%1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;t6&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;t7&lt;/td&gt;
&lt;td&gt;bne    1b&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;CPU 0&#x548C;CPU 1&#x90FD;&#x62FF;&#x5230; &#x5199;&#x9501;? &#x4E24;&#x4E2A;CPU&#x90FD;&#x6B7B;&#x5FAA;&#x73AF;? &#x597D;&#x50CF;&#x4E0D;&#x5E94;&#x8BE5;&#x554A;?
&#x672C;&#x7BC7;&#x53EA;&#x63D0;&#x95EE;, &#x4E0D;&#x89E3;&#x7B54;, &#x795D;&#x5F00;&#x5FC3;. ^_^&lt;/p&gt;

&lt;p&gt;&#x9644; linux-3.10.86/arch/arm/include/asm/spinlock.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void arch_write_lock(arch_rwlock_t *rw)
{
    unsigned long tmp;

    __asm__ __volatile__(
&amp;quot;1: ldrex   %0, [%1]\n&amp;quot;
&amp;quot;   teq %0, #0\n&amp;quot;
    WFE(&amp;quot;ne&amp;quot;)
&amp;quot;   strexeq %0, %2, [%1]\n&amp;quot;
&amp;quot;   teq %0, #0\n&amp;quot;
&amp;quot;   bne 1b&amp;quot;
    : &amp;quot;=&amp;amp;r&amp;quot; (tmp)
    : &amp;quot;r&amp;quot; (&amp;amp;rw-&amp;gt;lock), &amp;quot;r&amp;quot; (0x80000000)
    : &amp;quot;cc&amp;quot;);

    smp_mb();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x4ECE;create_mapping()&#x770B;arm linux&#x7684;&#x9875;&#x8868;</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_create_mapping_page_table</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;
&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;
http://blog.163.com/awaken_ing/blog/static/120613197201571932454226
&lt;/p&gt;

&lt;p&gt;create_mapping&#x4F1A;&#x8C03;&#x7528;&#x5230;alloc_init_pte(), &#x8FDB;&#x800C;&#x8C03;&#x7528;set_pte_ext()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define set_pte_ext(ptep,pte,ext) cpu_set_pte_ext(ptep,pte,ext)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;qemu&#x6A21;&#x62DF;&#x7684;versatilepb ARM Versatile/PB (ARM926EJ-S) ARMv5TEJ&lt;/p&gt;

&lt;p&gt;&#x6240;&#x4EE5;set_pte_ext(pte, pfn_pte(pfn, __pgprot(type-&amp;gt;prot_pte)), 0);&lt;/p&gt;

&lt;p&gt;&#x5C31;&#x662F;&lt;/p&gt;

&lt;p&gt;cpu_arm926_set_pte_ext (pte, pfn_pte(pfn, __pgprot(type-&amp;gt;prot_pte)), 0);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * cpu_arm926_set_pte_ext(ptep, pte, ext)
 *
 * Set a PTE and flush it out
 */
    .align  5
ENTRY(cpu_arm926_set_pte_ext)
#ifdef CONFIG_MMU
    armv3_set_pte_ext
    mov r0, r0
#ifndef CONFIG_CPU_DCACHE_WRITETHROUGH
    mcr p15, 0, r0, c7, c10, 1      @ clean D entry
#endif
    mcr p15, 0, r0, c7, c10, 4      @ drain WB
#endif
    mov pc, lr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5176;&#x4E2D;&#x5B8F;armv3_set_pte_ext&#x5B9E;&#x73B0;&#x5728; linux-2.6.35.7/arch/arm/mm/proc-macros.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * The ARMv3, ARMv4 and ARMv5 set_pte_ext translation function,
 * covering most CPUs except Xscale and Xscale 3.
 *
 * Permission translation:
 *  YUWD   AP   SVC User
 *  0xxx  0x00  no acc  no acc
 *  100x  0x00  r/o no acc
 *  10x0  0x00  r/o no acc
 *  1011  0x55  r/w no acc
 *  110x  0xaa  r/w r/o
 *  11x0  0xaa  r/w r/o
 *  1111  0xff  r/w r/w
 */

    .macro  armv3_set_pte_ext wc_disable=1
    str r1, [r0], #-2048        @ linux version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpu_arm926_set_pte_ext(ptep, pte, ext)&#x53C2;&#x6570;&#x4E2D;&#x7684;ptep&#x5DF2;&#x7ECF;&#x6307;&#x5411;linux&#x7248;&#x7684;pte&#x4E86;, linux&#x7248;&#x5728;&#x9AD8;&#x5730;&#x5740;, hw&#x7248;&#x5728;&#x4F4E;&#x5730;&#x5740;, &#x6240;&#x4EE5;&#x6709;&#x4E0A;&#x9762;&#x7684;-2048.&lt;br&gt;
arm hw&#x7248;&#x4E8C;&#x7EA7;&#x9875;&#x8868;&#x548C;linux&#x7248; &#x5728;&#x5185;&#x5B58;&#x5E03;&#x5C40;&#x7684;&#x5173;&#x7CFB;&#x5982;&#x4E0B;&#x56FE;&#x6240;&#x793A;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &#x9AD8;&#x5730;&#x5740;   +--------------+ x+1024*4
   ^     |   linux pte  | 
   |     |              |
   |     +--------------+ x+1024*3
   |     |   linux pte  | 
   |     |              |  
   |     +--------------+ x+1024*2
   |     |   hw pte     | 
   |     |              | 
   |     +--------------+ x+1024*1
         |   hw pte     |
         |              | 
  &#x4F4E;&#x5730;&#x5740;  +--------------+ x+0



    eor r3, r1, #L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_WRITE | L_PTE_DIRTY

    bic r2, r1, #PTE_SMALL_AP_MASK  @ keep C, B bits
    bic r2, r2, #PTE_TYPE_MASK
    orr r2, r2, #PTE_TYPE_SMALL
&#x5148;&#x6E05;&#x4F4E;2&#x4F4D;,&#x7136;&#x540E;D1:D0&#x5199;&#x4E3A;10,&#x4E5F;&#x5C31;&#x662F;&#x4F7F;&#x7528;small page


    tst r3, #L_PTE_USER         @ user?
    orrne   r2, r2, #PTE_SMALL_AP_URO_SRW
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5C06;linux&#x7248;&#x672C;&#x7684;L_PTE_USER&#x8F6C;&#x4E3A;arm&#x7248;&#x672C;&lt;br&gt;
&#x8FD9;&#x4E2A;bit(L_PTE_USER)&#x6765;&#x81EA;mem_types[]&#x7684;struct mem_type&#x7684;&#x6210;&#x5458;prot_pte&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static struct mem_type mem_types[] = {

    [MT_HIGH_VECTORS] = {
        .prot_pte  = L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_DIRTY |
                L_PTE_USER | L_PTE_EXEC,
        .prot_l1   = PMD_TYPE_TABLE,
        .domain    = DOMAIN_USER,
    },

};


tst r3, #L_PTE_WRITE | L_PTE_DIRTY  @ write and dirty?
orreq   r2, r2, #PTE_SMALL_AP_UNO_SRW
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7559;&#x610F;0x55| 0xaa==0xff, &#x5BF9;&#x5E94;&#x672C;&#x6BB5;&#x4EE3;&#x7801;&#x524D;&#x9762;&#x7684;&#x6CE8;&#x91CA;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Permission translation:
YUWD   AP   SVC User
1011  0x55  r/w no acc
110x  0xaa  r/w r/o
11x0  0xaa  r/w r/o
1111  0xff  r/w r/w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src="/assets/media/second-level_descriptor.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x95EE;&#x9898;:AP3&#x5230;AP0&#x662F;?&lt;br&gt;
&#x7B54;:If the level one descriptor defines a page-mapped access and the level two descriptor is for a large or small page, four access permission fields, ap3
to ap0, are specified, each corresponding to one quarter of the page. For small pages ap3 is selected by the top 1KB of the page and ap0 is selected by the bottom 1KB of the page. &lt;/p&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x5BF9;&#x4E8E;&#x4E8C;&#x7EA7;&#x9875;&#x8868;&#x4E2D;small page, &#x5F53;&#x524D;&#x662F;&#x54EA;&#x4E2A;domain&#x5462;?&lt;br&gt;
&#x7B54;:&#x6240;&#x5C5E;&#x7684;&#x4E00;&#x7EA7;&#x9875;&#x8868;&#x7684;domain&#x51B3;&#x5B9A;, &#x89C1;Figure3-4. D8:D5&#x8FD9;4&#x4E2A;bit&#x9009;&#x62E9;16&#x4E2A;domain&#x4E2D;&#x7684;&#x4E00;&#x4E2A;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/first-level_descriptor.jpg"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tst r3, #L_PTE_PRESENT | L_PTE_YOUNG    @ present and young?
movne   r2, #0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5BF9;&#x5E94;arm&#x7684;&#x4E8C;&#x7EA7;&#x9875;&#x8868;&#x4E2D;&#x7684;fault&#x7684;&#x60C5;&#x51B5;, &#x89C1;Figure3-9.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    .if \wc_disable
#ifdef CONFIG_CPU_DCACHE_WRITETHROUGH
    tst r2, #PTE_CACHEABLE
    bicne   r2, r2, #PTE_BUFFERABLE
#endif
    .endif
    str r2, [r0]            @ hardware version
    .endm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x76F8;&#x5173;&#x8D44;&#x6599;
ARM926EJ-S Technical Reference Manual &lt;/p&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x4E2D;&#x65AD;&#x5904;&#x7406;&#x8FC7;&#x7A0B;&#x4E2D;&#x5BC4;&#x5B58;&#x5668;&#x7684;&#x4FDD;&#x5B58;</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_int_pt_regs</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;
&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;
http://blog.163.com/awaken_ing/blog/static/1206131972015839465987
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#x6A21;&#x5F0F;   usr            exception                                   svc                             
-----|----|--------------------------------|---------------------------------------------------                                                                                               
&#x51FD;&#x6570;                 vector_\name:                             usr_entry:                         


                                                                            &#x5BF9;&#x5E94;&#x7684;&#x6C47;&#x7F16;&#x8BED;&#x53E5;:                    
                  +----------------+        0  +------------------+   ------------------------    
           &#x9AD8;&#x5730;&#x5740; |spsr_&amp;lt;exception&amp;gt;|           |      r0          |      str     r1, [sp]         
                  |                |        4  +------------------+    ----------------------     
             ^    +----------------+           |      r1          |                               
             |    |                |           |                  |                               
             |    |lr_&amp;lt;exception&amp;gt;  |           |      .           |                               
             |    |                |           |      .           |      stmib   sp, {r1 - r12}   
             |    +----------------+           |      .           |                               
                  |                |           |                  |                               
           &#x4F4E;&#x5730;&#x5740; |      r0        |           |     r12          |                               
                  |                |           |                  |                               
                  +----------------+       52  +------------------+     ----------------------    
                    struct stack               |      sp_usr      |                               
                                               |                  |                               
                                           56  +------------------+     stmdb   r0, {sp, lr}^     
                                               |     lr_usr       |                               
                                               |                  |                               
                                           60  +------------------+      ---------------------    
                                               |  lr_&amp;lt;exception&amp;gt;  |                               
                                               |                  |                               
                                           64  +------------------+                                
                                               | spsr_&amp;lt;exception&amp;gt; |      stmia   r0, {r2 - r4}    
                                               |                  |                               
                                           68  +------------------+                               
                                               |      -1          |                               
                                               |                  |                               
                                           72  +------------------+     -----------------------   
                                                struct  pt_regs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4EE3;&#x7801;&#x5728;linux-2.6.35.7/arch/arm/kernel/entry-armv.S&lt;/p&gt;

&lt;p&gt;lr_&amp;lt;exception&amp;gt; &#x8868;&#x793A; parent PC&lt;br&gt;
spsr_&amp;lt;exception&amp;gt; &#x8868;&#x793A; parent CPSR&lt;/p&gt;

&lt;p&gt;&#x53F3;&#x8FB9;72&#x4E2A;&#x5B57;&#x8282;&#x6784;&#x6210;&#x7684;&#x662F;struct  pt_regs.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x7684;iounmap()&#x5982;&#x4F55;&#x5904;&#x7406;&#x4E3B;&#x9875;&#x8868;(master page table)&#x7684;&#x540C;&#x6B65;</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_iounmap_master_table</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;: http://blog.163.com/awaken_ing/blog/static/120613197201510308269773&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x80CC;&#x666F;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5E73;&#x53F0;&#x4E3A;qemu ARM Versatile/PB (ARM926EJ-S) ARMv5TEJ, UP&lt;/p&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x77E5;&#x9053;&#x8FDB;&#x7A0B;&#x7684;&#x5185;&#x6838;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x7684;&#x9875;&#x8868; &#x548C; swapper_pg_dir &#x8FDB;&#x884C;&#x540C;&#x6B65;, &#x5728;&#x8FDB;&#x7A0B;&#x521B;&#x5EFA;&#x65F6;, do_fork()&#x4F1A;&#x62F7;&#x8D1D;&#x4E00;&#x7EA7;&#x9875;&#x8868;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x95EE;&#x9898;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;vmalloc() area&#x53D1;&#x751F;&#x5F02;&#x5E38;, &#x7531;do_translation_fault()&#x5904;&#x7406;, &#x5904;&#x7406;&#x7684;&#x662F;&#x4E00;&#x7EA7;&#x9875;&#x8868;&#x65E0;&#x6548;&#x7684;&#x60C5;&#x51B5;, &#x5904;&#x7406;&#x65B9;&#x6CD5;: If the init_task&amp;#39;s first level page tables contains the relevant entry, we copy the it to this task.&lt;/p&gt;

&lt;p&gt;&#x53EF;&#x4EE5;&#x731C;&#x60F3;, vmalloc&#x533A;&#x57DF;&#x7684;&#x9875;&#x8868;&#x662F; &#x4E24;&#x7EA7;&#x9875;&#x8868;(&#x4F4E;&#x4E24;&#x4F4D;D1D0&#x4E3A;0b01), &#x800C;&#x4E0D;&#x662F;section (D1D0&#x4E3A;0b10)&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/first-level_descriptor.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x6253;&#x5370;vmalloc&#x533A;&#x57DF;&#x7684;&#x5BF9;&#x5E94;&#x7684;&#x9875;&#x8868;, &#x53EF;&#x4EE5;&#x770B;&#x5230; D1D0 &#x65E2;&#x6709;0b01(&#x6307;&#x5411;&#x4E8C;&#x7EA7;&#x9875;&#x8868;), &#x4E5F;&#x6709;0b10(&#x65E0;&#x9700;&#x4E8C;&#x7EA7;&#x9875;&#x8868;) &#x7684;.&lt;/p&gt;

&lt;p&gt;&#x4ECE;cat /proc/vmallocinfo&#x53EF;&#x77E5;, &#x53EF;&#x77E5;0b10&#x4E0D;&#x662F;&#x7531;vmalloc()&#x5F15;&#x53D1;&#x7684;&#x9875;&#x8868;&#x521B;&#x5EFA;, &#x800C;&#x662F;ioremap(). (&#x8FD9;&#x91CC;&#x5E76;&#x4E0D;&#x662F;&#x8BF4;ioremap&#x521B;&#x5EFA;&#x7684;&#x90FD;&#x662F;section)&lt;/p&gt;

&lt;p&gt;&#x865A;&#x62DF;&#x5730;&#x5740;0xc9000000&#x5F00;&#x59CB;&#x5BF9;&#x5E94;&#x7684;&#x4E00;&#x7EA7;&#x9875;&#x8868;entry&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p /x *(int *)0xc0007240@65
$1 = {0x34000452, 0x34100452, 0x34200452, 0x34300452, 0x34400452, 0x34500452, 0x34600452, 0x34700452, 0x34800452, 
  0x34900452, 0x34a00452, 0x34b00452, 0x34c00452, 0x34d00452, 0x34e00452, 0x34f00452, 0x35000452, 0x35100452, 0x35200452, 
  0x35300452, 0x35400452, 0x35500452, 0x35600452, 0x35700452, 0x35800452, 0x35900452, 0x35a00452, 0x35b00452, 0x35c00452, 
  0x35d00452, 0x35e00452, 0x35f00452, 0x36000452, 0x36100452, 0x36200452, 0x36300452, 0x36400452, 0x36500452, 0x36600452, 
  0x36700452, 0x36800452, 0x36900452, 0x36a00452, 0x36b00452, 0x36c00452, 0x36d00452, 0x36e00452, 0x36f00452, 0x37000452, 
  0x37100452, 0x37200452, 0x37300452, 0x37400452, 0x37500452, 0x37600452, 0x37700452, 0x37800452, 0x37900452, 0x37a00452, 
  0x37b00452, 0x37c00452, 0x37d00452, 0x37e00452, 0x37f00452, 0x0}

# cat /proc/vmallocinfo
...
0xc9000000-0xcd001000 67112960 armflash_subdev_probe+0x64/0x120 ioremap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5BF9;&#x4E8E; 0b10(&#x65E0;&#x9700;&#x4E8C;&#x7EA7;&#x9875;&#x8868;) &#x5C31;&#x4E0D;&#x597D;&#x7406;&#x89E3;. &#x8003;&#x8651;&#x8FD9;&#x6837;&#x4E00;&#x79CD;&#x60C5;&#x51B5;,&lt;/p&gt;

&lt;p&gt;&#x8FDB;&#x7A0B;A&#x6267;&#x884C;ioremap(), &#x7136;&#x540E;&#x8FDB;&#x7A0B;B&#x66F4;&#x65B0;&#x4E86;the first level page table. &#x4E4B;&#x540E;&#x8FDB;&#x7A0B;A&#x6267;&#x884C;iounmap(), &#x8FDB;&#x7A0B;B&#x5982;&#x4F55;&#x80FD;&#x591F;&#x77E5;&#x9053;&#x5462;? (use-after-iounmap cases)&lt;/p&gt;

&lt;p&gt;&#x6240;&#x4EE5;, ioremap()&#x5BF9;&#x5E94;&#x7684;iounmap() &#x5982;&#x4F55;&#x5904;&#x7406;&#x4E00;&#x7EA7;&#x9875;&#x8868;, &#x624D;&#x80FD;&#x8FBE;&#x5230; &#x9875;&#x8868;&#x95F4;&#x7684;&#x540C;&#x6B65;?&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x89E3;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5148;&#x770B;&#x4E0B;&#x5728;&#x4F55;&#x5904;&#x521B;&#x5EFA;:&lt;/p&gt;

&lt;p&gt;&#x865A;&#x62DF;&#x5730;&#x5740;&#x7684;0xc9000000&#x7684;&#x4E00;&#x7EA7;&#x9875;&#x8868;&#x5728;0xc0007240&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) watch *(unsigned int *)0xc0007240
Watchpoint 5: *(unsigned int *)0xc0007240
(gdb) c
Continuing.
Watchpoint 5: *(unsigned int *)0xc0007240

Old value = 0
New value = 872416338
remap_area_sections (virt=&amp;lt;value optimized out&amp;gt;, pfn=213248, size=&amp;lt;value optimized out&amp;gt;, type=&amp;lt;value optimized out&amp;gt;)
    at arch/arm/mm/ioremap.c:207
207         pmd[1] = __pmd(__pfn_to_phys(pfn) | type-&amp;gt;prot_sect);
(gdb) p /x 872416338
$7 = 0x34000452
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7531; (gdb) bt &#x53EF;&#x77E5;, &#x8C03;&#x7528;&#x8DEF;&#x5F84;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ioremap
|--__arm_ioremap
|    |--__arm_ioremap_caller
|    |   |--__arm_ioremap_pfn_caller
|    |   |   |--remap_area_sections
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ioremap()&#x6709;remap_area_sections(), &#x76F8;&#x5BF9;&#x5E94;&#x7684;iounmap()&#x6709;unmap_area_sections()&lt;/p&gt;

&lt;p&gt;linux-2.6.35.7/arch/arm/mm/ioremap.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#ifndef CONFIG_SMP
/*
 * Section support is unsafe on SMP - If you iounmap and ioremap a region,
 * the other CPUs will not see this change until their next context switch.
 * Meanwhile, (eg) if an interrupt comes in on one of those other CPUs
 * which requires the new ioremap&amp;#39;d region to be referenced, the CPU will
 * reference the _old_ region.
 *
 * Note that get_vm_area_caller() allocates a guard 4K page, so we need to
 * mask the size back to 1MB aligned or we will overflow in the loop below.
 */
static void unmap_area_sections(unsigned long virt, unsigned long size)
{
        do {
            ...
                init_mm.context.kvm_seq++;
                ...
        } while (addr &amp;lt; end);

 /*
  * Ensure that the active_mm is up to date - we want to
  * catch any use-after-iounmap cases.
  */
 if (current-&amp;gt;active_mm-&amp;gt;context.kvm_seq != init_mm.context.kvm_seq)
  __check_kvm_seq(current-&amp;gt;active_mm);
}
void __check_kvm_seq(struct mm_struct *mm)
{
...
memcpy(pgd_offset(mm, VMALLOC_START), ...);
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x53EA;&#x5904;&#x7406;&#x4E86;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;, &#x5176;&#x4ED6;&#x8FDB;&#x7A0B;&#x5462;? &#x641C;&#x7D22; kvm_seq, &#x627E;&#x5230;&lt;/p&gt;

&lt;p&gt;linux-2.6.35.7/arch/arm/include/asm/mmu_context.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;check_context
{
if (unlikely(mm-&amp;gt;context.kvm_seq != init_mm.context.kvm_seq))
  __check_kvm_seq(mm);
}

switch_mm
{
check_context(next);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x5728;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#x65F6;, &#x4F1A;&#x77E5;&#x9053;&#x4E00;&#x7EA7;&#x9875;&#x8868;&#x53D1;&#x751F;&#x4E86;&#x53D8;&#x5316;, &#x8FDB;&#x800C;&#x540C;&#x6B65;&#x4E0A;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>&#x5173;&#x4E8E;arm linux&#x7684;map_io</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_map_io</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt; &#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2; http://blog.163.com/awaken_ing/blog/static/1206131972016226674429
&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4E3B;&#x8981;&#x6D41;&#x7A0B;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5E73;&#x53F0;:versatilepb ARM Versatile/PB (ARM926EJ-S) &#x5185;&#x6838;&#x7248;&#x672C;2.6.35.7&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paging_init
|--devicemaps_init
|   |--from VMALLOC_END, pmd_clear(pmd_off_k(addr))
|   |--mdesc-&amp;gt;map_io() =&amp;gt; versatile_map_io  
|   |   |--iotable_init
|   |   |   |--create_mapping
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x4E3A;&#x4F55;&#x662F; MT_DEVICE&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-2.6.35.7/arch/arm/mach-versatile/core.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void __init versatile_map_io(void)
{
    iotable_init(versatile_io_desc, ARRAY_SIZE(versatile_io_desc));
}

static struct map_desc versatile_io_desc[] __initdata = {
    {
        ...
        .type       = MT_DEVICE
    },
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x662F; MT_DEVICE, &#x800C;&#x4E0D;&#x662F; MT_UNCACHED, why?&lt;/p&gt;

&lt;p&gt;MT_DEVICE&#x7C7B;&#x578B;&#x548C; MT_UNCACHED &#x7684;&#x533A;&#x522B;&#x5728; .prot_pte &#x548C; .prot_sect &#x4E0A;.&lt;/p&gt;

&lt;p&gt;&#x770B;&#x770B; .prot_pte &#x548C; .prot_sect &#x7684;&#x4F5C;&#x7528;?&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;2.1 .prot_pte &#x7528;&#x9014;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4F7F;&#x7528;&#x5230; .prot_pte &#x7684;&#x5730;&#x65B9;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alloc_init_pte
{
    set_pte_ext(pte, pfn_pte(pfn, type-&amp;gt;prot_pte), 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7B49;&#x6548;&#x4E8E;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cpu_arm926_set_pte_ext(pte, pfn_pte(pfn, type-&amp;gt;prot_pte), 0);
#define pfn_pte(pfn,prot)    (__pte(((pfn) &amp;lt;&amp;lt; PAGE_SHIFT) | pgprot_val(prot)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpu_arm926_set_pte_ext&#x5C06;&#x4E3B;&#x8981;&#x5DE5;&#x4F5C;&#x4EA4;&#x7ED9; armv3_set_pte_ext, &#x8FD9;&#x91CC;&#x5E76;&#x6CA1;&#x6709;&#x5224;&#x65AD; L_PTE_MT_DEV_SHARED &#x6216;&#x8005; L_PTE_SHARED, &#x6240;&#x4EE5;, &#x5BF9;&#x4E8E;&#x786C;&#x4EF6;&#x9875;&#x8868;, &#x6DFB;&#x52A0;&#x4E0A;&#x4E5F;&#x6CA1;&#x6709;&#x5F71;&#x54CD;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;2.2 .prot_sect &#x7528;&#x9014;&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;alloc_init_section
{
pmd_t *pmd = pmd_offset(pgd, addr);
...&#x5982;&#x679C; &#x521B;&#x5EFA;&#x7684;&#x662F; section.
*pmd = phys | type-&amp;gt;prot_sect;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, .prot_sect &#x7528;&#x6765;&#x5199;&#x5230;&#x7269;&#x7406;&#x9875;&#x8868;&#x53BB;&#x7684;, &#x4E0D;&#x50CF;&#x4E8C;&#x7EA7;&#x9875;&#x8868;, &#x8FD9;&#x91CC;linux&#x4E0D;&#x9700;&#x8981;&#x8F6C;&#x6362;&#x5565;&#x7684;.&lt;/p&gt;

&lt;p&gt;MT_DEVICE&#x7684; .prot_sect = PROT_SECT_DEVICE | PMD_SECT_S,&lt;/p&gt;

&lt;p&gt;&#x7B49;&#x6548;&#x4E8E; PMD_TYPE_SECT|PMD_SECT_AP_WRITE | PMD_SECT_S MT_UNCACHED&#x7684;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.prot_sect = PMD_TYPE_SECT | PMD_SECT_XN,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;build_mem_type_table()&#x4E2D;&#x4F1A;&#x6839;&#x636E;arm&#x7248;&#x672C;, &#x5BF9; .prot_sect &#x8FDB;&#x884C;&#x4FEE;&#x6B63;, &#x6BD4;&#x5982;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build_mem_type_table
{
    if (cpu_arch &amp;lt; CPU_ARCH_ARMv6 ...)
        mem_types[i].prot_sect &amp;amp;= ~PMD_SECT_S;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x5C31;&#x4E0D;&#x8D70;&#x8BFB;&#x4EE3;&#x7801;&#x4E86;, &#x76F4;&#x63A5;&#x6253;&#x5370;&#x7ED3;&#x679C;.&lt;/p&gt;

&lt;p&gt;&#x5F80;build_mem_type_table()&#x4E2D;&#x6DFB;&#x52A0;&#x6253;&#x5370;&#x540E;(&#x672A;&#x6DFB;&#x52A0;&#x4E0A;domain), &#x6709;&lt;/p&gt;

&lt;p&gt;MT_DEVICE &#x7684; .prot_sect &#x4E3A; 0x412&lt;/p&gt;

&lt;p&gt;MT_UNCACHED&#x7684; .prot_sect &#x4E3A; 0x12&lt;/p&gt;

&lt;p&gt;C(D3)&#x548C;B(D2) &#x90FD;&#x662F;&#x5173;&#x95ED;&#x7684;.&lt;/p&gt;

&lt;p&gt;&#x4E5F;&#x5C31;&#x662F;&#x591A;&#x4E86;&#x4E2A; PMD_SECT_AP_WRITE&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PMD_SECT_AP_WRITE (1 &amp;lt;&amp;lt; 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5148;&#x68C0;&#x67E5;domain, &#x5982;&#x679C;&#x4E3A;01(Client), &#x5219;&#x63A5;&#x7740;&#x68C0;&#x67E5;AP bits.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/ARM_access_permission.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x5982;&#x679C;&#x521B;&#x5EFA;&#x7684;&#x662F;section&#x7684;&#x8BDD;, &#x7C7B;&#x578B;MT_UNCACHED, &#x6700;&#x591A;&#x53EA;&#x80FD;&#x591F; read-only, &#x4E0D;&#x7B26;&#x5408;&#x8981;&#x6C42;, &#x6545;&#x4E0D;&#x4F7F;&#x7528;.&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;3. &#x865A;&#x62DF;&#x5730;&#x5740;&#x6307;&#x5B9A;&#x6210;&#x5565;&#x597D;&#x5462;?&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;create_mapping
{
    if ((md-&amp;gt;type == MT_DEVICE || md-&amp;gt;type == MT_ROM) &amp;amp;&amp;amp;
        md-&amp;gt;virtual &amp;gt;= PAGE_OFFSET &amp;amp;&amp;amp; md-&amp;gt;virtual &amp;lt; VMALLOC_END) {
        printk(KERN_WARNING &amp;quot;BUG: mapping for 0x%08llx at 0x%08lx &amp;quot;
               &amp;quot;overlaps vmalloc space\n&amp;quot;,
               __pfn_to_phys((u64)md-&amp;gt;pfn), md-&amp;gt;virtual);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5982;&#x679C;&#x662F;MT_DEVICE, &#x90A3;&#x4E48;, &#x4E0D;&#x592A;&#x5EFA;&#x8BAE;&#x6620;&#x5C04;(&#x4E0D;&#x662F;&#x7981;&#x6B62;, &#x56E0;&#x4E3A;&#x53EA;&#x662F;&#x6253;&#x5370;&#x4E86;warning&#x800C;&#x5DF2;)&#x5230; 3G~VMALLOC_END &#x4E4B;&#x95F4;. &#x5EFA;&#x8BAE;&#x6211;&#x4EEC;&#x6620;&#x5C04;&#x5230;vmalloc&#x4E0E;DMA&#x4E4B;&#x95F4;&#x7684;gap&#x5185; (vmalloc&#x548C;DMA&#x95F4;&#x7684;gap&#x53EF;&#x4E0D;&#x662F;8MB).&lt;/p&gt;

&lt;p&gt;&#x770B;&#x4E0B;versatile&#x7684;&#x6620;&#x5C04;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;. linux-2.6.35.7/arch/arm/mach-versatile/core.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static struct map_desc versatile_io_desc[] __initdata = {
    {
        .virtual    =  IO_ADDRESS(VERSATILE_SYS_BASE),
        .pfn        = __phys_to_pfn(VERSATILE_SYS_BASE),
        .length        = SZ_4K,
        .type        = MT_DEVICE
    },

#define VERSATILE_SYS_BASE   0x1000 0000
#define IO_ADDRESS(x)  (((x) &amp;amp; 0x0fff ffff) 
                       + (((x) &amp;gt;&amp;gt; 4) &amp;amp; 0x0f00 0000) 
                       + 0xf000 0000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x8BA1;&#x7B97;&#x51FA;&#x6765;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x4E3A; 0xf100 0000.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Virtual kernel memory layout:
...
    DMA     : 0xffc00000 - 0xffe00000   (   2 MB)
    vmalloc : 0xc8800000 - 0xd8000000   ( 248 MB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6B63;&#x662F;&#x5904;&#x4E8E;vmalloc&#x4E0E;DMA&#x4E4B;&#x95F4;&#x7684;gap&#x5185;. &lt;/p&gt;
</description>
    </item>
  </channel>
</rss>
