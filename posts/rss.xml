<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>HOMEPAGE</title>
    <description>HOMEPAGE</description>
    <link>https://awakening-fong.github.io</link>
    <pubDate>2017-05-14</pubDate>
    <item>
      <title>&#x4E3A;&#x4F55;&#x4E2D;&#x65AD;handler&#x4E2D;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;current</title>
      <link>https://awakening-fong.github.io/posts/arm/current_in_interrupt_handler</link>
      <pubDate>2017-05-13</pubDate>
      <description>&lt;p&gt;&#x672C;&#x535A;&#x6587;&#x4EC5;&#x63D0;&#x51FA;&#x95EE;&#x9898;, &#x4E0D;&#x7ED9;&#x51FA;&#x7B54;&#x6848;. &#x795D;&#x73A9;&#x7684;&#x5F00;&#x5FC3;.   &lt;/p&gt;

&lt;p&gt;&#x95EE;&#x9898;: &#x6211;&#x4EEC;&#x77E5;&#x9053; &#x5F53;&#x524D;task&#x53EF;&#x4EE5;&#x901A;&#x8FC7;current&#x6765;&#x83B7;&#x5F97;. ARM&#x4E0A;, &#x5176;&#x5B9E;&#x73B0;&#x5982;&#x4E0B;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define current (get_current()) 
#define get_current() (current_thread_info()-&amp;gt;task)
static inline struct thread_info *current_thread_info(void)
{
    register unsigned long sp asm (&amp;quot;sp&amp;quot;);
    return (struct thread_info *)(sp &amp;amp; ~(THREAD_SIZE - 1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5BF9;&#x4E8E;ARM, &#x5176;sp&#x662F;banked&#x7684;, irq&#x6A21;&#x5F0F;&#x548C;SVC&#x6A21;&#x5F0F;&#x7684;sp&#x4E0D;&#x662F;&#x540C;&#x4E00;&#x4E2A;. &#x8FD9;&#x6837;, &#x4E2D;&#x65AD;handler&#x8FD8;&#x80FD;&#x901A;&#x8FC7;sp&#x6765;&#x83B7;&#x5F97;&#x5F53;&#x524D;task&#x5417;?&lt;/p&gt;

&lt;p&gt;&#x4EE5;&#x4E0B;&#x5185;&#x5BB9;&#x662F;&#x672C;&#x95EE;&#x9898;&#x7684;&#x63D0;&#x793A;.&lt;br&gt;
&#x4E3A;&#x4E86;&#x907F;&#x514D;&#x5E72;&#x6270;&#x5404;&#x4F4D;&#x601D;&#x8003;, &#x5DF2;&#x8BBE;&#x7F6E;&#x80CC;&#x666F;&#x8272;&#x4E3A;&#x9ED1;&#x8272;, &#x82E5;&#x8981;&#x67E5;&#x770B;&#x6587;&#x5B57;, &#x53EF;&#x901A;&#x8FC7;&#x6309;ctrl+a&#x7B49;&#x65B9;&#x6CD5;&#x67E5;&#x770B;.  &lt;/p&gt;

&lt;p style="background-color: rgb(0, 0, 0);"&gt;&#x4E2D;&#x65AD;handler&#x5728;SVC&#x6A21;&#x5F0F;&#x4E0B;&#x6267;&#x884C;&#x7684;.
&lt;/p&gt;
</description>
    </item>
    <item>
      <title>&#x4FE1;&#x53F7;</title>
      <link>https://awakening-fong.github.io/posts/other/signal</link>
      <pubDate>2017-02-26</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x53D1;&#x9001;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4EE5;tkill&#x4E3A;&#x4F8B;&#x6765;&#x8BF4;&#x660E;.
linux-3.10.86/kernel/signal.c
&#x5047;&#x5B9A;&#x4E0D;&#x662F;&#x53D1;&#x9001;&#x7ED9;&#x7EC4;&#x7684;, &#x5373;__send_signal()&#x7684;@group&#x4E3A;0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_tkill -&amp;gt; do_send_specific
|--find_task_by_vpid
|--check_kill_permission
|--do_send_sig_info -&amp;gt; send_signal
|   |--__send_signal


__send_signal
|--q=__sigqueue_alloc //new sigqueue instance
|--list_add_tail(&amp;amp;q-&amp;gt;list, &amp;amp;pending-&amp;gt;list);
|--&#x8BBE;&#x7F6E;q-&amp;gt;info&#x7684;&#x5404;&#x57DF;
|   |--q-&amp;gt;info.si_signo =
|   |--q-&amp;gt;info.si_pid =
|--complete_signal
|   |--signal_wake_up -&amp;gt; signal_wake_up_state
|   |   |--set_tsk_thread_flag(t, TIF_SIGPENDING);
|   |   |--wake_up_state(, |TASK_INTERRUPTIBLE) -&amp;gt; try_to_wake_up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x53D1;&#x9001;&#x4FE1;&#x53F7;&#x662F;&#x5C06;&#x4FE1;&#x53F7;&#x7684;&#x4FE1;&#x606F;&#x653E;&#x5165;&#x8FDB;&#x7A0B;&#x7684;&#x67D0;&#x94FE;&#x8868;&#x4E2D;, &#x5E76;&#x5728;thread info&#x4E2D;&#x7F6E;&#x4F4D;TIF_SIGPENDING.&lt;/p&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x4EC5;&#x5524;&#x9192;&#x5904;&#x4E8E;TASK_INTERRUPTIBLE&#x72B6;&#x6001;&#x7684;&#x8FDB;&#x7A0B;, 
&#x4E0D;&#x53BB;&#x5524;&#x9192;TASK_UNINTERRUPTIBLE&#x72B6;&#x6001;&#x7684;&#x8FDB;&#x7A0B;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x68C0;&#x6D4B;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;[Professional Linux Kernel Architecture] p388&lt;br&gt;
Signal queue processing is initiated by the kernel each time a switch is made from kernel mode to user mode.&lt;/p&gt;

&lt;p&gt;&#x5404;&#x4F53;&#x7CFB;&#x5B9E;&#x73B0;&#x4E0A;&#x4E0D;&#x4E00;&#x6837;, &#x4F46;&#x6700;&#x540E;&#x90FD;&#x662F;&#x8C03;&#x7528;&#x5230; do_signal.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/arch/arm/kernel/signal.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_work_pending 
{
    if (thread_flags &amp;amp; _TIF_SIGPENDING) {
        do_signal
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:do_work_pending&#x662F;&#x5426;&#x4F1A;&#x88AB; __irq_usr &#x8C03;&#x7528;?&lt;br&gt;
&#x7B54;: &#x4F1A;.&lt;br&gt;
linux-3.10.86/arch/arm/kernel/entry-armv.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__irq_usr:
...
b   ret_to_user_from_irq

ENTRY(ret_to_user_from_irq)
...
bne work_pending

work_pending:
    ...
    bl  do_work_pending  @&#x5B9A;&#x4E49;&#x5728;signal.c
    ...
    movlt   scno, #(__NR_restart_syscall - __NR_SYSCALL_BASE)
    ldmia   sp, {r0 - r6}           @ have to reload r0 - r6
    b   local_restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FDB;&#x7A0B;&#x8FD0;&#x884C;&#x65F6;, &#x88AB;&#x786C;&#x4EF6;&#x4E2D;&#x65AD;, &#x4E2D;&#x65AD;&#x6267;&#x884C;&#x540E;, &#x4ECE;&#x5185;&#x6838;&#x8FD4;&#x56DE;&#x5230;&#x7528;&#x6237;&#x6001;, &#x4F1A;&#x68C0;&#x67E5;&#x662F;&#x5426;&#x6709;&#x4FE1;&#x53F7;&#x9700;&#x8981;&#x5904;&#x7406;.
&#x8FD9;&#x6837;, &#x8FDB;&#x7A0B;&#x5728;&#x7528;&#x6237;&#x6001;&#x7684;&#x4EE3;&#x7801;&#x5C31;&#x88AB;&#x4FE1;&#x53F7;handler&#x6253;&#x65AD;&#x4E86;. &#x6240;&#x4EE5;, [Understanding the Linux Kernel, 3rd Edition]&#x4E2D;&#x6709;
this means that the current process must first execute the signal handler in User Mode before being allowed to resume its &#x201C;normal&#x201D; execution.
&#x8FD9;&#x91CC;&#x7684;its &#x201C;normal&#x201D; execution &#x5C31;&#x662F;&#x6CA1;&#x6709;&#x4FE1;&#x53F7;&#x65F6;, &#x7A0B;&#x5E8F;&#x6240;&#x5728;&#x6267;&#x884C;&#x7684;&#x6D41;&#x7A0B;.&lt;/p&gt;

&lt;h2 id="toc_2"&gt;&lt;h4&gt;2.1 &#x5185;&#x6838;&#x7EBF;&#x7A0B;&#x5BF9;&#x4FE1;&#x53F7;&#x7684;&#x68C0;&#x6D4B;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x7531;&#x4E8E;&#x662F;&#x5185;&#x6838;&#x7EBF;&#x7A0B;, &#x6240;&#x4EE5;, &#x5E76;&#x4E0D;&#x5B58;&#x5728;&#x8FD4;&#x56DE;&#x7528;&#x6237;&#x6001;&#x7684;&#x4E8B;&#x60C5;, &#x6240;&#x4EE5;, &#x4E0D;&#x4F1A;&#x7406;&#x4F1A;kill&#x53D1;&#x9001;&#x7684;&#x4FE1;&#x53F7;.
&#x5982;&#x679C;&#x5185;&#x6838;&#x7EBF;&#x7A0B;&#x9700;&#x8981;&#x54CD;&#x5E94;&#x4FE1;&#x53F7;&#xFF0C;&#x53EF;&#x4EE5;&#x6DFB;&#x52A0;&#x4EE3;&#x7801;&#xFF1A;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (signal_pending(current))
{
    // &#x81EA;&#x5B9A;&#x4E49;&#x4FE1;&#x53F7;&#x5904;&#x7406;&#x51FD;&#x6570;
}
flush_signals(current);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;3. &#x6267;&#x884C;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4FE1;&#x53F7;&#x7684;handler&#x662F;&#x5728;&#x7528;&#x6237;&#x6001;&#x6267;&#x884C;&#x7684;,  &#x9700;&#x8981;manipulates the user mode stack of the process &#x7684;&#x90A3;&#x4E9B;&#x9EBB;&#x70E6;&#x4E8B;.&lt;br&gt;
&#x8FD9;&#x90E8;&#x5206;&#x5185;&#x5BB9;&#x672C;&#x6587;&#x672A;&#x5B8C;&#x6210;, &#x4EC5;&#x5199;&#x4E86;&#x4E00;&#x90E8;&#x5206;, &#x4EE5;&#x4E0B;&#x5185;&#x5BB9;&#x5C31;&#x662F;&#x4E86;.&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;sandbox (&#x4EE5;&#x4E0B;&#x5185;&#x5BB9;&#x5F85;&#x6574;&#x7406;)&lt;/h4&gt;&lt;/h1&gt;

&lt;h1 id="toc_5"&gt;&lt;h4&gt;3.1 &#x6C47;&#x7F16;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/arch/arm/kernel/entry-common.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;work_pending:
    mov r0, sp              @ &amp;#39;regs&amp;#39;
    mov r2, why             @ &amp;#39;syscall&amp;#39;
    @r1&#x662F;? &#x7B54;:see ENTRY(ret_to_user_from_irq)
    @r1&#x662F;struct thread_info&#x7684;&#x57DF;unsigned long     flags
    bl  do_work_pending  @&#x5B9A;&#x4E49;&#x5728;signal.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/kernel/entry-header.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tbl .req    r8      @ syscall table pointer
/*
&#x5982;&#x679C;&#x662F;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;, &#x5219;r8&#x975E;0, &#x662F;&#x8FD9;&#x4E2A;&#x610F;&#x601D;&#x5417;?
&#x56E0;&#x4E3A;&#x5982;&#x679C;&#x662F;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;, &#x5219;&#x4F1A;&#x7ED9;&#x51FA;syscall table pointer (&#x5C31;&#x662F;&#x4E0A;&#x9762;&#x7684;tbl  .req    r8), 
&#x6240;&#x4EE5;, &#x4E24;&#x8005;&#x662F;&#x5171;&#x7528;r8&#x7684;.
*/
/*
&#x95EE;&#x9898;:&#x5728;&#x90A3;&#x4E2A;&#x5730;&#x65B9;&#x7ED9;r8&#x8D4B;&#x503C;&#x7684;? 
&#x7B54;:linux-3.10.86/arch/arm/kernel/entry-common.S
    ENTRY(vector_swi)
    ...
    adr tbl, sys_call_table     @ load syscall table pointer
*/
why .req    r8      @ Linux syscall (!= 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/kernel/signal.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asmlinkage int
do_work_pending(struct pt_regs *regs, unsigned int thread_flags, int syscall)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3&#x4E2A;&#x53C2;&#x6570;&#x8DDF;&#x4E0A;&#x9762;&#x7684;&#x6CE8;&#x91CA;&#x543B;&#x5408;.
&#x8FD9;&#x91CC;@syscall&#x8868;&#x793A;&#x662F;&#x5426;&#x662F;&#x56E0;&#x4E3A;&#x7CFB;&#x7EDF;&#x8C03;&#x7528;&#x800C;&#x9677;&#x5165;&#x5185;&#x6838;&#x7684;.&lt;/p&gt;

&lt;h1 id="toc_6"&gt;&lt;h4&gt;3.2 stack&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;do_work_pending&#x7684;&#x76F8;&#x5173;&#x53C2;&#x6570;&#x4F20;&#x9012;&#x7ED9;&#x4E86; do_signal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int do_signal(struct pt_regs *regs, int syscall)
{
    ...
    if (get_signal(&amp;amp;ksig)) { //&#x586B;&#x5145;ksig
        handle_signal(&amp;amp;ksig, regs);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&#x4FEE;&#x6539;pt_regs&#x7684;pc, &#x8FD9;&#x6837;&#x540E;&#x7EED;&#x8BA9;&#x4FE1;&#x53F7;handler&#x8FD0;&#x884C;, &#x800C;&#x4E0D;&#x662F; the normal program code.
&#x5728;&#x6B64;&#x4E4B;&#x524D;, &#x8981;&#x5907;&#x4EFD;pt_regs.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;setup_rt_frame&#x548C;setup_frame&#x7684;&#x533A;&#x522B;???  &#x5148;&#x4E0D;&#x7BA1;, &#x770B;setup_frame.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handle_signal
|--setup_frame
|   |--struct sigframe __user *frame = get_sigframe(ksig, regs, sizeof(*frame));
|   |   |--&#x53EF;&#x7B80;&#x5316;&#x7406;&#x89E3;&#x4E3A; return regs-&amp;gt;ARM_sp
|   |--setup_sigframe(struct sigframe __user *sf, struct pt_regs *regs, sigset_t *set)
|   |   |--//&#x4EE5;&#x4E0B; &#x5907;&#x4EFD;pt_regs&#x5230; __user&#x7684;&#x67D0;&#x5904;
|   |   |--__put_user_error(regs-&amp;gt;ARM_r0, &amp;amp;sf-&amp;gt;uc.uc_mcontext.arm_r0, ...);
|   |   |--__put_user_error(regs-&amp;gt;ARM_r1, &amp;amp;sf-&amp;gt;uc.uc_mcontext.arm_r1, err);
|   |   |--....
|   |   |--__put_user_error(regs-&amp;gt;ARM_pc, &amp;amp;sf-&amp;gt;uc.uc_mcontext.arm_pc, err);
|   |   |--__put_user_error(regs-&amp;gt;ARM_cpsr, &amp;amp;sf-&amp;gt;uc.uc_mcontext.arm_cpsr, err);
|   |--setup_return
|   |   |--unsigned long handler = (unsigned long)ksig-&amp;gt;ka.sa.sa_handler;
|   |   |--regs-&amp;gt;ARM_sp = (unsigned long)frame;
|   |   |--regs-&amp;gt;ARM_pc = handler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7B97;&#x4E86;, &#x5148;&#x4E0D;&#x770B;&#x4E86;.   &lt;/p&gt;
</description>
    </item>
    <item>
      <title>fixup_exception</title>
      <link>https://awakening-fong.github.io/posts/mm/fixup_exception</link>
      <pubDate>2017-02-25</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4EC0;&#x4E48;&#x60C5;&#x51B5;&#x4E0B;&#x4F1A;&#x8C03;&#x7528;fixup_exception&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/arch/arm/mm/fault.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int __kprobes
do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
{

    if (!user_mode(regs))
        goto no_context;


no_context:
    __do_kernel_fault(mm, addr, fsr, regs);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;,  &#x7528;&#x6237;&#x6001;(user_mode(regs))&#x53D1;&#x8D77;&#x7684; &#x8BFB;&#x6216;&#x5199; , 
copy to/from user&#x7B49;*&#x4E0D;&#x4F1A;*&#x8C03;&#x7528;&#x5230; __do_kernel_fault, &#x4E5F;&#x5C31;&#x4E0D;&#x4F1A;&#x8C03;&#x7528;fixup_exception&#x7684;.
(fixup_exception &#x4EC5;&#x4F1A;&#x88AB; __do_kernel_fault&#x8C03;&#x7528;.)&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. get_user &#x548C; __ex_table&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/uaccess.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define __get_user_asm_byte(x,addr,err)             \
    __asm__ __volatile__(                   \
    &amp;quot;1: &amp;quot; TUSER(ldrb) &amp;quot; %1,[%2],#0\n&amp;quot;           \
    &amp;quot;2:\n&amp;quot;                          \
    &amp;quot;   .pushsection .fixup,\&amp;quot;ax\&amp;quot;\n&amp;quot;           \
    &amp;quot;   .align  2\n&amp;quot;                    \
    &amp;quot;3: mov %0, %3\n&amp;quot;               \
    &amp;quot;   mov %1, #0\n&amp;quot;               \
    &amp;quot;   b   2b\n&amp;quot;                   \
    &amp;quot;   .popsection\n&amp;quot;                  \
    &amp;quot;   .pushsection __ex_table,\&amp;quot;a\&amp;quot;\n&amp;quot;        \
    &amp;quot;   .align  3\n&amp;quot;                    \
    &amp;quot;   .long   1b, 3b\n&amp;quot;               \
    &amp;quot;   .popsection&amp;quot;                    \
    : &amp;quot;+r&amp;quot; (err), &amp;quot;=&amp;amp;r&amp;quot; (x)                 \
    : &amp;quot;r&amp;quot; (addr), &amp;quot;i&amp;quot; (-EFAULT)             \
    : &amp;quot;cc&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5728; __ex_table section&#x4E2D;&#x5B9A;&#x4E49;&#x4E86;&#x5982;&#x4E0B;&#x6570;&#x636E;:
.long   1b, 3b&lt;br&gt;
3b&#x662F; 1b&#x5904;&#x7684;&#x4FEE;&#x590D;&#x6307;&#x4EE4;&lt;br&gt;
&#x5F53;1b&#x5904;&#x53D1;&#x751F;&#x5F02;&#x5E38;&#x65F6;, &#x7CFB;&#x7EDF;&#x6839;&#x636E;&#x60C5;&#x51B5;, &#x4F1A;&#x8DF3;&#x8F6C;&#x5230;&#x6807;&#x53F7;3&#x7684;&#x6307;&#x4EE4;&#x5904;&#x7EE7;&#x7EED;&#x6267;&#x884C;.&lt;br&gt;
&#x4E0A;&#x9762;&#x7684;&#x4F8B;&#x5B50;, &#x5C06;&#x51FD;&#x6570;&#x8FD4;&#x56DE;&#x503C;&#x8BBE;&#x7F6E;&#x4E3A;-EFAULT, get&#x5230;&#x7684;&#x503C;&#x8BBE;&#x7F6E;&#x4E3A;0.&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. fixup_exception&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/include/asm-generic/vmlinux.lds.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 * Exception table
 */
#define EXCEPTION_TABLE(align)                      \
    . = ALIGN(align);                       \
    __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {       \
        VMLINUX_SYMBOL(__start___ex_table) = .;         \
        *(__ex_table)                       \
        VMLINUX_SYMBOL(__stop___ex_table) = .;          \
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/mm/fault.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__do_kernel_fault(struct mm_struct *mm, unsigned long addr, unsigned int fsr,
          struct pt_regs *regs)
{
    /*
     * Are we prepared to handle this kernel fault?
     */
    if (fixup_exception(regs))
        return;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/mm/extable.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int fixup_exception(struct pt_regs *regs)
{
    const struct exception_table_entry *fixup;
    fixup = search_exception_tables(instruction_pointer(regs));
    if (fixup) {
        regs-&amp;gt;ARM_pc = fixup-&amp;gt;fixup;
        ...
    }

    return fixup != NULL;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x4FEE;&#x6539;&#x4E86;pt_regs&#x7684;pc&#x503C;, &#x540E;&#x7EED;&#x5C06;pt_regs&#x8FD8;&#x539F;, &#x4E5F;&#x5C31;&#x662F;&#x4FEE;&#x6539;&#x4E86;&#x7A0B;&#x5E8F;&#x7684;&#x6267;&#x884C;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. &#x4F8B;&lt;/h4&gt;&lt;/h1&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;4.1 &#x65AD;&#x70B9;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x4E0B;&#x65AD;&#x70B9;, &#x770B;&#x770B; &#x53D1;&#x751F;fixup_exception&#x7684;&#x4E0A;&#x4E0B;&#x6587;.
&#x6211;&#x4EEC;&#x9700;&#x8981;&#x4EC5;&#x5728;fixup_exception()&#x4E2D;if (fixup) &#x6210;&#x7ACB;&#x65F6;&#x7684;&#x65AD;&#x70B9;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) disass fixup_exception
Dump of assembler code for function fixup_exception:
   0xc001cf40 &amp;lt;+0&amp;gt;: mov r12, sp
   0xc001cf44 &amp;lt;+4&amp;gt;: push    {r3, r4, r11, r12, lr, pc}
   0xc001cf48 &amp;lt;+8&amp;gt;: sub r11, r12, #4
   0xc001cf4c &amp;lt;+12&amp;gt;:    push    {lr}        ; (str lr, [sp, #-4]!)
   0xc001cf50 &amp;lt;+16&amp;gt;:    bl  0xc000efa8 &amp;lt;__gnu_mcount_nc&amp;gt;
=&amp;gt; 0xc001cf54 &amp;lt;+20&amp;gt;:    mov r4, r0
   0xc001cf58 &amp;lt;+24&amp;gt;:    ldr r0, [r0, #60]   ; 0x3c
   0xc001cf5c &amp;lt;+28&amp;gt;:    bl  0xc00475c4 &amp;lt;search_exception_tables&amp;gt;
   0xc001cf60 &amp;lt;+32&amp;gt;:    cmp r0, #0
   0xc001cf64 &amp;lt;+36&amp;gt;:    ldrne   r3, [r0, #4] ;&#x8FD9;&#x4E2A;&#x504F;&#x79FB;&#x91CF;4, &#x6307;&#x5411;&#x4E86;fixup, &#x5BF9;&#x5E94;&#x4EE3;&#x7801;fixup-&amp;gt;fixup
   0xc001cf68 &amp;lt;+40&amp;gt;:    strne   r3, [r4, #60]   ; 0x3c
   0xc001cf6c &amp;lt;+44&amp;gt;:    subs    r0, r0, #0
   0xc001cf70 &amp;lt;+48&amp;gt;:    movne   r0, #1  ; fixup != NULL
   0xc001cf74 &amp;lt;+52&amp;gt;:    ldm sp, {r3, r4, r11, sp, pc}
End of assembler dump

(gdb) bt
#0  0xc001cf70 in fixup_exception (regs=0xc05706e8)
    at arch/arm/mm/extable.c:21
#1  0xc001d1a8 in __do_kernel_fault (mm=0x0, addr=0, fsr=5, 
    regs=0xc7827e78) at arch/arm/mm/fault.c:138
#2  0xc001d3d0 in do_page_fault (addr=0, fsr=5, regs=0xc7827e78)
    at arch/arm/mm/fault.c:393
#3  0xc001d6e4 in do_translation_fault (addr=&amp;lt;value optimized out&amp;gt;, 
    fsr=5, regs=&amp;lt;value optimized out&amp;gt;) at arch/arm/mm/fault.c:432
#4  0xc0008474 in do_DataAbort (addr=0, fsr=3226928864, 
    regs=0xc7827e78) at arch/arm/mm/fault.c:549
#5  0xc000e9d8 in __dabt_svc () at arch/arm/kernel/entry-armv.S:194
---Type &amp;lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit--- 
Backtrace stopped: frame did not save the PC



0xc001cf64 &amp;lt;+36&amp;gt;:   ldrne   r3, [r0, #4]
0xc001cf68 &amp;lt;+40&amp;gt;:   strne   r3, [r4, #60]   ; 0x3c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x65AD;&#x70B9;&#x5E94;&#x8BE5;&#x8BBE;&#x7F6E;&#x5728;  strne    r3, [r4, #60] ; regs-&amp;gt;ARM_pc = fixup-&amp;gt;fixup
&#x8FD9;&#x6837;&#x624D;&#x80FD;&#x901A;&#x8FC7;pt_regs&#x77E5;&#x9053;&#x5F02;&#x5E38;&#x53D1;&#x751F;&#x524D; &#x53D1;&#x751F;&#x4E86;&#x4EC0;&#x4E48;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b *0xc001cf68
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_5"&gt;&lt;h4&gt;4.2 &#x5F02;&#x5E38;&#x53D1;&#x751F;&#x524D;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;b *0xc001cf68 &#x505C;&#x4E0B;&#x6765;&#x540E;, &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) disass $pc
Dump of assembler code for function fixup_exception:
   0xc001cf40 &amp;lt;+0&amp;gt;: mov r12, sp
   0xc001cf44 &amp;lt;+4&amp;gt;: push    {r3, r4, r11, r12, lr, pc}
   0xc001cf48 &amp;lt;+8&amp;gt;: sub r11, r12, #4
   0xc001cf4c &amp;lt;+12&amp;gt;:    push    {lr}        ; (str lr, [sp, #-4]!)
   0xc001cf50 &amp;lt;+16&amp;gt;:    bl  0xc000efa8 &amp;lt;__gnu_mcount_nc&amp;gt;
   0xc001cf54 &amp;lt;+20&amp;gt;:    mov r4, r0
   0xc001cf58 &amp;lt;+24&amp;gt;:    ldr r0, [r0, #60]   ; 0x3c
   0xc001cf5c &amp;lt;+28&amp;gt;:    bl  0xc00475c4 &amp;lt;search_exception_tables&amp;gt;
   0xc001cf60 &amp;lt;+32&amp;gt;:    cmp r0, #0
   0xc001cf64 &amp;lt;+36&amp;gt;:    ldrne   r3, [r0, #4]
=&amp;gt; 0xc001cf68 &amp;lt;+40&amp;gt;:    strne   r3, [r4, #60]   ; 0x3c
   0xc001cf6c &amp;lt;+44&amp;gt;:    subs    r0, r0, #0
   0xc001cf70 &amp;lt;+48&amp;gt;:    movne   r0, #1
   0xc001cf74 &amp;lt;+52&amp;gt;:    ldm sp, {r3, r4, r11, sp, pc}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;r3&#x5B58;&#x50A8;&#x7684;&#x662F; fixup&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p /x $r3
$14 = 0xc044a79c
(gdb) info symbol $r3
__idmap_text_end + 1724 in section .text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[r4, #60]&#x539F;&#x5148;&#x8981;&#x7EE7;&#x7EED;&#x6267;&#x884C;&#x7684;&#x4F4D;&#x7F6E;,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p /x $r4+60
$4 = 0xc7827eb4
(gdb) p /x  *0xc7827eb4
$5 = 0xc006e5dc  #&#x51FA;&#x9519;&#x6307;&#x4EE4;&#x662F;
(gdb) i sym 0xc006e5dc
cmpxchg_futex_value_locked + 80 in section .text

(gdb) i sym (*($r4+56))  # &#x539F;&#x672C;&#x8FD4;&#x56DE;
futex_init + 36 in section .init.text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x8C03;&#x7528;fixup_exception&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x662F;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;futex_init
|--futex_detect_cmpxchg
|   |--cmpxchg_futex_value_locked  //&#x8FD9;&#x91CC;&#x9762;&#x53D1;&#x751F;&#x5F02;&#x5E38;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_6"&gt;&lt;h4&gt;4.3 fixup &lt;/h4&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;(gdb) disass (*($r4+60))
Dump of assembler code for function cmpxchg_futex_value_locked:
   0xc006e58c &amp;lt;+0&amp;gt;: mov r12, sp
   0xc006e590 &amp;lt;+4&amp;gt;: push    {r3, r4, r5, r6, r11, r12, lr, pc}
   0xc006e594 &amp;lt;+8&amp;gt;: sub r11, r12, #4
   0xc006e598 &amp;lt;+12&amp;gt;:    push    {lr}        ; (str lr, [sp, #-4]!)
   0xc006e59c &amp;lt;+16&amp;gt;:    bl  0xc000efa8 &amp;lt;__gnu_mcount_nc&amp;gt;
   0xc006e5a0 &amp;lt;+20&amp;gt;:    mov r4, sp
   0xc006e5a4 &amp;lt;+24&amp;gt;:    bic r12, r4, #8128  ; 0x1fc0
   0xc006e5a8 &amp;lt;+28&amp;gt;:    bic r12, r12, #63   ; 0x3f
   0xc006e5ac &amp;lt;+32&amp;gt;:    ldr r5, [r12, #4]
   0xc006e5b0 &amp;lt;+36&amp;gt;:    add r4, r5, #1
   0xc006e5b4 &amp;lt;+40&amp;gt;:    str r4, [r12, #4]
   0xc006e5b8 &amp;lt;+44&amp;gt;:    ldr r4, [r12, #8]
   0xc006e5bc &amp;lt;+48&amp;gt;:    adds    r5, r1, #4
   0xc006e5c0 &amp;lt;+52&amp;gt;:    sbcscc  r5, r5, r4
   0xc006e5c4 &amp;lt;+56&amp;gt;:    movcc   r4, #0
   0xc006e5c8 &amp;lt;+60&amp;gt;:    cmp r4, #0
   0xc006e5cc &amp;lt;+64&amp;gt;:    mvnne   r4, #13  ;&#x6839;&#x636E;&#x8FD9;&#x91CC;&#x7684;13, &#x5927;&#x6982;&#x5BF9;&#x5E94;if !access_ok  return -EFAULT
   0xc006e5d0 &amp;lt;+68&amp;gt;:    bne 0xc006e5fc &amp;lt;cmpxchg_futex_value_locked+112&amp;gt;
   0xc006e5d4 &amp;lt;+72&amp;gt;:    dmb sy
   0xc006e5d8 &amp;lt;+76&amp;gt;:    mvn r5, #13   
   0xc006e5dc &amp;lt;+80&amp;gt;:    ldrex   r6, [r1] ;===&#x5F15;&#x53D1;&#x5F02;&#x5E38;===
   0xc006e5e0 &amp;lt;+84&amp;gt;:    teq r6, r2
   0xc006e5e4 &amp;lt;+88&amp;gt;:    strexeq r4, r3, [r1]
   0xc006e5e8 &amp;lt;+92&amp;gt;:    movne   r4, #0
   0xc006e5ec &amp;lt;+96&amp;gt;:    teq r4, #0
   0xc006e5f0 &amp;lt;+100&amp;gt;:   bne 0xc006e5dc &amp;lt;cmpxchg_futex_value_locked+80&amp;gt;
   0xc006e5f4 &amp;lt;+104&amp;gt;:   dmb sy
   0xc006e5f8 &amp;lt;+108&amp;gt;:   str r6, [r0]
   0xc006e5fc &amp;lt;+112&amp;gt;:   ldr r1, [r12, #4]  ;access_ok()&#x5931;&#x8D25;&#x540E;&#x5230;&#x8FD9;&#x91CC;
   0xc006e600 &amp;lt;+116&amp;gt;:   sub r0, r1, #1
   0xc006e604 &amp;lt;+120&amp;gt;:   str r0, [r12, #4]
   0xc006e608 &amp;lt;+124&amp;gt;:   ldr r3, [r12]
   0xc006e60c &amp;lt;+128&amp;gt;:   tst r3, #2
   0xc006e610 &amp;lt;+132&amp;gt;:   bne 0xc006e61c &amp;lt;cmpxchg_futex_value_locked+144&amp;gt;
   0xc006e614 &amp;lt;+136&amp;gt;:   mov r0, r4
   0xc006e618 &amp;lt;+140&amp;gt;:   ldm sp, {r3, r4, r5, r6, r11, sp, pc}
   0xc006e61c &amp;lt;+144&amp;gt;:   bl  0xc04488e8 &amp;lt;preempt_schedule&amp;gt;
   0xc006e620 &amp;lt;+148&amp;gt;:   b   0xc006e614 &amp;lt;cmpxchg_futex_value_locked+136&amp;gt;
---Type &amp;lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit---
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7EFC;&#x5408;&#x4E0A;&#x9762;&#x6765;&#x770B;, pt_regs&#x4E2D;&#x7684;pc&#x503C;&#x662F;&#x5DF2;&#x7ECF;&#x4FEE;&#x6B63;&#x8FC7;(&#x6839;&#x636E;&#x60C5;&#x51B5;-8 -4)&#x7684;&#x503C;&#x4E86;, &#x5BF9;&#x5417;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cmpxchg_futex_value_locked -&amp;gt; futex_atomic_cmpxchg_inatomic
{
...
: &amp;quot;=&amp;amp;r&amp;quot; (ret), &amp;quot;=&amp;amp;r&amp;quot; (val)
: &amp;quot;r&amp;quot; (oldval), &amp;quot;r&amp;quot; (newval), &amp;quot;r&amp;quot; (uaddr), &amp;quot;Ir&amp;quot; (-EFAULT)

}

#define EFAULT      14  /* Bad address */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x88AB;&#x7FFB;&#x8BD1;&#x4E3A;:  mvn  r5, #13  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ldrex   r6, [r1] ;&#x5F15;&#x53D1;&#x5F02;&#x5E38;

static inline int
futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,
                  u32 oldval, u32 newval)
{


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;r1&#x662F; u32 __user *uaddr&lt;/p&gt;

&lt;p&gt;fixup&#x4EE3;&#x7801;&#x662F;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xc044a79c &amp;lt;+1724&amp;gt;: mov r4, r5
0xc044a7a0 &amp;lt;+1728&amp;gt;: b   0xc006e5f4 &amp;lt;cmpxchg_futex_value_locked+104&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;r5&#x662F;-EFAULT, r4&#x662F;ret,&lt;br&gt;
&#x8BBE;&#x7F6E;&#x8FD4;&#x56DE;&#x503C;&#x4E3A;-EFAULT, &#x4E24; dmb  sy &#x4E4B;&#x95F4;&#x7684;&#x4EE3;&#x7801;&#x5C31;&#x4E0D;&#x6267;&#x884C;&#x4E86;. &lt;/p&gt;

&lt;h2 id="toc_7"&gt;&lt;h4&gt;4.4 &#x770B;&#x4E0B;__ex_table&#x7684;&#x8BBE;&#x7F6E;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/futex.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;futex_atomic_cmpxchg_inatomic
{
    ...
    smp_mb();
    __asm__ __volatile__(&amp;quot;@futex_atomic_cmpxchg_inatomic\n&amp;quot;
    &amp;quot;1: ldrex   %1, [%4]\n&amp;quot;
    &amp;quot;   teq %1, %2\n&amp;quot;
    &amp;quot;   ite eq  @ explicit IT needed for the 2b label\n&amp;quot;
    &amp;quot;2: strexeq %0, %3, [%4]\n&amp;quot;
    &amp;quot;   movne   %0, #0\n&amp;quot;
    &amp;quot;   teq %0, #0\n&amp;quot;
    &amp;quot;   bne 1b\n&amp;quot;
    __futex_atomic_ex_table(&amp;quot;%5&amp;quot;)
    : &amp;quot;=&amp;amp;r&amp;quot; (ret), &amp;quot;=&amp;amp;r&amp;quot; (val)
    : &amp;quot;r&amp;quot; (oldval), &amp;quot;r&amp;quot; (newval), &amp;quot;r&amp;quot; (uaddr), &amp;quot;Ir&amp;quot; (-EFAULT)
    : &amp;quot;cc&amp;quot;, &amp;quot;memory&amp;quot;);
    smp_mb();
...
}


#define __futex_atomic_ex_table(err_reg)            \
    &amp;quot;3:\n&amp;quot;                          \
    &amp;quot;   .pushsection __ex_table,\&amp;quot;a\&amp;quot;\n&amp;quot;        \
    &amp;quot;   .align  3\n&amp;quot;                    \
    &amp;quot;   .long   1b, 4f, 2b, 4f\n&amp;quot;           \
    &amp;quot;   .popsection\n&amp;quot;                  \
    &amp;quot;   .pushsection .fixup,\&amp;quot;ax\&amp;quot;\n&amp;quot;           \
    &amp;quot;   .align  2\n&amp;quot;                    \
    &amp;quot;4: mov %0, &amp;quot; err_reg &amp;quot;\n&amp;quot;          \
    &amp;quot;   b   3b\n&amp;quot;                   \
    &amp;quot;   .popsection&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;1b, 4f,&lt;br&gt;
1b&#x6307;&#x7684;&#x662F;1:   ldrex   %1, [%4], &#x4E5F;&#x5C31;&#x662F;&#x5F15;&#x53D1;&#x5F02;&#x5E38;&#x7684;ldrex r6, [r1].&lt;br&gt;
4f&#x662F;4: mov %0, %5  &#x548C;       b 3b&lt;br&gt;
&#x4E5F;&#x5C31;&#x662F;mov    r4, r5 &#x548C; b    0xc006e5f4 &lt;/p&gt;

&lt;h2 id="toc_8"&gt;&lt;h4&gt;4.5 &#x5C0F;&#x7ED3;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;linux-3.10.86/kernel/futex.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void __init futex_detect_cmpxchg(void)
{
#ifndef CONFIG_HAVE_FUTEX_CMPXCHG
    u32 curval;

    if (cmpxchg_futex_value_locked(&amp;amp;curval, NULL, 0, 0) == -EFAULT)
        futex_cmpxchg_enabled = 1;
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x8981;&#x5224;&#x65AD;cmpxchg_futex_value_locked&#x7684;&#x8FD4;&#x56DE;&#x503C;, &#x6B63;&#x597D;, fixup&#x4EE3;&#x7801;&#x5B8C;&#x6210;&#x4E86;&#x8FD9;&#x4EFB;&#x52A1;.
&#x5185;&#x6838;&#x8FD9;&#x6837;, &#x5B8C;&#x6210;&#x4E86;&#x4E00;&#x4E9B;&#x9700;&#x8981;detect&#x7684;&#x521D;&#x59CB;&#x5316;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>mmap&#x548C;fault handler</title>
      <link>https://awakening-fong.github.io/posts/mm/mmap_fault</link>
      <pubDate>2017-02-24</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x60F3;&#x77E5;&#x9053;, &#x901A;&#x8FC7;mmap&#x6620;&#x5C04;&#x6587;&#x4EF6;, &#x7136;&#x540E;&#x8BFB;&#x53D6;, &#x662F;&#x5982;&#x4F55;&#x8BFB;&#x53D6;&#x5230;&#x6587;&#x4EF6;&#x7684;, &#x5176;&#x4E2D;&#x7684;fault handler&#x76F8;&#x5173;&#x7684;&#x5185;&#x5BB9;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. ftrace&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code class="c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;strings.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;

#define MEMSIZE 1024*4
#define MPFILE &amp;quot;./.ash_history&amp;quot;

//#define ON_OFF //tracing_on

void write_ftrace(char *path, char *val)
{
    char ftrace_d[50]=&amp;quot;/sys/kernel/debug/tracing/&amp;quot;;
    int len_d=strlen(ftrace_d);


    int fd_trace=open(strcat(ftrace_d,path), O_RDWR|O_TRUNC);
    if (fd_trace &amp;lt; 0) {
        printf(&amp;quot;open %s:%s\n&amp;quot;,path,strerror(errno));
        exit(1);
    }

    printf(&amp;quot;to write:%s %s\n&amp;quot;,path,val);

    int ret=write(fd_trace, val, strlen(val));
    if(ret&amp;lt;0)
    {
        printf(&amp;quot;write %s %s\n&amp;quot;,path,strerror(errno));
        exit(1);
    }


    if (0==strncmp(&amp;quot;trace&amp;quot;,path, sizeof(&amp;quot;trace&amp;quot;)))
    {
        close(fd_trace);
        return;
    }

    char val_read[20];
    memset(val_read,0,sizeof(val_read));
    pread(fd_trace, val_read, sizeof(val_read),0);
    printf(&amp;quot;read val:%s\n&amp;quot;,val_read);
    close(fd_trace);

}

void write_val(char *path, char *val)
{
    int fd=open(path, O_RDWR);
    if (fd &amp;lt; 0) {
        printf(&amp;quot;open %s:%s\n&amp;quot;,path,strerror(errno));
        exit(1);
    }

    printf(&amp;quot;to write:%s %s\n&amp;quot;,path, val);
    int ret=write(fd, val, strlen(val));
    if(ret&amp;lt;0)
    {
        printf(&amp;quot;write %s %s\n&amp;quot;,path,strerror(errno));
        exit(1);
    }

    char val_read[20];
    memset(val_read,0,sizeof(val_read));
    pread(fd, val_read, sizeof(val_read),0);
    printf(&amp;quot;read val:%s\n&amp;quot;,val_read);
    close(fd);
}


int main()
{
    char *ptr;
    int fd;
    int ret=-1;
    int i=-1;

    fd = open(MPFILE, O_RDWR);
    if (fd &amp;lt; 0) {
        perror(&amp;quot;open()&amp;quot;);
        exit(1);
    }

    ptr = mmap(NULL, MEMSIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (ptr == NULL) {
        perror(&amp;quot;malloc()&amp;quot;);
        exit(1);
    }

    /*&#x907F;&#x514D;page cache&#x5E72;&#x6270;*/
    if( posix_fadvise(fd,0,4096,POSIX_FADV_DONTNEED) != 0) {  
        printf(&amp;quot;Cache FADV_DONTNEED failed, %s\n&amp;quot;,strerror(errno));  
    }  
    else {  
        printf(&amp;quot;Cache FADV_DONTNEED done\n&amp;quot;);  
    }  

    //mount -t debugfs nodev /sys/kernel/debug/
    system(&amp;quot;mount -t debugfs nodev /sys/kernel/debug/&amp;quot;);



    /*
    ~ # echo 1 &amp;gt; /proc/sys/kernel/ftrace_enabled
    */

    write_val(&amp;quot;/proc/sys/kernel/ftrace_enabled&amp;quot;, &amp;quot;1&amp;quot;);

    int pid_cur=getpid();
    printf(&amp;quot;pid:%d\n&amp;quot;,pid_cur);
    char str_pid[25];
    memset(str_pid,0, sizeof(str_pid));
    snprintf(str_pid, sizeof(str_pid),&amp;quot;%d&amp;quot;, pid_cur);
    //  /sys/kernel/debug/tracing/set_ftrace_pid
    write_ftrace(&amp;quot;set_ftrace_pid&amp;quot;, str_pid);


    write_ftrace(&amp;quot;tracing_on&amp;quot;, &amp;quot;1&amp;quot;);


    /*# can set other filtering here
    echo function &amp;gt; ${ROOT_FTRACE}/current_tracer
    */
    write_ftrace(&amp;quot;current_tracer&amp;quot;, &amp;quot;function&amp;quot;);

    write_ftrace(&amp;quot;trace&amp;quot;, &amp;quot;0&amp;quot;);

    /*
    #echo 0 &amp;gt; ${ROOT_FTRACE}/trace
    echo start_trace_marker &amp;gt; ${ROOT_FTRACE}/trace_marker
    exec $* 
    */

    //write_ftrace(&amp;quot;trace_marker&amp;quot;, &amp;quot;start_trace_marker&amp;quot;);

   i=*ptr;  //&#x8FD9;&#x4E2A;&#x5C31;&#x662F;&#x6211;&#x4EEC;&#x8981;&#x8DDF;&#x8E2A;&#x7684;


    /*
    echo end_trace_marker &amp;gt; ${ROOT_FTRACE}/trace_marker
    echo 0  &amp;gt; ${ROOT_FTRACE}/tracing_on  #stop record to buffer
    */

    //write_ftrace(&amp;quot;trace_marker&amp;quot;, &amp;quot;end_trace_marker&amp;quot;);

    write_ftrace(&amp;quot;tracing_on&amp;quot;, &amp;quot;0&amp;quot;);
    system(&amp;quot;cat /sys/kernel/debug/tracing/trace &amp;gt; mmap.ftrace&amp;quot;);

    printf(&amp;quot;%x\n&amp;quot;, i);


    munmap(ptr, MEMSIZE);
    close(fd);

    exit(1);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x7ED3;&#x679C;&#x5206;&#x6790;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;ARM&#x5E73;&#x53F0;, linux-3.10.86, ftrace&#x8F93;&#x51FA;&#x4E2D;&#x6709;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_DataAbort &amp;lt;-__dabt_usr
do_page_fault &amp;lt;-do_DataAbort
down_read_trylock &amp;lt;-do_page_fault
_raw_spin_lock_irqsave &amp;lt;-__down_read_trylock
_raw_spin_unlock_irqrestore &amp;lt;-__down_read_trylock
find_vma &amp;lt;-do_page_fault
handle_mm_fault &amp;lt;-do_page_fault
handle_pte_fault &amp;lt;-handle_mm_fault
__do_fault &amp;lt;-handle_pte_fault
filemap_fault &amp;lt;-__do_fault
find_get_page &amp;lt;-filemap_fault
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5206;&#x6790;: &#x7565;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>do_fork&#x548C;COW</title>
      <link>https://awakening-fong.github.io/posts/mm/do_fork_cow</link>
      <pubDate>2017-02-24</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6458;&#x81EA;APUE:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&#x7531;&#x4E8E;&#x5728;fork&#x4E4B;&#x540E;&#x8FDB;&#x7A0B;&#x8DDF;&#x968F;&#x7740;exec, &#x6240;&#x4EE5;&#x73B0;&#x5728;&#x7684;&#x5F88;&#x591A;&#x5B9E;&#x73B0;&#x5E76;&#x4E0D;&#x6267;&#x884C;&#x4E00;&#x4E2A;&#x7236;&#x8FDB;&#x7A0B;&#x6570;&#x636E;&#x6BB5;, &#x6808;&#x548C;&#x5806;&#x7684;&#x5B8C;&#x5168;&#x590D;&#x5236;. &#x4F5C;&#x4E3A;&#x66FF;&#x4EE3;, &#x4F7F;&#x7528;&#x4E86;COW&#x6280;&#x672F;. &#x8FD9;&#x4E9B;&#x533A;&#x57DF;&#x7531;&#x7236;&#x5B50;&#x8FDB;&#x7A0B;&#x5171;&#x4EAB;, &#x800C;&#x4E14;&#x5185;&#x6838;&#x5C06;&#x5B83;&#x4EEC;&#x7684;&#x8BBF;&#x95EE;&#x6743;&#x9650;&#x6539;&#x53D8;&#x4E3A;&#x53EA;&#x8BFB;&#x7684;. &#x5982;&#x679C;&#x7236;&#x5B50;&#x8FDB;&#x7A0B;&#x4E2D;&#x7684;&#x4EFB;&#x4E00;&#x4E2A;&#x8BD5;&#x56FE;&#x4FEE;&#x6539;&#x8FD9;&#x4E9B;&#x533A;&#x57DF;, &#x5219;&#x5185;&#x6838;&#x53EA;&#x4E3A;&#x4FEE;&#x6539;&#x533A;&#x57DF;&#x7684;&#x90A3;&#x5757;&#x5185;&#x5B58;&#x5236;&#x4F5C;&#x4E00;&#x4E2A;&#x526F;&#x672C;, &#x901A;&#x5E38;&#x662F;&#x865A;&#x62DF;&#x5B58;&#x50A8;&#x7CFB;&#x7EDF;&#x4E2D;&#x7684;&#x4E00;&amp;quot;&#x9875;&amp;quot;.  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x54EA;&#x91CC;&#x8BBE;&#x7F6E;&#x53EA;&#x8BFB;, &#x5982;&#x4F55;&#x77E5;&#x9053;&#x53EA;&#x8BFB;?&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x89E3;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5FEB;&#x901F;tips:&lt;br&gt;
PTE entry is marked as un-writeable.&lt;br&gt;
But VMA is marked as writeable.  &lt;/p&gt;

&lt;p&gt;copy_one_pte()&#x4F1A;&#x8C03;&#x7528; ptep_set_wrprotect()&lt;/p&gt;

&lt;p&gt;&#x8FD8;&#x662F;&#x5148;&#x4ECE;dup_mm()&#x5F00;&#x59CB;&#x770B;&#x5427;.&lt;br&gt;
linux-3.10.86/kernel/fork.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct mm_struct *dup_mm(struct task_struct *tsk)
{
    struct mm_struct *mm, *oldmm = current-&amp;gt;mm;
    mm = allocate_mm();
    memcpy(mm, oldmm, sizeof(*mm)); 

    mm_init(mm, tsk)); //&#x91CC;&#x9762;&#x6D89;&#x53CA;&#x9875;&#x8868;
    err = dup_mmap(mm, oldmm);

}

static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p)
|-- mm_alloc_pgd(mm)
|   |--mm-&amp;gt;pgd = pgd_alloc(mm); //&#x5206;&#x914D;&#x9875;&#x8868;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/mm/pgd.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pgd_alloc
{
    new_pgd = __pgd_alloc();
    memset(new_pgd, 0, USER_PTRS_PER_PGD * sizeof(pgd_t));  //&#x6E05;&#x7A7A;&#x9875;&#x8868;

    /*
     * Copy over the kernel and IO PGD entries  &#x62F7;&#x8D1D;&#x5185;&#x6838;&#x7684;&#x9875;&#x8868;, &#x4E14;&#x662F;first level&#x9875;&#x8868;
     */
    init_pgd = pgd_offset_k(0);  //&#x5185;&#x6838;&#x7684;&#x9875;&#x8868;
    memcpy(new_pgd + USER_PTRS_PER_PGD, init_pgd + USER_PTRS_PER_PGD,
               (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t)); 

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/kernel/fork.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
{
    struct vm_area_struct *mpnt;
    //&#x8FD9;&#x4E2A;&#x662F;&#x8FDB;&#x7A0B;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x533A;&#x57DF;, &#x975E;&#x5185;&#x6838;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x533A;&#x57DF;
    for (mpnt = oldmm-&amp;gt;mmap; mpnt; mpnt = mpnt-&amp;gt;vm_next) { 
        copy_page_range(mm, oldmm, mpnt);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x5C31;&#x662F;&#x6211;&#x4EEC;&#x8981;&#x5173;&#x6CE8;&#x7684;&#x90E8;&#x5206;&#x4E86;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;copy_page_range
|--copy_pud_range
|   |--copy_pmd_range
|   |   |--copy_pte_range
|   |   |   |--copy_one_pte

copy_one_pte
{
    /*
     * If it&amp;#39;s a COW mapping, write protect it both
     * in the parent and the child
     */
    if (is_cow_mapping(vm_flags)) {
        ptep_set_wrprotect(src_mm, addr, src_pte);
        pte = pte_wrprotect(pte);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x5185;&#x6838;&#x4E2D;&#x5E38;&#x89C1;&#x7684;&#x4F18;&#x5316;&#x65B9;&#x6CD5;</title>
      <link>https://awakening-fong.github.io/posts/other/optimize</link>
      <pubDate>2017-02-23</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x6279;&#x91CF;&#x5904;&#x7406;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;add_to_page_cache_lru,  &#x64CD;&#x4F5C;lru&#x7684;&#x8BDD;, &#x5148;&#x653E;&#x5230;per cpu&#x7684;lru cache (struct pagevec), &#x5F85;lru cache&#x5B58;&#x6EE1;&#x540E;drain.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x541E;&#x5410;&#x91CF;&#xFF08;Throughput&#xFF09;&#x548C;&#x65F6;&#x5EF6;&#xFF08;Latency&#xFF09;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;2.1   HZ &#x8BBE;&#x7F6E;&#x4E3A; 250, 1000&#x7B49;.&lt;/p&gt;

&lt;p&gt;2.2 
&#x4E2D;&#x65AD;&#x7EBF;&#x7A0B;&#x5316;&#x540E;, &#x541E;&#x5410;&#x91CF;&#x53EF;&#x80FD;&#x4E0B;&#x964D;, &#x4F46;&#x7CFB;&#x7EDF;&#x5176;&#x5B83;&#x5730;&#x65B9;&#x7684;&#x65F6;&#x5EF6;&#x53EF;&#x80FD;&#x6539;&#x5584;.&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x7528;&#x7A7A;&#x95F4;&#x6362;&#x65F6;&#x95F4;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x8BA1;&#x7B97;&#x7ED3;&#x679C;&#x7F13;&#x5B58;&#x4E4B;&#x7C7B;&#x7684;, &#x6BD4;&#x5982; &#x4E00;&#x4E9B;&#x6570;&#x503C;&#x8BA1;&#x7B97;, &#x5F00;&#x6839;&#x53F7;&#x4EC0;&#x4E48;&#x7684;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. &#x6536;&#x655B;?&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;radix tree&#x7684;tag, &#x4E0D;&#x5FC5;&#x9010;&#x4E2A;&#x5224;&#x65AD;&#x8BE5;&#x8282;&#x70B9; &#x5B50;&#x6811; &#x4E0B;&#x7684;&#x53F6;&#x5B50;. &#x8FD9;&#x4E2A;&#x53EF;&#x80FD;&#x4E5F;&#x53EF;&#x4EE5;&#x5F52;&#x5230;  &#x7F13;&#x5B58; &#x4E2D;.&lt;/p&gt;

&lt;p&gt;hash&#x5E94;&#x8BE5;&#x4E5F;&#x7B97;&#x8FD9;&#x4E2A;&#x7C7B;&#x522B;.&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;5. &#x7F13;&#x5B58;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;buddy system &#x4E00;&#x5F00;&#x59CB;&#x4ECE;zone&#x7684;&#x94FE;&#x8868;&#x4E2D;&#x5206;&#x914D;, &#x91CA;&#x653E;&#x65F6;&#x653E;&#x5230;per cpu&#x7684;pcp, &#x540E;&#x7EED;&#x4ECE;pcp&#x4E2D;&#x53D6;, &#x51CF;&#x5C11;&#x4E86;&#x9501;&#x7684;&#x95EE;&#x9898;.&lt;/p&gt;

&lt;h1 id="toc_5"&gt;&lt;h4&gt;6. &#x9501;&#x7684;&#x95EE;&#x9898;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;6.1 &#x4F7F;&#x7528;per cpu.
&#x6BD4;&#x5982; lru&#x95EE;&#x9898; per cpu&#x7684; pagevec.&lt;/p&gt;

&lt;p&gt;6.2&lt;br&gt;
1. lock&#x5168;&#x5C40;&#x7684;&#x94FE;&#x8868;,&lt;br&gt;
2. &#x4ECE;&#x5168;&#x5C40;&#x7684;&#x94FE;&#x8868;&#x4E2D;&#x6311;&#x9009;&#x653E;&#x5165;on a local list,&lt;br&gt;
3. unlock &#x5168;&#x5C40;&#x7684;&#x94FE;&#x8868;&lt;br&gt;
4. &#x5BF9; local list&#x8FDB;&#x884C;&#x76F8;&#x5BF9;&#x6BD4;&#x8F83;&#x8017;&#x65F6;&#x7684;&#x64CD;&#x4F5C;&lt;/p&gt;

&lt;p&gt;&#x8FD9;&#x4E2A;&#x6BD4;&#x8F83;&#x5E38;&#x89C1;, &#x6BD4;&#x5982; ...&lt;/p&gt;

&lt;p&gt;6.3 RCU&#x7684;&#x9002;&#x7528;&#x8303;&#x56F4;
...&lt;/p&gt;

&lt;p&gt;6.4 &#x628A;&#x76F8;&#x5173;&#x4FE1;&#x606F; &#x6324;&#x5230;  int &#x4E2D;, &#x66F4;&#x65B0;int&#x662F;&#x539F;&#x5B50;&#x7684;, &#x5C31;&#x7701;&#x6389;&#x4E86;&#x9501;.
&#x6BD4;&#x5982;, 
strct page&#x4E2D;&#x6709;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct { /* SLUB */
    unsigned inuse:16;
    unsigned objects:15;
    unsigned frozen:1; 
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x5185;&#x6838;&#x4E2D; &#x901A;&#x8FC7; struct pt_regs &#x6765;&#x83B7;&#x53D6;  &#x7528;&#x6237;&#x4F20;&#x9012;&#x7684;&#x53C2;&#x6570;</title>
      <link>https://awakening-fong.github.io/posts/other/pt_regs_for_debug</link>
      <pubDate>2017-02-23</pubDate>
      <description>&lt;p&gt;&#x57FA;&#x4E8E; linux-2.6.35.7/drivers/char/mem.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;asm/ptrace.h&amp;gt;
#include &amp;lt;asm/uaccess.h&amp;gt;

static ssize_t kmsg_write(struct file *file, const char __user *buf,
              size_t count, loff_t *ppos)
{
    char *tmp;
    ssize_t ret;

    tmp = kmalloc(count + 1, GFP_KERNEL);
    if (tmp == NULL)
        return -ENOMEM;
    ret = -EFAULT;
    if (!copy_from_user(tmp, buf, count)) {
        tmp[count] = 0;
        //add
        #define STR_FOUND &amp;quot;sth_will_show_in_dmesg&amp;quot;
        if(NULL!=strstr(tmp,STR_FOUND))
        {
            struct pt_regs *usr_regs; 
            usr_regs=task_pt_regs(current); 
            if(valid_user_regs(usr_regs))
            {
                int fd=usr_regs-&amp;gt;ARM_r0;
                char *write_buf=usr_regs-&amp;gt;ARM_r1;
                int len=usr_regs-&amp;gt;ARM_r2;
                /*&#x7528;&#x6237;&#x6001;&#x7A0B;&#x5E8F;:
                #define STR_TMP &amp;quot;sth_will_show_in_dmesg&amp;quot;
                int fd=open(&amp;quot;/dev/kmsg&amp;quot;, O_WRONLY);
                write(fd,STR_TMP,strlen(STR_TMP));
                */

                /*
                &#x5185;&#x6838;&#x6253;&#x5370;:
                kmsg_write(),969:3 0x6fee0 22
                kmsg_write(),971:buf:sth_will_show_in_dmesg
                &#x4E5F;&#x5C31;&#x662F;&#x6253;&#x5370;&#x51FA;&#x4E86; &#x7528;&#x6237;&#x6001;&#x4F20;&#x9012;&#x7684;&#x53C2;&#x6570;
                */
                tmp_print(&amp;quot;%d 0x%x %d&amp;quot;,fd,write_buf,len);
                if(access_ok(VERIFY_READ, (void *) write_buf,strlen(write_buf)))
                    tmp_print(&amp;quot;buf:%s\n&amp;quot;,write_buf);
            }
            else
            {
                tmp_print(&amp;quot;not valid_user_regs\n&amp;quot;);
            }


        }
        //end add
        ret = printk(&amp;quot;%s&amp;quot;, tmp);
        if (ret &amp;gt; count)
            /* printk can add a prefix */
            ret = count;
    }
    kfree(tmp);
    return ret;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x5173;&#x4E8E;THREAD_START_SP</title>
      <link>https://awakening-fong.github.io/posts/arm/thread_start_sp</link>
      <pubDate>2017-02-23</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://awakening-fong.github.io/posts/arm/arm_qemu_02"&gt;https://awakening-fong.github.io/posts/arm/arm_qemu_02&lt;/a&gt;
&#x4E2D;&#x8BF4;&#x5230; start_kernel&#x524D;&#x8BBE;&#x7F6E;sp&#x4E3A; init_thread_union + THREAD_START_SP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define THREAD_START_SP (THREAD_SIZE - 8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E3A;&#x4F55;&#x8981;-8?  &lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x89E3;&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;static inline struct thread_info *current_thread_info(void)
{
    register unsigned long sp asm (&amp;quot;sp&amp;quot;);
    return (struct thread_info *)(sp &amp;amp; ~(THREAD_SIZE - 1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(&#x56FE;&#x793A;&#x4E2D;A&#x70B9;&#x5230;B&#x70B9;  &#x5927;&#x5C0F;&#x662F;8&#x5B57;&#x8282;)&lt;br&gt;
&#x5982;&#x679C;sp&#x662F;SP0, &#x90A3;&#x4E48;,(sp &amp;amp; ~(THREAD_SIZE - 1)) &#x540E;&#x8FD8;&#x662F;&#x6307;&#x5411;SP0 (A&#x70B9;);&lt;br&gt;
&#x5982;&#x679C;sp&#x662F;SP1, &#x90A3;&#x4E48;, (sp &amp;amp; ~(THREAD_SIZE - 1)) &#x540E;&#x6307;&#x5411;&#x7684;&#x662F;thread_info (C&#x70B9;).&lt;br&gt;
&#x6240;&#x4EE5;, &#x9700;&#x8981;-8.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          SP0 ----&amp;gt;  +.------------+   --.--        &#x9AD8;&#x5730;&#x5740;  
                |    | A           |     |                  
                8    |             |     |            ^     
                |    |             |                  |     
          SP1 ----&amp;gt;  |.B           |  THREAD_SIZE     |     
                     |             |     .            |     
                     |             |     |            |     
                     |             |     |            |     
                     |             |     |            |     
  thread_info ---&amp;gt;   |.C           |  ------          |     
                     |             |                  |     
                     |             |                  |     
                     |             |                  |      
                     |             |                        
                     +-------------+                 &#x4F4E;&#x5730;&#x5740; 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>IIC&#x76F8;&#x5173;&#x5185;&#x5BB9;&#x7684;&#x8BB0;&#x5FC6;</title>
      <link>https://awakening-fong.github.io/posts/hw/iic</link>
      <pubDate>2017-02-15</pubDate>
      <description>&lt;p&gt;&#x672C;&#x6587;&#x7684;&#x5185;&#x5BB9; &#x4EC5;&#x4EC5;&#x662F;&#x4E3A;&#x4E86;&#x80FD;&#x591F;&#x56DE;&#x60F3;&#x8D77;IIC&#x76F8;&#x5173;&#x5185;&#x5BB9;, &#x5E76;&#x4E0D;&#x6C42;&#x4E25;&#x8C28;&#x548C;&#x51C6;&#x786E;.&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x8D77;&#x59CB;&#x548C;&#x505C;&#x6B62;&#x4FE1;&#x53F7;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x56E0;&#x4E3A;&#x4E0A;&#x62C9;&#x7701;&#x7535;, &#x6240;&#x4EE5;, &#x7A7A;&#x95F2;&#x65F6;, SDA&#x662F;&#x4E0A;&#x62C9;&#x7684;.
&#x5728;&#x65F6;&#x949F;&#x4E3A;&#x9AD8;&#x65F6;, SDA&#x82E5;&#x8868;&#x793A;&#x6570;&#x636E;, &#x9700;&#x7EF4;&#x6301;&#x7A33;&#x5B9A;, &#x5426;&#x5219;, &#x5176;&#x8868;&#x793A;&#x8D77;&#x59CB;&#x6216;&#x505C;&#x6B62;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/IIC_start_stop.jpg"&gt;&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x6570;&#x636E;&#x7684;&#x7EC4;&#x7EC7; &#x548C; &#x8868;&#x793A;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5047;&#x5B9A;&#x662F;7bit&#x5730;&#x5740;&#x7684;&#x60C5;&#x51B5;.
&#x5148;&#x53D1;&#x9001;&#x9AD8;&#x4F4D;&#x8FD8;&#x662F;&#x4F4E;&#x4F4D;?&lt;br&gt;
&#x53EF;&#x4EE5;&#x8003;&#x8651;/&#x56DE;&#x5FC6;&#x4E0B; 7bit&#x5730;&#x5740;+1bit&#x8BFB;&#x5199; &#x65F6;&#x7684;&#x60C5;&#x51B5;, &#x6211;&#x4EEC;&#x662F;&#x5148;&#x53D1;&#x9001;&#x5730;&#x5740;&#x7684;, &#x6240;&#x4EE5;, &#x662F;&#x5148;&#x53D1;&#x9001;&#x9AD8;&#x4F4D;, &#x540E;&#x53D1;&#x9001;&#x4F4E;&#x4F4D;&#x7684;.&lt;/p&gt;

&lt;p&gt;&#x6700;&#x5E38;&#x89C1;&#x7684;&#x662F;r/w# &#x6240;&#x4EE5;,&#x8BFB;&#x4E3A;1, &#x5199;&#x4E3A;0.  &lt;/p&gt;

&lt;p&gt;&#x65F6;&#x949F;&#x6709;, &#x4EE3;&#x8868;&#x5FC3;&#x810F;&#x8FD8;&#x5728;&#x8DF3;, &#x5668;&#x4EF6;&#x8FD8;&#x5728;&#x5DE5;&#x4F5C;, &#x6240;&#x4EE5;, &#x5728;SCL&#x9AD8;&#x7535;&#x5E73;&#x65F6;&#x5BF9;SDA&#x91C7;&#x6837;&#x4F5C;&#x4E3A;&#x6570;&#x636E;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/IIC_SCL_high_SDA_valid.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x5982;SCL&#x9AD8;&#x7535;&#x5E73;&#x65F6;, SDA&#x53D1;&#x751F;&#x4E86;&#x8F6C;&#x6362;, &#x90A3;&#x4E48;, &#x5C31;&#x4E0D;&#x662F;&#x5728;&#x4F20;&#x9001;&#x6570;&#x636E;, &#x800C;&#x662F;&#x8868;&#x793A;&#x8D77;&#x59CB;&#x6216;&#x505C;&#x6B62;.&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x5F02;&#x5E38;&#x5904;&#x7406;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;ACK: &#x63A5;&#x6536;&#x5230;8bit&#x6570;&#x636E;&#x7684;&#x8981;&#x56DE;&#x590D;ACK, &#x8FD9;&#x6837;&#x662F;9bit. master&#x7AEF;&#x53D1;&#x9001;7bit&#x5730;&#x5740;+1bit&#x8BFB;&#x5199;, slave&#x56DE;&#x590D;ACK, &#x4E5F;&#x662F;9bit, &#x5F62;&#x5F0F;&#x4E0A;&#x7EDF;&#x4E00;.&lt;/p&gt;

&lt;p&gt;ACK&#x8981;&#x80FD;&#x591F;&#x88AB;&#x68C0;&#x6D4B;&#x5230;, &#x6545;&#x4E0D;&#x53D1;&#x9001;ACK&#x7684;&#x90A3;&#x65B9;&#x4E0D;&#x80FD;&#x53BB;&#x5E72;&#x6270;SDA, &#x6545;&#x4FDD;&#x6301;&#x9AD8;&#x7535;&#x4F4D;, &#x53D1;&#x9001;ACK&#x7684;&#x90A3;&#x65B9;&#x62C9;&#x4F4E;SDA.&lt;/p&gt;

&lt;p&gt;&#x5982;&#x679C; &#x4ECE;&#x673A;&#x63A5;&#x6536;&#x597D;&#x5B8C;&#x6574;&#x7684;&#x6570;&#x636E;&#x5B57;&#x8282;(&#x542B;&#x54CD;&#x5E94;&#x4F4D;) &#x540E;,  &#x8981;&#x5B8C;&#x6210;&#x4E00;&#x4E9B;&#x5176;&#x4ED6;&#x529F;&#x80FD;&#x540E; (&#x4F8B;&#x5982;&#x4E00;&#x4E2A;&#x5185;&#x90E8;&#x4E2D;&#x65AD;&#x670D;&#x52A1;&#x7A0B;&#x5E8F;), &#x624D;&#x80FD;&#x63A5;&#x6536;&#x6216;&#x53D1;&#x9001;&#x4E0B;&#x4E00;&#x4E2A;&#x5B8C;&#x6574;&#x7684;&#x6570;&#x636E;&#x5B57;&#x8282;, &#x53EF;&#x4EE5;&#x4F7F;&#x65F6;&#x949F;&#x7EBF; SCL &#x4FDD;&#x6301;&#x4F4E;&#x7535;&#x5E73;&#x8FEB;&#x4F7F;&#x4E3B;&#x673A;&#x8FDB;&#x5165;&#x7B49;&#x5F85;&#x72B6;&#x6001;. &lt;/p&gt;
</description>
    </item>
    <item>
      <title>page reclaim 01:&#x6982;&#x8FF0;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_01_overview</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x80CC;&#x666F;/&#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x672C;&#x6587;&#x4E0D;&#x8BA8;&#x8BBA; swapping (swap out to disk).  &lt;/p&gt;

&lt;p&gt;If a seldom-used page is backed by a block device (e.g., memory mappings
of files) then the modified pages need not be swapped out, but can be directly synchronized with the block device. The page frame can be reused, and if the data are required again, it can be reconstructed from the source. If a page is backed by a file but cannot be modified in memory (e.g., binary executable data), then it can be discarded if it is currently not required.
&#x901A;&#x8FC7;Writing back cached data&#x5373;&#x53EF;&#x5C06;&#x8FD9;&#x4E9B;page&#x91CA;&#x653E;.&lt;/p&gt;

&lt;p&gt;If a page is backed by a file but cannot be modified in memory (e.g., binary executable data), then it can be discarded if it is currently not required. &lt;/p&gt;

&lt;p&gt;&#x5C06; &#x6682;&#x65F6;&#x4E0D;&#x7528;&#x7684; &#x6216; &#x5F88;&#x5C11;&#x4F7F;&#x7528;&#x7684;  &#x5185;&#x5B58;&#x56DE;&#x7B3C;/&#x56DE;&#x6536;, &#x7ED9;&#x540E;&#x7EED;&#x5176;&#x4ED6;&#x4EBA;&#x4F7F;&#x7528;. &#x90A3;&#x4E48;, &#x5982;&#x4F55;&#x754C;&#x5B9A; &#x6682;&#x65F6;&#x4E0D;&#x7528; &#x6216; &#x5F88;&#x5C11;&#x4F7F;&#x7528; &#x5462;? &#x8FD9;&#x4E9B;&#x5DF2;&#x5206;&#x914D;&#x51FA;&#x53BB;&#x7684;&#x5185;&#x5B58;&#x90FD;&#x6563;&#x843D;&#x5728;&#x54EA;&#x91CC;?&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x6563;&#x843D;&#x5728;&#x54EA;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5982;&#x4F55;&#x627E;&#x5230;&#x8FD9;&#x4E9B;&#x5185;&#x5B58;&#x5462;? &#x5565;&#x94FE;&#x8868;&#x5417;?&lt;br&gt;
&#x7B54;:see add_to_page_cache_lru(), page_add_new_anon_rmap()&lt;/p&gt;

&lt;p&gt;&#x65B9;&#x5F0F;1:
add_to_page_cache_lru &#x628A;page&#x6DFB;&#x52A0;&#x5230; both the page cache and the LRU cache. 
Most importantly, it is used by mpage_readpages and do_generic_mapping_read, the standard functions in which the block layer ends up when reading data from a file or mapping.
&#x5F53;&#x7136;, &#x5B9E;&#x9645;&#x662F;&#x5148;&#x6DFB;&#x52A0;&#x5230;per cpu&#x7684;struct pagevec&#x4E2D;, &#x7B49;&#x6EE1;&#x4E86;&#x518D;&#x8F6C;&#x79FB;&#x5230;global&#x7684;lru&#x4E2D;.&lt;/p&gt;

&lt;p&gt;&#x65B9;&#x5F0F;2:
add_to_page_cache_lru &#x5C06;page&#x52A0;&#x5165;tree, &#x6545;&#x53EF;&#x8003;&#x8651;&#x4ECE;&#x5404;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;inode&#x904D;&#x5386;&#x5404;page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drop_caches_sysctl_handler -&amp;gt; iterate_supers(drop_pagecache_sb, NULL)
|--list_for_each_entry(inode, &amp;amp;sb-&amp;gt;s_inodes, i_sb_list)
|   |--invalidate_mapping_pages(inode-&amp;gt;i_mapping, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x5982;&#x4F55;&#x5224;&#x65AD;rarely used&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5982;&#x4E0A;&#x6240;&#x8FF0;, page&#x7EC4;&#x7EC7;&#x5728;&#x94FE;&#x8868;lru&#x4E2D;. &#x9996;&#x6B21;&#x8BBF;&#x95EE;page&#x4F1A;&#x5C06;page&#x653E;&#x5230;&#x94FE;&#x8868;&#x5F00;&#x5934;,  &#x4E0D;&#x8FC7;, &#x540E;&#x7EED;&#x8BBF;&#x95EE;page, &#x5E76;&#x4E0D;&#x4F1A;&#x628A;page&#x8C03;&#x6574;&#x5230;&#x94FE;&#x8868;lru&#x7684;&#x5F00;&#x5934;.
&#x4E3A;&#x4E86;&#x533A;&#x5206;&#x4F7F;&#x7528;&#x9891;&#x7387;, &#x5185;&#x6838;&#x5C06;&#x8F83;&#x5C11;&#x4F7F;&#x7528;&#x7684;page&#x653E;&#x5165;inactive list&#x4E2D;. &#x5982;&#x679C;&#x4F7F;&#x7528;&#x76F8;&#x5BF9;&#x9891;&#x7E41;, &#x5219;&#x79FB;&#x52A8;&#x5230;active list&#x4E2D;.&lt;br&gt;
&#x8FD9;&#x6837;, &#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x4ECE;&#x7279;&#x5B9A;&#x94FE;&#x8868;&#x4E2D;&#x5C1D;&#x8BD5;&#x5BF9;page&#x8FDB;&#x884C;&#x56DE;&#x6536;, &#x56E0;&#x4E3A;&#x8FD9;&#x4E9B;&#x94FE;&#x8868;&#x4E2D;&#x7684;page&#x76F8;&#x5BF9;&#x8F83;&#x5C11;&#x4F7F;&#x7528;.&lt;/p&gt;

&lt;p&gt;&#x9996;&#x6B21;&#x6DFB;&#x52A0;&#x5230;lru&#x7684;&#x8BDD;, &#x901A;&#x5E38;&#x662F;&#x6DFB;&#x52A0;&#x5230;inactive&#x90A3;&#x8FB9;, &#x5BF9;&#x4E8E;&#x533F;&#x540D;&#x9875;&#x6DFB;&#x52A0;&#x5230;active list, see  __do_fault, do_anonymous_page, do_wp_page&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. PG_referenced&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;page&#x5728;active list&#x548C;inactive list&#x4E4B;&#x95F4;&#x8FC1;&#x79FB;, &#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A;page&#x7684;&#x72B6;&#x6001;&#x8FC1;&#x79FB;&#x4E86;, &#x800C;&#x8FD9;&#x4E24;&#x8005;&#x7684;&#x8FC1;&#x79FB;&#x4EC5;&#x9700;&#x4E00;&#x6B65;, &#x5185;&#x6838;&#x8BA4;&#x4E3A;&#x8FD9;&#x4E2A;&#x4E0D;&#x5408;&#x9002;, &#x5F15;&#x5165;&#x4E86; PG_referenced. &lt;/p&gt;

&lt;p&gt;PG_referenced &#x548C; PG_active &#x7684;&#x533A;&#x522B;&lt;br&gt;
&#x5728;&#x5F15;&#x5165;PG_referenced&#x4E4B;&#x524D;, When the page is accessed, the flag is set, but when is it going to be removed again? Either the kernel does not remove it automatically, but then the page would remain in the active state forever even if it would only be used very little, or not at all anymore.   &lt;/p&gt;

&lt;p&gt;&#x4E3A;&#x6B64;, &#x6211;&#x4EEC;&#x9700;&#x8981;&#x80FD;&#x591F;&#x8BA4;&#x51FA; &#x6807;&#x8BB0;&#x4E86;PG_active&#x4F46;&#x4E0D;&#x5E38;&#x8BBF;&#x95EE;&#x7684;page.
&#x5F53;&#x524D;&#x7684;&#x65B9;&#x6CD5;&#x662F;&#x5F15;&#x5165;&#x4E86; PG_referenced &#x8FD9;&#x4E2A;&#x6807;&#x8BB0;.&lt;/p&gt;

&lt;p&gt;page fault&#x4F1A;&#x5C06;page &#x8BBE;&#x7F6E;&#x4E3A;active, &#x90A3;&#x4E48;, &#x662F;&#x5426;&#x4F1A;&#x4E00;&#x76F4;&#x5446;&#x5728;&#x67D0;&#x4E2A;list&#x4E2D;&#x5462;?&lt;br&gt;
&#x7B54;:&#x4E0D;&#x4F1A;, page_check_references &#x548C; mark_page_accessed &#x53CC;&#x65B9;&#x8FDB;&#x884C;&#x89D2;&#x9010;.&lt;/p&gt;

&lt;p&gt;inactive&#x4E0D;&#x4F1A;&#x76F4;&#x63A5;&#x8F6C;&#x53D8;&#x4E3A;active, &#x8981;&#x5148;unreferenced&#x8F6C;&#x53D8;&#x4E3A;referenced.&lt;br&gt;
&#x5982;&#x679C;D0&#x8868;&#x793A; PG_referenced , D1&#x8868;&#x793A; PG_active, &#x90A3;&#x4E48;, &#x72B6;&#x6001;&#x8F6C;&#x6362;&#x5373;&#x4E3A;:&lt;br&gt;
0b00-&amp;gt;0b01-&amp;gt;0b10-&amp;gt;0b11&lt;/p&gt;

&lt;p&gt;&#x5F15;&#x5165;&#x4E4B;&#x540E;, A highly active page has both PG_active and PG_referenced set.&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;5. &#x4F55;&#x5904;&#x8C03;&#x7528; page_check_references &#x548C; mark_page_accessed&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x8C03;&#x7528;page_check_references&#x7684;&#x8DEF;&#x5F84;:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_inactive_list -&amp;gt; shrink_page_list -&amp;gt; page_check_references
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5E38;&#x89C1;&#x7684;&#x8C03;&#x7528; mark_page_accessed&#x7684;&#x8DEF;&#x5F84;: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch_buffer -&amp;gt; mark_page_accessed(bh-&amp;gt;b_page)
do_generic_file_read -&amp;gt; mark_page_accessed(page)
generic_perform_write -&amp;gt; mark_page_accessed(page)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4F55;&#x65F6; shrink   PG_referenced, PG_active?&lt;br&gt;
&#x7B54;: &#x5E38;&#x89C1;&#x7684;&#x6709;direct reclaim &#x548C; kswapd, &#x4EE5;&#x53CA;truncate&#x7B49;.&lt;/p&gt;

&lt;h1 id="toc_5"&gt;&lt;h4&gt;6. &#x5982;&#x4F55;&#x56DE;&#x6536;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5982;&#x6807;&#x9898;1&#x4E2D;&#x7684;&#x5185;&#x5BB9;&#x6240;&#x8FF0;, &#x5BF9;&#x4E8E;&#x6709;&#x5757;&#x8BBE;&#x5907;&#x540E;&#x5907;&#x7684;page, &#x5728;reclaim&#x540E;, &#x82E5;&#x540E;&#x7EED;&#x9700;&#x8981;, &#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x91CD;&#x65B0;&#x8BFB;&#x5165;&#x6765;&#x6062;&#x590D;, &#x6240;&#x4EE5;, &#x53EF;&#x5C06;page&#x7684;&#x5185;&#x5BB9;&#x56DE;&#x5199;&#x5230;&#x540E;&#x5907;&#x8BBE;&#x5907;&#x4E2D;, &#x7136;&#x540E;&#x5F52;&#x8FD8;&#x7ED9;buddy system, see shrink_inactive_list().&lt;/p&gt;

&lt;h1 id="toc_6"&gt;&lt;h4&gt;7. &#x6570;&#x636E;&#x7ED3;&#x6784;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;per zone : active list, inactive list&lt;br&gt;
per node :kswapd&lt;br&gt;
per cpu  :lru cache, &#x4E5F;&#x5C31;&#x662F; pagevec  &lt;/p&gt;
</description>
    </item>
    <item>
      <title>page reclaim 05:page count</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_05_page_count</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/vmscan.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline int is_page_cache_freeable(struct page *page)
{

    /*
     * A freeable page cache page is referenced only by the caller
     * that isolated the page, the page cache radix tree and
     * optional buffer heads at page-&amp;gt;private.
     */
    return page_count(page) - page_has_private(page) == 2;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E3A;&#x4F55;&#x662F;== 2?&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x89E3;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x8C03;&#x7528;&#x8DEF;&#x5F84;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_inactive_list
|--lru_add_drain
|--isolate_lru_pages
|   |--get_page_unless_zero  //&#x5F15;&#x7528;&#x8BA1;&#x6570;
|--shrink_page_list   (shrink_page_list&#x4E0D;&#x4F1A;&#x88AB;shrink_active_list&#x8C03;&#x7528;.)
|   |--pageout
|   |   |--is_page_cache_freeable
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_2"&gt;&lt;h4&gt;2.1 isolated the page&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x7565;&lt;/p&gt;

&lt;h2 id="toc_3"&gt;&lt;h4&gt;2.2 buddy system&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x6CE8;&#x91CA;&#x4E2D;&#x63D0;&#x5230;&amp;quot;the page cache radix tree&amp;quot;&#x7684;&#x5F15;&#x7528;&#x8BA1;&#x6570;, &#x8FD9;&#x4E2A;&#x6CE8;&#x91CA;&#x5E76;&#x4E0D;&#x51C6;&#x786E;, &#x5E94;&#x8BE5;&#x662F;&#x4ECE;buddy system&#x5206;&#x914D;&#x4EA7;&#x751F;&#x7684;&#x5F15;&#x7528;&#x8BA1;&#x6570;.&lt;/p&gt;

&lt;p&gt;buddy system&#x7684;get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;page_cache_alloc_cold -&amp;gt; __alloc_pages_nodemask
|   |--get_page_from_freelist
|   |   |--buffered_rmqueue 
|   |   |   |--prep_new_page
|   |   |   |   |--set_page_refcounted -&amp;gt; set_page_count(page, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5E76;&#x4E0D;&#x662F;radix tree&#x7684;get&#x7684;&#x7406;&#x7531;&#x5982;&#x4E0B;:&lt;br&gt;
&#x4EE5;do_generic_file_read &#x4E3A;&#x4F8B;, &#x770B;&#x4E0B;page cache&#x7684;get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_generic_file_read
|--no_cached_page: page_cache_alloc_cold -&amp;gt; __alloc_pages_nodemask
|   |--get_page_from_freelist
|   |   |--buffered_rmqueue 
|   |   |   |--prep_new_page
|   |   |   |   |--set_page_refcounted -&amp;gt; set_page_count(page, 1);
|--add_to_page_cache_lru
|   |--add_to_page_cache -&amp;gt; add_to_page_cache_locked
|   |   |   |--page_cache_get //&#x5F15;&#x7528;&#x8BA1;&#x6570;A
|   |   |   |--radix_tree_insert
|   |--lru_cache_add_file -&amp;gt; __lru_cache_add
|--readpage: mapping-&amp;gt;a_ops-&amp;gt;readpage(filp, page)
|--ret = actor(desc, page, offset, nr);//&#x6BD4;&#x5982;file_read_actor()
|--page_cache_release(page); //&#x5F15;&#x7528;&#x8BA1;&#x6570;B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4F7F;&#x7528;&#x5B8C;&#x540E;, &#x4FEE;&#x6539;&#x5F15;&#x7528;&#x8BA1;&#x6570;, &#x6545;&#x8FD9;&#x91CC;&#x5BF9;&#x5F15;&#x7528;&#x8BA1;&#x6570;&#x6CA1;&#x6709;&#x5F71;&#x54CD;.&lt;/p&gt;

&lt;p&gt;lru&#x7684;&#x8BA1;&#x6570;&#x5462;?&lt;br&gt;
&#x7B54;:&#x52A0;&#x5165;pagevec&#x4E2D;&#x4F1A;get page, &#x6E05;&#x7A7A;pagevec&#x653E;&#x5165;lru&#x65F6;, &#x4F1A;put page.&lt;/p&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;2.3 buffer_head&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x82E5;page_has_private()&#x8FD4;&#x56DE;1, &#x5219;page_count&#x4E3A;3&lt;/p&gt;

&lt;p&gt;buffer_head&#x65F6;&#x7684;get page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grow_dev_page
|--find_or_create_page
|--alloc_page_buffers
|--link_dev_buffers(page, bh) -&amp;gt; attach_page_buffers
|   |--page_cache_get
|   |--set_page_private
|--page_cache_release(page);  //&#x548C;find_or_create_page&#x4E2D;&#x7684;get &#x5BF9;&#x5E94;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>page reclaim 06:ARM&#x548C;L_PTE_YOUNG</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_06_arm_l_pte_young</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. page_referenced_one&#x5BF9;&#x786C;&#x4EF6;&#x9875;&#x8868;&#x7684;&#x5F71;&#x54CD;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/include/asm-generic/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;page_referenced_one -&amp;gt; ptep_clear_flush_young_notify -&amp;gt; ptep_clear_flush_young -&amp;gt; ptep_test_and_clear_young
{
//pte_mkold &#x5B9E;&#x73B0;&#x4E0A;&#x662F;:PTE_BIT_FUNC(mkold,     &amp;amp;= ~L_PTE_YOUNG);
set_pte_at(vma-&amp;gt;vm_mm, address, ptep, pte_mkold(pte));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,
                  pte_t *ptep, pte_t pteval)
{
    unsigned long ext = 0;

    if (addr &amp;lt; TASK_SIZE &amp;amp;&amp;amp; pte_present_user(pteval)) {
        __sync_icache_dcache(pteval);
        ext |= PTE_EXT_NG;
    }
    /*
    @pteval &#x662F;linux&#x7248;&#x7684;pte
    &#x786C;&#x4EF6;&#x7248;&#x7684;&#x4F1A;&#x6839;&#x636E;ext&#x6765;&#x751F;&#x6210;
    */
    set_pte_ext(ptep, pteval, ext);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable-2level-hwdef.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PTE_EXT_NG      (_AT(pteval_t, 1) &amp;lt;&amp;lt; 11)    /* v6 */    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x4E2A;&#x540E;&#x7EED;&#x6CA1;&#x6709;&#x7528;&#x5230;, &#x5FFD;&#x7565;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable-2level.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define set_pte_ext(ptep,pte,ext) cpu_set_pte_ext(ptep,pte,ext)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set_pte_at -&amp;gt; set_pte_ext -&amp;gt; cpu_set_pte_ext -&amp;gt; cpu_v7_set_pte_ext&lt;/p&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x60F3;&#x77E5;&#x9053;&#x7684;&#x662F;: ext&#x4E2D; L_PTE_YOUNG&#x6CA1;&#x6709;&#x7F6E;&#x4F4D;&#x65F6;, &#x786C;&#x4EF6;&#x9875;&#x8868;&#x7684;&#x53D8;&#x5316;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/arch/arm/mm/proc-v7-2level.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ENTRY(cpu_v7_set_pte_ext)
...
@r1&#x662F;linux&#x7248;
tst r1, #L_PTE_YOUNG
tstne   r1, #L_PTE_VALID
@#define L_PTE_NONE     (_AT(pteval_t, 1) &amp;lt;&amp;lt; 11)
eorne   r1, r1, #L_PTE_NONE
tstne   r1, #L_PTE_NONE
moveq   r3, #0
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5F53;L_PTE_YOUNG&#x6CA1;&#x6709;&#x7F6E;&#x4F4D;&#x65F6;, &#x8FD9;&#x91CC;&#x4F1A;&#x6267;&#x884C;moveq r3, #0, 
&#x4E5F;&#x5C31;&#x662F;&#x9875;&#x8868;&#x9879;&#x4FEE;&#x6539;&#x4E3A;0, &#x7136;&#x540E;&#x5B58;&#x50A8;&#x5230;&#x786C;&#x4EF6;&#x7248;&#x9875;&#x8868;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x540E;&#x7EED;&#x8BBF;&#x95EE;&#x76F8;&#x5173;page&#x4F1A;&#x5982;&#x4F55;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6267;&#x884C;page_referenced_one&#x4E4B;&#x540E;, &#x7531;&#x4E8E;&#x786C;&#x4EF6;&#x9875;&#x8868;&#x88AB;&#x6E05;&#x96F6;, &#x540E;&#x7EED;&#x8BBF;&#x95EE;&#x5F15;&#x53D1;&#x5F02;&#x5E38;, &#x4F1A;&#x6267;&#x884C;&#x5230;handle_pte_fault.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/mm/memory.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;handle_pte_fault
{
    if (!pte_present(entry)) {

        return ...
    }
    ...
    entry = pte_mkyoung(entry);
    ptep_set_access_flags() -&amp;gt;  set_pte_at()

}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E0A;&#x9762;&#x786C;&#x4EF6;&#x9875;&#x8868;&#x88AB;&#x6E05;&#x96F6;&#x4E86;, &#x4F46;&#x662F;linux&#x7248;&#x9875;&#x8868;&#x5E76;&#x6CA1;&#x6709;&#x6E05;&#x96F6;, &#x53EA;&#x6E05;&#x6389;L_PTE_YOUNG.
&#x8FD9;&#x91CC;&#x9700;&#x8981;&#x77E5;&#x9053;, if (!pte_present(entry))&#x662F;&#x5426;&#x4F1A;&#x6210;&#x7ACB;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define pte_present(pte)    (pte_isset((pte), L_PTE_PRESENT))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable-2level.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define L_PTE_PRESENT       (_AT(pteval_t, 1) &amp;lt;&amp;lt; 0)
#define L_PTE_YOUNG     (_AT(pteval_t, 1) &amp;lt;&amp;lt; 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4EE5;&#x901A;&#x8FC7;mmap&#x6765;&#x8BBF;&#x95EE;&#x6587;&#x4EF6;&#x4E3A;&#x4F8B;, &#x770B;&#x770B;&#x521B;&#x5EFA;&#x7684;linux&#x7684;pte.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mmap_region
|--vma-&amp;gt;vm_flags = vm_flags;
|--vma-&amp;gt;vm_page_prot = vm_get_page_prot(vm_flags);

vm_get_page_prot -&amp;gt; protection_map -&amp;gt; __PAGE_NONE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/arch/arm/include/asm/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define __PAGE_NONE     __pgprot(_L_PTE_DEFAULT | ...&#x7701;&#x7565;...  )
#define _L_PTE_DEFAULT  L_PTE_PRESENT | L_PTE_YOUNG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;__PAGE_NONE &#x548C;&#x5176;&#x4ED6;&#x7684;__PAGE_xx &#x90FD;&#x542B;_L_PTE_DEFAULT.
&#x4E5F;&#x5C31;&#x662F;&#x8BF4;, &#x521B;&#x5EFA;&#x7684;linux&#x7248;pte&#x542B;&#x6709;L_PTE_PRESENT.&lt;/p&gt;

&lt;p&gt;set_pte_at -&amp;gt; set_pte_ext -&amp;gt; cpu_set_pte_ext -&amp;gt; cpu_v7_set_pte_ext&lt;br&gt;
cpu_v7_set_pte_ext&#x4E0D;&#x4F1A;&#x4FEE;&#x6539;&#x5230;L_PTE_PRESENT.&lt;br&gt;
&#x4E5F;&#x5C31;&#x662F;&#x8BF4;, &#x540E;&#x7EED;&#x5F02;&#x5E38;&#x65F6;, L_PTE_PRESENT&#x662F;&#x7F6E;&#x4F4D;&#x72B6;&#x6001;&#x4E86;, &#x540E;&#x7EED;&#x82E5;&#x56E0;reclaim&#x7684;&#x626B;&#x63CF;, L_PTE_YOUNG&#x4F1A;&#x88AB;&#x6E05;&#x6389;, &#x786C;&#x4EF6;&#x9875;&#x8868;&#x4E5F;&#x88AB;&#x6E05;&#x96F6;, &#x82E5;&#x8BBF;&#x95EE;&#x8BE5;&#x9875;&#x8868;&#x76F8;&#x5173;&#x7684;page, &#x4E0D;&#x8D70;if (!pte_present(entry)), &#x800C;&#x662F;&#x4F1A;&#x7F6E;&#x4F4D;L_PTE_YOUNG, &#x5E76;&#x6839;&#x636E;&#x8FD9;&#x4E2A;&#x542B;&#x6709;L_PTE_YOUNG&#x7684;linux&#x9875;&#x8868; &#x91CD;&#x65B0;&#x8BBE;&#x7F6E;&#x786C;&#x4EF6;&#x9875;&#x8868;.&lt;/p&gt;

&lt;p&gt;&#x7531;&#x4E8E;&#x8FD9;&#x4E2A;&#x5F02;&#x5E38;&#x53EA;&#x6709;&#x5728;&#x8BE5;page&#x88AB;reclaim&#x626B;&#x63CF;&#x5230;&#x540E;&#x624D;&#x4F1A;&#x53D1;&#x751F;, &#x6545;overhead&#x5E76;&#x4E0D;&#x4E25;&#x91CD;.  &lt;/p&gt;
</description>
    </item>
    <item>
      <title>page reclaim 00:&#x76F8;&#x5173;&#x8D44;&#x6599;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_00_references</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[Professional Linux Kernel Architecture]&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reducing Memory Access Latency by Satoru Moriya
&lt;a href="http://events.linuxfoundation.org/sites/events/files/lcjp13_moriya.pdf"&gt;http://events.linuxfoundation.org/sites/events/files/lcjp13_moriya.pdf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/"&gt;https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[Understanding the Linux Kernel, 3rd Edition]&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>page reclaim 03:&#x6D3B;&#x8DC3;&#x5EA6;&#x7684;&#x8868;&#x793A;&#x548C;&#x72B6;&#x6001;&#x8F6C;&#x6362;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_03_activity</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. page_referenced&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/rmap.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; * Quick test_and_clear_referenced for all mappings to a page,
 * returns the number of ptes which referenced the page.
&#x8FD9;&#x4E2A;&#x6CE8;&#x91CA;&#x8FC7;&#x65F6;&#x4E86;, &#x5B9E;&#x9645;&#x529F;&#x80FD;&#x5E76;&#x4E0D;&#x662F;&#x8FD4;&#x56DE;&#x6307;&#x5411;&#x8BE5;page&#x7684;pte&#x7684;&#x4E2A;&#x6570;. 

 &#x95EE;&#x9898;:&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x7684;&#x7528;&#x9014;?
 &#x7B54;:&#x7528;&#x6765;&#x53CD;&#x5E94;&#x5728;inactive list&#x4E2D;&#x7684;page&#x7684;&#x6D3B;&#x8DC3;&#x7A0B;&#x5EA6;.
 &#x8FD4;&#x56DE;&#x6570;&#x503C;1&#x548C;&#x8FD4;&#x56DE;&#x6570;&#x503C;2&#x662F;&#x6709;&#x533A;&#x522B;&#x7684;, see page_check_references
 {
     referenced_ptes = page_referenced(...);
     if (... || referenced_ptes &amp;gt; 1)
        return PAGEREF_ACTIVATE;

 }
 */
int page_referenced(struct page *page,
        int is_locked,
        struct mem_cgroup *memcg,
        unsigned long *vm_flags)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. L_PTE_YOUNG&#x548C; mark_page_accessed, &#x7528;&#x54EA;&#x4E2A;&#x5462;?&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6709;&#x4E9B;page&#x662F;&#x5148;kmap, &#x63A5;&#x7740; __copy_to_user, &#x6700;&#x540E;kunmap, &#x8FD9;&#x79CD;&#x4F7F;&#x7528;&#x4E4B;&#x540E; page&#x5C31;&#x88AB; unmap &#x6389;, &#x5982;&#x679C;&#x662F;highmem, &#x901A;&#x8FC7;pte young&#x6807;&#x8BB0;&#x5C31;&#x6CA1;&#x6709;&#x610F;&#x4E49;, &#x6545;&#x91C7;&#x7528;mark page accessed&#x6765;&#x63D0;&#x5347;&#x6D3B;&#x8DC3;&#x5EA6;.
&#x8FD9;&#x79CD;&#x7C7B;&#x578B;&#x7684;page, &#x6CA1;&#x6709;&#x88AB;&#x8FDB;&#x7A0B;&#x5F15;&#x7528;, &#x56DE;&#x6536;&#x65F6;&#x4E5F;&#x65E0;&#x9700;&#x4FEE;&#x6539;&#x9875;&#x8868;.
&#x6216;&#x8005;&#x8BF4;, &#x8BE5;page&#x6CA1;&#x6709;&#x548C;&#x8FDB;&#x7A0B;&#x5173;&#x8054;, &#x6545;&#x4E0D;&#x901A;&#x8FC7;&#x9875;&#x8868;&#x6765;&#x6807;&#x8BB0;&#x6D3B;&#x8DC3;&#x5EA6;.&lt;/p&gt;

&lt;p&gt;&#x5BF9;&#x4E8E;&#x548C;&#x8FDB;&#x7A0B;&#x5173;&#x8054;&#x7684;page, L_PTE_YOUNG&#x6CA1;&#x6709;&#x7F6E;&#x4F4D;&#x65F6;, &#x8BBF;&#x95EE;&#x4F1A;&#x53D1;&#x751F;&#x5F02;&#x5E38;, &#x5728;fault handler&#x4E2D;&#x4F1A;&#x7F6E;&#x4F4D;L_PTE_YOUNG, &#x5B8C;&#x6210;&#x6D3B;&#x8DC3;&#x5EA6;&#x7684;&#x6807;&#x8BB0;.
&#x88AB;&#x626B;&#x63CF;&#x5230;&#x65F6;, &#x5224;&#x65AD;&#x6D3B;&#x8DC3;&#x5EA6;&#x4FE1;&#x606F;&#x540E;, &#x603B;&#x662F;&#x4F1A;&#x88AB;&#x6E05;&#x6389;L_PTE_YOUNG, &#x5982;&#x679C;&#x6709;L_PTE_YOUNG&#x7684;&#x8BDD;.&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. page_check_references&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x6D3B;&#x8DC3;&#x7A0B;&#x5EA6; &#x4F53;&#x73B0;&#x5728; &#x4E24;&#x4E2A;&#x65B9;&#x9762;, 
&#x4E00;&#x4E2A;&#x662F;  &#x8BE5;page&#x53EF;&#x80FD;&#x5728;&#x591A;&#x4E2A;&#x8FDB;&#x7A0B;/&#x7EBF;&#x7A0B;&#x4E2D;&#x88AB;&#x5F15;&#x7528;, &#x8FD9;&#x4E9B;&#x8FDB;&#x7A0B;&#x4E2D;&#x8BE5;page&#x7684;pte&#x7684;young&#x6709;&#x6240;&#x4F53;&#x73B0;,&lt;br&gt;
&#x53E6;&#x4E00;&#x4E2A;&#x662F; struct page&#x7684;flag PG_referenced, PG_active.&lt;/p&gt;

&lt;p&gt;shrink_inactive_list -&amp;gt; shrink_page_list -&amp;gt; page_check_references&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static enum page_references page_check_references(struct page *page,
                      struct scan_control *sc)
{
    int referenced_ptes, referenced_page;
    unsigned long vm_flags;

    referenced_ptes = page_referenced(page, 1, sc-&amp;gt;target_mem_cgroup,
                      &amp;amp;vm_flags);
    referenced_page = TestClearPageReferenced(page);


    if (referenced_ptes) {
            SetPageReferenced(page);

        if (referenced_page || referenced_ptes &amp;gt; 1)
            return PAGEREF_ACTIVATE;
        ...
        return PAGEREF_KEEP;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x5982;&#x4F55;&#x7406;&#x89E3;&#x8FD9;&#x91CC;&#x7684; SetPageReferenced?&lt;br&gt;
&#x7B54;: page_referenced()&#x603B;&#x662F;&#x4F1A;&#x6E05;&#x6389;pte&#x7684;young, &#x5982;&#x679C;&#x8FD9;&#x91CC;(shrink_inactive_list -&amp;gt; .. -&amp;gt; page_check_references)&#x4E0D;SetPageReferenced, 
&#x76F8;&#x5F53;&#x4E8E;&#x4E00;&#x4E0B;&#x5B50;&#x628A;&#x8F83;&#x6D3B;&#x8DC3;&#x7684;page&#x7684;&#x6D3B;&#x8DC3;&#x5EA6;&#x5168;&#x90E8;&#x62B9;&#x6389;, &#x4F3C;&#x4E4E;&#x5E76;&#x4E0D;&#x5408;&#x9002;, &#x6545;&#x8FD9;&#x91CC;SetPageReferenced&#x7ED9;page&#x4FDD;&#x7559;&#x4E00;&#x70B9;&#x6D3B;&#x8DC3;&#x5EA6;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. mm: don&amp;#39;t mark_page_accessed in fault path&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/filemap.c&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;filemap_fault() is invoked via the vma operations vector for a
mapped memory region to read in file data during a page fault.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;filemap_fault  
|--count_vm_event(PGMAJFAULT);  
|--no_cached_page: page_cache_read(file, offset);  
|   |--page_cache_alloc_cold  
|   |--add_to_page_cache_lru -&amp;gt; lru_cache_add_file  
|   |   |--__lru_cache_add(page, LRU_INACTIVE_FILE)  
|   |--mapping-&amp;gt;a_ops-&amp;gt;readpage  
|--retry_find:  page = find_get_page(mapping, offset)  
|--&lt;del&gt;mark_page_accessed&lt;/del&gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mm: don&amp;#39;t mark_page_accessed in fault path 
&lt;a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=bf3f3bc5e734706730c12a323f9b2068052aa1f0"&gt;https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=bf3f3bc5e734706730c12a323f9b2068052aa1f0&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Doing a mark_page_accessed at fault-time, then doing SetPageReferenced at unmap-time if the pte is young       has a number of problems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x672C;&#x8865;&#x4E01;&#x4E4B;&#x524D;&#x7684;&#x65B9;&#x5F0F;&#x662F;, &#x5982;&#x679C;
fault&#x65F6;mark_page_accessed, &#x7136;&#x540E;, unmap&#x65F6;&#x82E5;pte young&#x5219;SetPageReferenced, 
&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x4F1A;&#x5BFC;&#x81F4;&#x4E00;&#x4E9B;&#x95EE;&#x9898;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;So calling mark_page_accessed not only adds extra lru or PG_referenced manipulations for pages that are already going to have pte_young ptes anyway, but it also adds these references which are difficult to work with from the context of vma specific references (eg. MADV_SEQUENTIAL pte_young may not wish to contribute to the page being referenced).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x53CD;&#x6B63;&#x5C31;&#x8981;&#x7ED9;pte&#x7F6E;&#x4F4D;young&#x4E86;, &#x5C31;&#x4E0D;&#x8981;&#x518D;&#x5F04;&#x4E2A;&#x989D;&#x5916;&#x7684;page flag&#x4E86;. &#x800C;&#x4E14;&#x8FD8;&#x4F1A;&#x7ED9; &#x8C01;&#x8C01;&#x8C01; &#x6DFB;&#x5835;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Then, simply doing SetPageReferenced when zapping a pte and finding it is young, is not a really good solution either. SetPageReferenced does not correctly promote the page to the active list for example. So after removing mark_page_accessed from the fault path, several mmap()+touch+munmap() would have a very different result from several read(2) calls for example, which is not really desirable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x4E4B;&#x524D;&#x7684;&#x5904;&#x7406;, &#x5728;&#x7B2C;2&#x56DE;&#x7684; munmap&#x4F1A;&#x628A;&#x4E0A;&#x56DE;&#x7684;&#x4FE1;&#x606F;&#x4E22;&#x5931;&#x6389;, &#x6545;&#x6D3B;&#x8DC3;&#x5EA6;&#x548C; read&#x7684;&#x7ED3;&#x679C;&#x4E0D;&#x540C;.&lt;/p&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;4.1 unmap&#x65F6;&#x7684;&#x5904;&#x7406;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;linux-3.10.86/mm/memory.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zap_pte_range
{
    if (PageAnon(page))
        ...
    else{
        if (pte_present(ptent)) {
                if (pte_young(ptent) &amp;amp;&amp;amp;
                    likely(!VM_SequentialReadHint(vma)))
                    /*&#x95EE;&#x9898;:&#x6211;&#x4EEC;&#x662F;&#x5728;unmap, &#x4E3A;&#x4F55;&#x8981;mark accessed?*/
                    mark_page_accessed(page);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x6211;&#x4EEC;&#x662F;&#x5728;unmap, &#x4E3A;&#x4F55;&#x8981;mark accessed?&lt;br&gt;
&#x7B54;:&#x7531;&#x4E8E;unmap, &#x5BFC;&#x81F4;&#x539F;&#x5148;&#x901A;&#x8FC7;young&#x6807;&#x8BB0;&#x7684;&#x6D3B;&#x8DC3;&#x5EA6;&#x4FE1;&#x606F;&#x5C06;&#x4F1A;&#x6D88;&#x5931;, &#x6545;&#x6539;&#x7528;mark_page_accessed&#x6765;&#x53CD;&#x6620;&#x8BE5;&#x4FE1;&#x606F;.&lt;/p&gt;

&lt;p&gt;&#x8FD9;&#x662F; &#x975E;if (PageAnon(page))&#x7684;&#x60C5;&#x51B5;, &#x8FD9;&#x6837;&#x5373;&#x4F7F;&#x8131;&#x79BB;pte, &#x8FD8;&#x53EF;&#x901A;&#x8FC7;radix tree&#x627E;&#x5230;&#x8BE5;page,  &#x8FDB;&#x800C;&#x4F7F;&#x7528;&#x4E4B;&#x524D;&#x7684;page&#x5185;&#x5BB9;, &#x8FD9;&#x6837;, &#x6807;&#x8BB0;&#x6D3B;&#x8DC3;&#x5EA6;&#x624D;&#x6709;&#x610F;&#x4E49;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>page reclaim 04:&#x53C2;&#x6570;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_04_parameter</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;p&gt;&#x672A;&#x5F00;&#x542F;CONFIG_MEMCG, CONFIG_SWAP.&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. scan_control&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/vmscan.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct scan_control {

    /* Incremented by the number of inactive pages that were scanned */
    unsigned long nr_scanned;

    /* How many pages shrink_list() should reclaim 
    &#x95EE;&#x9898;:nr_to_reclaim&#x548C;nr_scanned&#x7684;&#x5173;&#x7CFB;?
    &#x7B54;:nr_to_reclaim&#x662F;&#x4E2A;setting data, nr_reclaimed&#x662F;runtime date.
    &#x901A;&#x5E38;&#x662F;&#x5148;&#x7ED9;struct scan_control sc&#x8BBE;&#x7F6E;&#x597D;&#x8FD9;&#x4E2A;&#x76EE;&#x6807;, 
    &#x7136;&#x540E;&#x542F;&#x52A8;&#x56DE;&#x6536;. 
    &#x5728; sum of shrink_list() &amp;gt; nr_to_reclaim&#x540E;&#x4E2D;&#x65AD;&#x56DE;&#x6536;, see shrink_lruvec() or do_try_to_free_pages().
    */
    unsigned long nr_to_reclaim;

    /*
    &#x8FD9;&#x91CC;&#x7684;may&#x7C7B;&#x4F3C;may I ..., may&#x7684;&#x610F;&#x601D;&#x662F; &#x662F;&#x5426;&#x53EF;&#x4EE5;, &#x662F;&#x5426;&#x5141;&#x8BB8;
    */
    int may_writepage;

    /*
    [Understanding the Linux Kernel, 3rd Edition]p695
    Lower priority implies scanning more pages.
    */
    int priority;

};

get_scan_count
{
        size = get_lru_size(lruvec, lru);
        scan = size &amp;gt;&amp;gt; sc-&amp;gt;priority;
        //&#x626B;&#x63CF;&#x7684;&#x91CF; &#x4E0E; list&#x7684;&#x5927;&#x5C0F; &#x6210;&#x6BD4;&#x4F8B;
}

shrink_lruvec
|--//1. &#x6839;&#x636E;&#x4F18;&#x5148;&#x7EA7;&#x7B49; &#x7ED9;&#x6570;&#x7EC4;nr[]&#x8D4B;&#x503C;
|--get_scan_count(lruvec, sc, nr); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. watermark &lt;/h4&gt;&lt;/h1&gt;

&lt;h2 id="toc_2"&gt;&lt;h4&gt;2.1 low watermark&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x53D1;&#x73B0;&#x4F4E;&#x4E8E;low watermark&#x65F6;, &#x5524;&#x9192;kswapd:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__alloc_pages_nodemask
|-- int alloc_flags = ALLOC_WMARK_LOW|ALLOC_CPUSET;
|--page = get_page_from_freelist(,alloc_flags,)
|--if (unlikely(!page)) 
|   |--__alloc_pages_slowpath()
|   |   |--if (!(gfp_mask &amp;amp; __GFP_NO_KSWAPD))
|   |   |   |--wake_all_kswapd(order, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_3"&gt;&lt;h4&gt;2.2 high watermark&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x8FBE;&#x5230;high watermark&#x65F6;&#x505C;&#x6B62;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zone_balanced(, balance_gap:0,)  //&#x7B80;&#x5316;&#x95EE;&#x9898;, &#x5FFD;&#x7565;CONFIG_COMPACTION
|--free &amp;gt; high_wmark_pages+balance_gap 
|-- and ...

pgdat_balanced //&#x7B80;&#x5316;&#x95EE;&#x9898;, &#x53EA;&#x770B;order&#x4E3A;0&#x7684;&#x60C5;&#x51B5;
{
    if (zone_balanced(..,balance_gap:0, ))
        return true
}


kswapd -&amp;gt; balance_pgdat
{
    ...
            shrink_zone
            shrink_slab

    if (pgdat_balanced(...))
        break;      /* kswapd: all done */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;2.3 min_free_kbytes&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;linux-3.10.86/Documentation/sysctl/vm.txt&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;min_free_kbytes:&lt;/p&gt;

&lt;p&gt;This is used to force the Linux VM to keep a minimum number of kilobytes free.  The VM uses this number to compute a watermark[WMARK_MIN] value for each lowmem zone in the system. Each lowmem zone gets a number of reserved free pages based proportionally on its size.&lt;/p&gt;

&lt;p&gt;Some minimal amount of memory is needed to satisfy PF_MEMALLOC allocations; if you set this to lower than 1024KB, your system will become subtly broken, and prone to deadlock under high loads.&lt;/p&gt;

&lt;p&gt;Setting this too high will OOM your machine instantly. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;linux-3.10.86/mm/vmscan.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pfmemalloc_watermark_ok
{
    pfmemalloc_reserve += min_wmark_pages(zone);
    wmark_ok = free_pages &amp;gt; pfmemalloc_reserve / 2;

    if (!wmark_ok &amp;amp;&amp;amp; waitqueue_active(&amp;amp;pgdat-&amp;gt;kswapd_wait)) {
        ...
        /*&#x5982;&#x679C;&#x7761;&#x7720;&#x4E2D;(waitqueue_active()), &#x5219;&#x5524;&#x9192;kswapd*/
        wake_up_interruptible(&amp;amp;pgdat-&amp;gt;kswapd_wait);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="https://lwn.net/Articles/422291/"&gt;https://lwn.net/Articles/422291/&lt;/a&gt;&lt;br&gt;
The thresholds kswapd/direct reclaim starts(ends) depend on
watermark[min,low,high] and currently all watermarks are set
based on min_free_kbytes. min_free_kbytes is the amount of
free memory that Linux VM should keep at least.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/mm/page_alloc.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__setup_per_zone_wmarks
{

    zone-&amp;gt;watermark[WMARK_MIN] = ...
    zone-&amp;gt;watermark[WMARK_LOW]  = min_wmark_pages(zone) + (tmp &amp;gt;&amp;gt; 2);
    zone-&amp;gt;watermark[WMARK_HIGH] = min_wmark_pages(zone) + (tmp &amp;gt;&amp;gt; 1);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>page reclaim 02:&#x5B9E;&#x73B0;</title>
      <link>https://awakening-fong.github.io/posts/mm/reclaim_02_implement</link>
      <pubDate>2017-02-07</pubDate>
      <description>&lt;p&gt;&#x672C;&#x6587;&#x7B80;&#x5316;&#x63CF;&#x8FF0;, &#x5FFD;&#x7565;compound page, &#x5FFD;&#x7565;HUGEPAGE, &#x672A;&#x5F00;&#x542F;CONFIG_MEMCG, &#x672A;&#x5F00;&#x542F;CONFIG_SWAP.
&#x82E5;&#x65E0;&#x7279;&#x522B;&#x8BF4;&#x660E;, &#x672C;&#x6587;&#x4EC5;&#x8BA8;&#x8BBA;ARM&#x4F53;&#x7CFB;&#x7684;&#x60C5;&#x51B5;.&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x6570;&#x636E;&#x7ED3;&#x6784;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;per zone : active list, inactive list&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct zone {
    struct lruvec       lruvec;
};

struct lruvec {
    struct list_head lists[NR_LRU_LISTS];
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;per node :kswapd  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kswapd_init -&amp;gt; for_each_node_state(nid, N_MEMORY) kswapd_run(nid)
kswapd_run -&amp;gt; pgdat-&amp;gt;kswapd = kthread_run(kswapd, pgdat, &amp;quot;kswapd%d&amp;quot;, nid);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;per cpu  :lru cache, &#x4E5F;&#x5C31;&#x662F;struct pagevec&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x8C03;&#x7528;&#x903B;&#x8F91;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4F55;&#x65F6;&#x8C03;&#x7528;  shrink_active_list, &#x4F55;&#x65F6;&#x8C03;&#x7528; shrink_inactive_list ?&lt;/p&gt;

&lt;p&gt;&#x8C03;&#x7528;&#x8DEF;&#x5F84;:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_zones
|--shrink_zone -&amp;gt; shrink_lruvec
|    |--for_each_evictable_lru //&#x987A;&#x5E8F;&#x662F;INACTIVE_xx, ACTIVE_xx, ..
|    |  |--shrink_list
|    |  |   |--if active list, shrink_active_list 
|    |  |   |--else shrink_inactive_list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7531;&#x4E8E; shrink_active_list &#x5B58;&#x5728;&#x5C06;page&#x6DFB;&#x52A0;&#x5230;inactive list&#x7684;&#x60C5;&#x51B5; , &#x82E5;&#x4E4B;&#x540E;&#x518D; shrink_inactive_list &#x7684;&#x8BDD;, &#x5C31;&#x662F;&#x53CC;&#x91CD;&#x6253;&#x51FB;&#x4E86;,  &#x6545;shrink_lruvec()&#x4F1A; &#x5148;&#x8C03;&#x7528; shrink_inactive_list, &#x540E;&#x8C03;&#x7528;shrink_active_list.   &lt;/p&gt;

&lt;p&gt;&#x6211;&#x4EEC;&#x5E76;&#x4E0D;&#x4F1A;&#x603B;&#x662F;shrink_active_list, &#x53EA;&#x6709;&#x5728;inactive list&#x7684;page&#x76F8;&#x5BF9;&#x6BD4;&#x8F83;&#x5C11;&#x65F6;&#x624D;&#x4F1A;shrink_active_list.&lt;/p&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x5982;&#x679C;shrink_inactive_list&#x4E2D;&#x628A;page&#x79FB;&#x5230;active list, &#x90A3;&#x4E48;, shrink_active_list&#x4F1A;&#x4E0D;&#x4F1A;&#x53C8;&#x628A;&#x8BE5;page&#x632A;&#x5230; inactive list?&lt;br&gt;
&#x7B54;:&#x6211;&#x4EEC;&#x662F;&#x65B0;&#x6DFB;&#x52A0;&#x5230;active list&#x7684;, &#x961F;&#x5217;&#x662F;FIFO&#x7684;&#x65B9;&#x5F0F;, &#x6240;&#x4EE5;, &#x53EA;&#x8981;nr_to_scan&#x4E0D;&#x662F;&#x5F88;&#x5927;, &#x5C31;&#x53EF;&#x4EE5;&#x907F;&#x514D;&#x77ED;&#x65F6;&#x95F4;&#x5185;&#x88AB;&#x626B;&#x63CF;&#x5230;.&lt;/p&gt;

&lt;p&gt;&#x7531;&#x4E8E;page&#x88AB;&#x56DE;&#x6536;, &#x76F8;&#x5173;&#x9875;&#x8868;&#x9879;&#x9700;&#x8981;&#x5904;&#x7406;, &#x8FD9;&#x90E8;&#x5206;&#x9700;&#x8981;rmap, &#x672C;&#x6587;&#x7565;&#x53BB;.&lt;/p&gt;

&lt;h2 id="toc_2"&gt;&lt;h4&gt;3. shrink_active_list&lt;/h4&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;shrink_active_list
|--lru_add_drain
|--isolate_lru_pages(, , &amp;amp;l_hold, )
|    |--__isolate_lru_page  isolate&#x662F;&#x8BA9;page&#x8FD8;&#x5446;&#x5728;lru&#x4E0A;, &#x4F46;&#x6E05;&#x6389;PG_lru
|    |--list_move(&amp;amp;page-&amp;gt;lru, l_hold);  &#x632A;&#x5230;&#x94FE;&#x8868;(list_head) l_hold
|--for each page in struct list_head l_hold
|    |--page_referenced
|    |    |--page_referenced_file -&amp;gt; page_referenced_one -&amp;gt; ptep_clear_flush_young_notify -&amp;gt; pte_mkold
|    |    |--page_test_and_clear_young  ARM&#x4F53;&#x7CFB;&#x662F;&#x7A7A;&#x64CD;&#x4F5C;
|    |--ClearPageActive  and  list_add(&amp;amp;page-&amp;gt;lru, &amp;amp;l_inactive);
|    |--or list_add(&amp;amp;page-&amp;gt;lru, &amp;amp;l_active) //&#x4E0D;&#x8BA8;&#x8BBA;
|--move_active_pages_to_lru(lruvec, &amp;amp;l_active, &amp;amp;l_hold, lru);
|--move_active_pages_to_lru(lruvec, &amp;amp;l_inactive, &amp;amp;l_hold, lru - LRU_ACTIVE);
|    |--&#x5C06;l_inactive&#x7684;page move&#x5230; lruvec-&amp;gt;lists[lru - LRU_ACTIVE]&#x4E2D;,
|    |--put page, &#x5982;&#x679C;&#x4E3A;zero, &#x5219;__ClearPageActive + &#x4ECE;lru&#x4E2D;&#x79FB;&#x9664; + &#x6DFB;&#x52A0;&#x5230;l_hold&#x4E2D;, &#x5F85;&#x540E;&#x7EED;&#x6267;&#x884C;free 
|--free_hot_cold_page_list(&amp;amp;l_hold, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E0A;&#x9762;&#x7684;&#x6D41;&#x7A0B;&#x5FFD;&#x7565;Compound page. 
&#x6240;&#x4EE5;, &#x5E38;&#x89C1;&#x7684;&#x6D41;&#x7A0B;&#x662F;: &#x4ECE;active list&#x4E2D;&#x79FB;&#x9664;, &#x6DFB;&#x52A0;&#x5230;inactive list&#x4E2D;. &#x5982;&#x679C;page count&#x4E3A;0, &#x5C31;&#x4E0D;&#x5FC5;&#x6DFB;&#x52A0;&#x5230;list&#x4E2D;, &#x800C;&#x662F;free&#x6389;page.
&#x5BF9;&#x4E8E;&#x53EF;&#x6267;&#x884C;&#x6587;&#x4EF6;&#x7684;page, &#x6839;&#x636E;&#x60C5;&#x51B5;&#x53EF;&#x91CD;&#x65B0;&#x653E;&#x5165;active list.&lt;/p&gt;

&lt;p&gt;&#x5173;&#x4E8E;move_active_pages_to_lru&#x4E2D;put&#x540E;, page count&#x4E3A;0:&lt;br&gt;
linux-3.10.86/mm/vmscan.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;move_active_pages_to_lru
{

        /*
        &#x5728;buddy system&#x4E2D;&#x7684;page&#x7684;_count&#x4E3A;0.
        &#x4ECE;buddy system&#x53D6;&#x4E0B;, page&#x4E3A;1.
        &#x5F53;&#x524D;page&#x8FD8;&#x88AB;isolate_lru_pages get.
        &#x6240;&#x4EE5;, &#x5982;&#x679C;if (put_page_testzero(page))&#x6210;&#x7ACB;, &#x90A3;&#x5C31;&#x53EF;&#x80FD;&#x53D1;&#x751F;&#x4E0B;&#x9762;&#x7684;&#x5E8F;&#x5217;:
        alloc page
        isolate_lru_pages
        free page
        put_page_testzero
        */
        if (put_page_testzero(page)) {

            list_add(&amp;amp;page-&amp;gt;lru, pages_to_free);

        }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. shrink_inactive_list&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;//&#x5FFD;&#x7565;Compound Page&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_inactive_list(..., enum lru_list lru)
|--lru_add_drain
|--isolate_lru_pages(, &amp;amp;page_list, ) //&#x6311;&#x51FA;&#x7684;page&#x653E;&#x5165;&#x94FE;&#x8868;page_list
|--shrink_page_list(&amp;amp;page_list, ) //&#x5C1D;&#x8BD5;reclaim, &#x6839;&#x636E;&#x60C5;&#x51B5;&#x53EF;&#x80FD;&#x7ED9;page&#x8BBE;&#x7F6E;PG_active.
|    |--VM_BUG_ON(PageActive(page));
|    |--page_check_references //&#x5224;&#x65AD;&#x662F;&#x5426;&#x8FDB;&#x884C;reclaim, &#x662F;&#x5426;&#x8BBE;&#x7F6E;active&#x7B49;
|    |  |--page_referenced
|    |--case PAGEREF_ACTIVATE:  ...
|    |--case PAGEREF_KEEP: ...
|    |--case PAGEREF_RECLAIM or PAGEREF_RECLAIM_CLEAN: ...
|--/*&#x5BF9;page_list&#x4E2D;&#x7684;page, &#x6839;&#x636E;page flag, &#x5C06;&#x5176;&#x653E;&#x5165;&#x5BF9;&#x5E94;lru. &#x82E5;-&amp;gt;_count put&#x540E;&#x4E3A;0, &#x5219;&#x653E;&#x5165;&#x94FE;&#x8868;, &#x540E;&#x7EED;free&#x6389;*/
|--putback_inactive_pages(, &amp;amp;page_list);
|-- /*&#x73B0;page_list&#x4E2D;&#x5B58;&#x653E;&#x7684;&#x662F; putback_inactive_pages()&#x68C0;&#x6D4B;put_page_testzero()&#x6210;&#x7ACB;&#x7684;page*/
|--free_hot_cold_page_list(&amp;amp;page_list, )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;4.1 shrink_page_list&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;[Professional Linux Kernel Architecture] p1072&lt;br&gt;
shrink_page_list sends the page to the associated backing store (which means the page is synchronized, swapped out, or discarded)&lt;/p&gt;

&lt;p&gt;[Professional Linux Kernel Architecture]p1074&lt;br&gt;
shrink_page_list returns the number of pages for which it succeeded to initiate writeout.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shrink_page_list
{

    if (PageWriteback(page)) {

        &#x5982;&#x679C;&#x5141;&#x8BB8;&#x7B49;&#x5F85;&#x7684;&#x8BDD;, wait_on_page_writeback(page);
    }

    &#x82E5;&#x53EF;&#x56DE;&#x6536;, try_to_unmap

    if (PageDirty(page)) {
    //&#x8F83;&#x5C11;&#x53D1;&#x751F;, &#x8FD9;&#x91CC;&#x4E0D;&#x8BA8;&#x8BBA;
    }

    if (page_has_private(page)) {
    //&#x4E0D;&#x662F;&#x91CD;&#x70B9;, &#x8FD9;&#x91CC;&#x4E0D;&#x8BA8;&#x8BBA;
    }

    free_hot_cold_page

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_5"&gt;&lt;h4&gt;5. &#x5E38;&#x89C1;&#x95EE;&#x9898;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;direct reclaim&#x53EF;&#x80FD;&#x5BFC;&#x81F4;&#x5806;&#x6808;overflow&#x7684;&#x95EE;&#x9898;&lt;br&gt;
mm: vmscan: do not writeback filesystem pages in direct reclaim
&lt;a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ee72886d8ed5d9de3fa0ed3b99a7ca7702576a96"&gt;https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ee72886d8ed5d9de3fa0ed3b99a7ca7702576a96&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x7684;ASID (Address Space ID)</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_asid</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;
&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2; http://blog.163.com/awaken_ing/blog/static/1206131972015112011286335
&lt;/p&gt;

&lt;p&gt;&#x5E73;&#x53F0;:ARM Versatile Express for Cortex-A9 (ARMv7)&lt;br&gt;
 # CONFIG_ARM_LPAE is not set, &#x4E5F;&#x5C31;&#x662F;&#x4F7F;&#x7528;Short-descriptor&#x683C;&#x5F0F;, ASID&#x5B58;&#x50A8;&#x5728;CONTEXTIDR&#x7684;&#x4F4E;8 bit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;31                         7          0
+-------------------------+-----------+
|      PROCID             |   ASID    |
+-------------------------+-----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x9875;&#x8868;&#x9879;&#x4E2D; nG == 1&#x65F6;, &#x8FD9;&#x4E2A;&#x9875;&#x8868;&#x9879;&#x4FE1;&#x606F;&#x5C31;&#x662F; non-global, &#x6216;&#x8005;&#x8BF4; process-specific, &#x5BF9;&#x5E94;&#x7684;TLB&#x4E2D;&#x5C31;&#x4F1A;&#x6709;ASID&#x4FE1;&#x606F;, &#x6267;&#x884C;&#x865A;&#x62DF;&#x5730;&#x5740;&#x5230;&#x7269;&#x7406;&#x5730;&#x5740;&#x8F6C;&#x6362;&#x65F6;, ASID&#x4E5F;&#x9700;&#x8981;&#x53C2;&#x4E0E;&#x8BE5;&#x8FC7;&#x7A0B;.&lt;/p&gt;

&lt;p&gt;&#x7528;&#x6237;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x7684;&#x9875;&#x8868;&#x624D;&#x4F1A;&#x8BBE;&#x7F6E;nG&#x6807;&#x5FD7; (&#x5185;&#x6838;&#x5730;&#x5740;&#x7684;&#x4E00;&#x90E8;&#x5206;&#x5730;&#x5740;&#x8303;&#x56F4;&#x4F7F;&#x7528;TLB lockdown&#x6BD4;&#x8F83;&#x5408;&#x9002;):
linux-3.10.86/arch/arm/include/asm/pgtable.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void set_pte_at(struct mm_struct *mm, unsigned long addr, 
                  pte_t *ptep, pte_t pteval) 
{ 
...
    if (addr &amp;lt; TASK_SIZE &amp;amp;&amp;amp; pte_present_user(pteval)) { 
... 
        ext |= PTE_EXT_NG; 
    } 
... 
    set_pte_ext(ptep, pteval, ext); 
}

set_pte_at -&amp;gt; set_pte_ext -&amp;gt; cpu_v7_set_pte_ext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;arm linux&#x4E2D;&#x901A;&#x8FC7;&#x8BBE;&#x7F6E;CONTEXTIDR, &#x8FDB;&#x800C;&#x8BBE;&#x7F6E;ASID, &#x76F8;&#x5173;&#x4EE3;&#x7801;&#x4E3A;:
linux-3.10.86/arch/arm/mm/proc-v7-2level.S&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ENTRY(cpu_v7_switch_mm) 
... 
mcr    p15, 0, r1, c13, c0, 1        @ set context ID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8C03;&#x7528;&#x5173;&#x7CFB;&#x4E3A;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context_switch() -&amp;gt;switch_mm() -&amp;gt; check_and_switch_context(struct mm_struct *mm, struct task_struct *tsk) -&amp;gt; cpu_switch_mm() -&amp;gt; cpu_v7_switch_mm(pgd_t * pgd, struct mm_struct *mm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux&#x628A;ASID&#x5B58;&#x50A8;&#x5728;mm-&amp;gt;context.id&#x7684;&#x4F4E;8&#x4F4D; (D7:D0).&lt;/p&gt;

&lt;p&gt;&#x65B0;&#x521B;&#x5EFA;&#x7684;&#x975E;&#x5185;&#x6838;&#x7EBF;&#x7A0B; (&#x5185;&#x6838;&#x7EBF;&#x7A0B;&#x4E0D;&#x4F1A;&#x8C03;&#x7528;&#x5230;dup_mm), &#x521D;&#x59CB;&#x5316;ASID&#x4E3A;0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;copy_mm -&amp;gt; dup_mm -&amp;gt; init_new_context
#define init_new_context(tsk,mm)   ({ atomic64_set(&amp;amp;mm-&amp;gt;context.id, 0); 0; })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5230;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#x7684;&#x65F6;&#x5019;&#x624D;&#x771F;&#x6B63;&#x5F00;&#x59CB;&#x7ED9;ASID&#x8D4B;&#x503C;, &#x5E76;&#x8BBE;&#x7F6E;CONTEXTIDR&#x5BC4;&#x5B58;&#x5668;.&lt;/p&gt;

&lt;p&gt;&#x6709;&#x5206;&#x914D;, &#x5C31;&#x8BE5;&#x6709;&#x56DE;&#x6536;, &#x8FD9;&#x4E5F;&#x662F;&#x4F7F;&#x7528;bitmap&#x6765;&#x7BA1;&#x7406;ASID, &#x800C;&#x4E0D;&#x662F;asid++&#x7684;&#x65B9;&#x5F0F;&#x7684;&#x539F;&#x56E0;. ASID&#x7684;&#x5206;&#x914D;&#x662F;&#x901A;&#x8FC7;bitmap&#x53D8;&#x91CF;asid_map&#x6765;&#x8BB0;&#x5F55;&#x7684;. set bit&#x7684;&#x64CD;&#x4F5C;&#x5728;new_context()&#x4E2D;&#x53EF;&#x4EE5;&#x627E;&#x5230;. &#x67E5;&#x627E;&#x5BF9;&#x8BE5;&#x53D8;&#x91CF;&#x7684;clear bit&#x64CD;&#x4F5C;, &#x8FDB;&#x7A0B;&#x9000;&#x51FA;&#x65F6;, &#x672C;&#x5E94;&#x6709;&#x8BE5;&#x52A8;&#x4F5C;(&#x6E05;asid_map&#x4E2D;&#x8BE5;&#x8FDB;&#x7A0B;&#x6240;&#x5BF9;&#x5E94;&#x7684;bit), &#x4F46;&#x5F88;&#x9057;&#x61BE;, &#x6CA1;&#x6709;&#x627E;&#x5230;, &#x5F00;&#x53D1;&#x4EBA;&#x5458;&#x5077;&#x61D2;&#x4E86;?&lt;/p&gt;

&lt;p&gt;&#x7531;&#x4E8E;ASID&#x53EA;&#x6709;8bit, &#x8303;&#x56F4;&#x4E3A;0~0xff, &#x5F53;&#x8FD9;&#x4E9B;&#x503C;&#x5206;&#x914D;&#x5B8C;&#x540E;, &#x5C31;&#x9700;&#x8981;flush TLB, &#x540C;&#x65F6;&#x5BF9;generation&#x52A0;1, &#x7136;&#x540E;&#x91CD;&#x65B0;&#x5F00;&#x59CB;&#x5206;&#x914D;ASID. generation&#x4E3A;mm-&amp;gt;context.id&#x7684;&#x9AD8;24+32&#x4F4D;(D63:D8), &#x8FD9;&#x6837;, &#x540E;&#x7EED;&#x518D;&#x8C03;&#x5EA6;&#x5230;&#x8FD9;&#x4E2A;&#x8FDB;&#x7A0B;&#x65F6;, &#x5C31;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5224;&#x65AD;generation&#x662F;&#x5426;&#x53D8;&#x5316;&#x4E86;, &#x6765;&#x77E5;&#x9053; mm-&amp;gt;context.id&#x4E2D;&#x7684;ASID&#x662F;&#x5426;&#x8FD8;&#x6709;&#x6548;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>&#x5173;&#x4E8E;arm linux&#x7684;map_io</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_map_io</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt; &#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2; http://blog.163.com/awaken_ing/blog/static/1206131972016226674429
&lt;/p&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4E3B;&#x8981;&#x6D41;&#x7A0B;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5E73;&#x53F0;:versatilepb ARM Versatile/PB (ARM926EJ-S) &#x5185;&#x6838;&#x7248;&#x672C;2.6.35.7&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paging_init
|--devicemaps_init
|   |--from VMALLOC_END, pmd_clear(pmd_off_k(addr))
|   |--mdesc-&amp;gt;map_io() =&amp;gt; versatile_map_io  
|   |   |--iotable_init
|   |   |   |--create_mapping
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x4E3A;&#x4F55;&#x662F; MT_DEVICE&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-2.6.35.7/arch/arm/mach-versatile/core.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void __init versatile_map_io(void)
{
    iotable_init(versatile_io_desc, ARRAY_SIZE(versatile_io_desc));
}

static struct map_desc versatile_io_desc[] __initdata = {
    {
        ...
        .type       = MT_DEVICE
    },
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x662F; MT_DEVICE, &#x800C;&#x4E0D;&#x662F; MT_UNCACHED, why?&lt;/p&gt;

&lt;p&gt;MT_DEVICE&#x7C7B;&#x578B;&#x548C; MT_UNCACHED &#x7684;&#x533A;&#x522B;&#x5728; .prot_pte &#x548C; .prot_sect &#x4E0A;.&lt;/p&gt;

&lt;p&gt;&#x770B;&#x770B; .prot_pte &#x548C; .prot_sect &#x7684;&#x4F5C;&#x7528;?&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;2.1 .prot_pte &#x7528;&#x9014;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4F7F;&#x7528;&#x5230; .prot_pte &#x7684;&#x5730;&#x65B9;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alloc_init_pte
{
    set_pte_ext(pte, pfn_pte(pfn, type-&amp;gt;prot_pte), 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x7B49;&#x6548;&#x4E8E;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cpu_arm926_set_pte_ext(pte, pfn_pte(pfn, type-&amp;gt;prot_pte), 0);
#define pfn_pte(pfn,prot)    (__pte(((pfn) &amp;lt;&amp;lt; PAGE_SHIFT) | pgprot_val(prot)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpu_arm926_set_pte_ext&#x5C06;&#x4E3B;&#x8981;&#x5DE5;&#x4F5C;&#x4EA4;&#x7ED9; armv3_set_pte_ext, &#x8FD9;&#x91CC;&#x5E76;&#x6CA1;&#x6709;&#x5224;&#x65AD; L_PTE_MT_DEV_SHARED &#x6216;&#x8005; L_PTE_SHARED, &#x6240;&#x4EE5;, &#x5BF9;&#x4E8E;&#x786C;&#x4EF6;&#x9875;&#x8868;, &#x6DFB;&#x52A0;&#x4E0A;&#x4E5F;&#x6CA1;&#x6709;&#x5F71;&#x54CD;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;2.2 .prot_sect &#x7528;&#x9014;&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;alloc_init_section
{
pmd_t *pmd = pmd_offset(pgd, addr);
...&#x5982;&#x679C; &#x521B;&#x5EFA;&#x7684;&#x662F; section.
*pmd = phys | type-&amp;gt;prot_sect;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, .prot_sect &#x7528;&#x6765;&#x5199;&#x5230;&#x7269;&#x7406;&#x9875;&#x8868;&#x53BB;&#x7684;, &#x4E0D;&#x50CF;&#x4E8C;&#x7EA7;&#x9875;&#x8868;, &#x8FD9;&#x91CC;linux&#x4E0D;&#x9700;&#x8981;&#x8F6C;&#x6362;&#x5565;&#x7684;.&lt;/p&gt;

&lt;p&gt;MT_DEVICE&#x7684; .prot_sect = PROT_SECT_DEVICE | PMD_SECT_S,&lt;/p&gt;

&lt;p&gt;&#x7B49;&#x6548;&#x4E8E; PMD_TYPE_SECT|PMD_SECT_AP_WRITE | PMD_SECT_S MT_UNCACHED&#x7684;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.prot_sect = PMD_TYPE_SECT | PMD_SECT_XN,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;build_mem_type_table()&#x4E2D;&#x4F1A;&#x6839;&#x636E;arm&#x7248;&#x672C;, &#x5BF9; .prot_sect &#x8FDB;&#x884C;&#x4FEE;&#x6B63;, &#x6BD4;&#x5982;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build_mem_type_table
{
    if (cpu_arch &amp;lt; CPU_ARCH_ARMv6 ...)
        mem_types[i].prot_sect &amp;amp;= ~PMD_SECT_S;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x5C31;&#x4E0D;&#x8D70;&#x8BFB;&#x4EE3;&#x7801;&#x4E86;, &#x76F4;&#x63A5;&#x6253;&#x5370;&#x7ED3;&#x679C;.&lt;/p&gt;

&lt;p&gt;&#x5F80;build_mem_type_table()&#x4E2D;&#x6DFB;&#x52A0;&#x6253;&#x5370;&#x540E;(&#x672A;&#x6DFB;&#x52A0;&#x4E0A;domain), &#x6709;&lt;/p&gt;

&lt;p&gt;MT_DEVICE &#x7684; .prot_sect &#x4E3A; 0x412&lt;/p&gt;

&lt;p&gt;MT_UNCACHED&#x7684; .prot_sect &#x4E3A; 0x12&lt;/p&gt;

&lt;p&gt;C(D3)&#x548C;B(D2) &#x90FD;&#x662F;&#x5173;&#x95ED;&#x7684;.&lt;/p&gt;

&lt;p&gt;&#x4E5F;&#x5C31;&#x662F;&#x591A;&#x4E86;&#x4E2A; PMD_SECT_AP_WRITE&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define PMD_SECT_AP_WRITE (1 &amp;lt;&amp;lt; 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5148;&#x68C0;&#x67E5;domain, &#x5982;&#x679C;&#x4E3A;01(Client), &#x5219;&#x63A5;&#x7740;&#x68C0;&#x67E5;AP bits.&lt;/p&gt;

&lt;p&gt;&lt;img src="/assets/media/ARM_access_permission.jpg"&gt;&lt;/p&gt;

&lt;p&gt;&#x5982;&#x679C;&#x521B;&#x5EFA;&#x7684;&#x662F;section&#x7684;&#x8BDD;, &#x7C7B;&#x578B;MT_UNCACHED, &#x6700;&#x591A;&#x53EA;&#x80FD;&#x591F; read-only, &#x4E0D;&#x7B26;&#x5408;&#x8981;&#x6C42;, &#x6545;&#x4E0D;&#x4F7F;&#x7528;.&lt;/p&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;3. &#x865A;&#x62DF;&#x5730;&#x5740;&#x6307;&#x5B9A;&#x6210;&#x5565;&#x597D;&#x5462;?&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;create_mapping
{
    if ((md-&amp;gt;type == MT_DEVICE || md-&amp;gt;type == MT_ROM) &amp;amp;&amp;amp;
        md-&amp;gt;virtual &amp;gt;= PAGE_OFFSET &amp;amp;&amp;amp; md-&amp;gt;virtual &amp;lt; VMALLOC_END) {
        printk(KERN_WARNING &amp;quot;BUG: mapping for 0x%08llx at 0x%08lx &amp;quot;
               &amp;quot;overlaps vmalloc space\n&amp;quot;,
               __pfn_to_phys((u64)md-&amp;gt;pfn), md-&amp;gt;virtual);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5982;&#x679C;&#x662F;MT_DEVICE, &#x90A3;&#x4E48;, &#x4E0D;&#x592A;&#x5EFA;&#x8BAE;&#x6620;&#x5C04;(&#x4E0D;&#x662F;&#x7981;&#x6B62;, &#x56E0;&#x4E3A;&#x53EA;&#x662F;&#x6253;&#x5370;&#x4E86;warning&#x800C;&#x5DF2;)&#x5230; 3G~VMALLOC_END &#x4E4B;&#x95F4;. &#x5EFA;&#x8BAE;&#x6211;&#x4EEC;&#x6620;&#x5C04;&#x5230;vmalloc&#x4E0E;DMA&#x4E4B;&#x95F4;&#x7684;gap&#x5185; (vmalloc&#x548C;DMA&#x95F4;&#x7684;gap&#x53EF;&#x4E0D;&#x662F;8MB).&lt;/p&gt;

&lt;p&gt;&#x770B;&#x4E0B;versatile&#x7684;&#x6620;&#x5C04;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;. linux-2.6.35.7/arch/arm/mach-versatile/core.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static struct map_desc versatile_io_desc[] __initdata = {
    {
        .virtual    =  IO_ADDRESS(VERSATILE_SYS_BASE),
        .pfn        = __phys_to_pfn(VERSATILE_SYS_BASE),
        .length        = SZ_4K,
        .type        = MT_DEVICE
    },

#define VERSATILE_SYS_BASE   0x1000 0000
#define IO_ADDRESS(x)  (((x) &amp;amp; 0x0fff ffff) 
                       + (((x) &amp;gt;&amp;gt; 4) &amp;amp; 0x0f00 0000) 
                       + 0xf000 0000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x8BA1;&#x7B97;&#x51FA;&#x6765;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x4E3A; 0xf100 0000.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Virtual kernel memory layout:
...
    DMA     : 0xffc00000 - 0xffe00000   (   2 MB)
    vmalloc : 0xc8800000 - 0xd8000000   ( 248 MB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6B63;&#x662F;&#x5904;&#x4E8E;vmalloc&#x4E0E;DMA&#x4E4B;&#x95F4;&#x7684;gap&#x5185;. &lt;/p&gt;
</description>
    </item>
    <item>
      <title>arm linux&#x591A;&#x6838;&#x540C;&#x65F6;&#x83B7;&#x53D6;&#x8BFB;&#x5199;&#x9501;, &#x4F1A;&#x6B7B;&#x5FAA;&#x73AF;&#x5417;, &#x8FD8;&#x662F;&#x90FD;&#x5F97;&#x5230;&#x5199;&#x9501;</title>
      <link>https://awakening-fong.github.io/posts/arm/arm_smp_rwlock</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;p&gt;&#x6587;&#x6765;&#x81EA;&#x672C;&#x4EBA;&#x7684;&#x65E7;&#x535A;&#x5BA2;: http://blog.163.com/awaken_ing/blog/static/120613197201631133058159&lt;/p&gt;

&lt;p&gt;&#x672C;&#x7BC7;&#x53EA;&#x63D0;&#x95EE;, &#x4E0D;&#x89E3;&#x7B54;, &#x795D;&#x5F00;&#x5FC3;.&lt;/p&gt;

&lt;p&gt;&#x5982;&#x679C;&#x8BFB;&#x5199;&#x9501;&#x662F;unlocked, &#x7136;&#x540E;cpu 0&#x548C;cpu 1&#x90FD;&#x60F3;&#x83B7;&#x53D6;&#x5199;&#x9501;,
&#x5982;&#x8868;&#x683C;&#x6240;&#x793A;, CPU 0&#x5728;t2&#x65F6;&#x523B;&#x6267;&#x884C;&#x7684;&#x662F;wfene, &#x8FD9;&#x65F6;, CPU 1&#x6267;&#x884C;&#x7684;&#x662F;ldrex, &#x7136;&#x540E;&#x662F;&#x5426;&#x4F1A;&#x6709;cpu&#x80FD;&#x591F;&#x83B7;&#x53D6;&#x5230;&#x9501;?
&#x6E90;&#x7801;&#x6765;&#x81EA;
linux-3.10.86/arch/arm/include/asm/spinlock.h
arch_write_lock()&lt;/p&gt;

&lt;!--
&#x67E5;&#x770B;&#x6E90;&#x7801;&#x540E;, &#x5C06;&#x7B2C;1&#x4E2A;&lt;table&gt;&#x6539;&#x4E3A;
&lt;table class="table table-bordered table-striped table-condensed"&gt;

&#x65F6;&#x95F4; | CPU0                      |&#x65F6;&#x95F4;  |CPU1
-----|---------------------------|------|----
t0/t6| 1:    ldrex    %0, [%1]   |      |
t1/t7| teq    %0, #0             |      |
t2   |WFE("ne")                  |t2    |1:    ldrex    %0, [%1]
t3   |strexeq    %0, %2, [%1]    |t3    |teq    %0, #0
t4   |teq    %0, #0              |t4    |WFE("ne")
t5   |bne    1b                  |t5    |strexeq    %0, %2, [%1]
t6   |                           |t6    |teq    %0, #0
t7   |                           |t7    |bne    1b
--&gt;

&lt;table class="table table-bordered table-striped table-condensed"&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&#x65F6;&#x95F4;&lt;/th&gt;
&lt;th&gt;CPU0&lt;/th&gt;
&lt;th&gt;&#x65F6;&#x95F4;&lt;/th&gt;
&lt;th&gt;CPU1&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;t0/t6&lt;/td&gt;
&lt;td&gt;1:    ldrex    %0, [%1]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t1/t7&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t2&lt;/td&gt;
&lt;td&gt;WFE(&amp;quot;ne&amp;quot;)&lt;/td&gt;
&lt;td&gt;t2&lt;/td&gt;
&lt;td&gt;1:    ldrex    %0, [%1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t3&lt;/td&gt;
&lt;td&gt;strexeq    %0, %2, [%1]&lt;/td&gt;
&lt;td&gt;t3&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t4&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;td&gt;t4&lt;/td&gt;
&lt;td&gt;WFE(&amp;quot;ne&amp;quot;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t5&lt;/td&gt;
&lt;td&gt;bne    1b&lt;/td&gt;
&lt;td&gt;t5&lt;/td&gt;
&lt;td&gt;strexeq    %0, %2, [%1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;t6&lt;/td&gt;
&lt;td&gt;teq    %0, #0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;t7&lt;/td&gt;
&lt;td&gt;bne    1b&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;CPU 0&#x548C;CPU 1&#x90FD;&#x62FF;&#x5230; &#x5199;&#x9501;? &#x4E24;&#x4E2A;CPU&#x90FD;&#x6B7B;&#x5FAA;&#x73AF;? &#x597D;&#x50CF;&#x4E0D;&#x5E94;&#x8BE5;&#x554A;?
&#x672C;&#x7BC7;&#x53EA;&#x63D0;&#x95EE;, &#x4E0D;&#x89E3;&#x7B54;, &#x795D;&#x5F00;&#x5FC3;. ^_^&lt;/p&gt;

&lt;p&gt;&#x9644; linux-3.10.86/arch/arm/include/asm/spinlock.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void arch_write_lock(arch_rwlock_t *rw)
{
    unsigned long tmp;

    __asm__ __volatile__(
&amp;quot;1: ldrex   %0, [%1]\n&amp;quot;
&amp;quot;   teq %0, #0\n&amp;quot;
    WFE(&amp;quot;ne&amp;quot;)
&amp;quot;   strexeq %0, %2, [%1]\n&amp;quot;
&amp;quot;   teq %0, #0\n&amp;quot;
&amp;quot;   bne 1b&amp;quot;
    : &amp;quot;=&amp;amp;r&amp;quot; (tmp)
    : &amp;quot;r&amp;quot; (&amp;amp;rw-&amp;gt;lock), &amp;quot;r&amp;quot; (0x80000000)
    : &amp;quot;cc&amp;quot;);

    smp_mb();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x4E2D;&#x65AD;, softirq, tasklet&#x7684;&#x533A;&#x522B;</title>
      <link>https://awakening-fong.github.io/posts/arm/interrupt_softirq_in_arm</link>
      <pubDate>2017-01-18</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4E2D;&#x65AD;&#x6D41;&#x7A0B;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5047;&#x5B9A; CONFIG_MULTI_IRQ_HANDLER=y, handle_arch_irq &#x4E3A; gic_handle_irq.&lt;br&gt;
linux-3.10.86/arch/arm/kernel/setup.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__irq_svc @entry-armv.S
|   |--svc_entry    &#x4FDD;&#x5B58;spsr_&amp;lt;exception&amp;gt; &#x5230;r5
|   |--irq_handler
|   |   |--handle_arch_irq =&amp;gt; gic_handle_irq
|   |   |   |--irq_find_mapping  &#x5B8C;&#x6210; an hw irq number&#x5230;a linux irq&#x7684;&#x8F6C;&#x6362;
|   |   |   |--handle_IRQ(irqnr, regs) if not IPI 
|   |   |   |       |--generic_handle_irq  -&amp;gt; generic_handle_irq_desc -&amp;gt; handle_fasteoi_irq
|   |   |   |       |   |--raw_spin_lock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |   |--handle_irq_event
|   |   |   |       |   |   |--raw_spin_unlock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |   |   |--handle_irq_event_percpu -&amp;gt; action-&amp;gt;handler
|   |   |   |       |   |   |--raw_spin_lock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |   |--chip-&amp;gt;irq_eoi
|   |   |   |       |   |--raw_spin_unlock(&amp;amp;desc-&amp;gt;lock);
|   |   |   |       |--irq_exit();  &#x8FD9;&#x91CC;&#x4E2D;&#x65AD;&#x8FD8;&#x662F;&#x7981;&#x7528;&#x7684;&#x5417;? &#x7B54;:&#x662F;&#x7684;, ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED
|   |   |   |       |   |--WARN_ON_ONCE(!irqs_disabled());
|   |   |   |       |   |--if( ... ) invoke_softirq() 
|   |   |   |       |   |    |--do_softirq -&amp;gt; __do_softirq
|   |   |   |       |   |    |    |--local_irq_enable   //&#x4FEE;&#x6539;CPSR I bit, &#x6253;&#x5F00;&#x4E2D;&#x65AD;
|   |   |   |       |   |    |    |--h-&amp;gt;action(h)
|   |   |   |       |   |    |    |--local_irq_disable  //&#x8FD9;&#x91CC;&#x4E3A;&#x4F55;&#x53C8;&#x7981;&#x6B62;&#x4E2D;&#x65AD;???
|   |   |   |       |--set_irq_regs(old_regs)  &#x8FD9;&#x91CC;&#x5F00;&#x542F;&#x4E2D;&#x65AD;? &#x7B54;:&#x4E0D;&#x662F;.
|   |--svc_exit r5, irq = 1  @entry-header.S
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5047;&#x5B9A;&#x53D1;&#x751F;&#x4E2D;&#x65AD;&#x524D;, &#x662F;&#x5904;&#x4E8E;svc&#x6A21;&#x5F0F;&#x7684;, &#x6240;&#x4EE5;, &#x4E0A;&#x9762;&#x6D41;&#x7A0B;&#x4E3A;__irq_svc.
&#x4E2D;&#x65AD;&#x4E0A;&#x534A;&#x90E8;&#x5206; &#x4E2D;&#x65AD;&#x662F;&#x5173;&#x95ED;&#x7684;, &#x4F55;&#x65F6;&#x91CD;&#x65B0;&#x4F7F;&#x80FD;&#x4E2D;&#x65AD;, &#x4E0A;&#x9762;&#x90FD;&#x4EE5;&#x6807;&#x51FA;. &#x4F7F;&#x80FD;&#x4E4B;&#x540E;, &#x5C31;&#x5F00;&#x59CB;&#x5904;&#x7406;&#x8F6F;&#x4E2D;&#x65AD;&#x4E86;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. tasklet&#x7684;&#x7279;&#x70B9;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x4E24;&#x4E2A;&#x7C7B;&#x578B;&#x76F8;&#x540C;&#x7684;tasklet&#x4E0D;&#x80FD;&#x540C;&#x65F6;&#x8FD0;&#x884C;, &#x5373;&#x4F7F;&#x5728;&#x4E0D;&#x540C;&#x7684;&#x5904;&#x7406;&#x5668;&#x4E0A;&#x4E5F;&#x662F;&#x5982;&#x6B64;, &#x56E0;&#x4E3A;&#x4EE3;&#x7801;&#x4E0A;&#x68C0;&#x67E5;&#x7684;&#x5E76;&#x4E0D;&#x662F;per cpu&#x7684;&#x53D8;&#x91CF;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void __init softirq_init(void)
{
...
    open_softirq(TASKLET_SOFTIRQ, tasklet_action);
    open_softirq(HI_SOFTIRQ, tasklet_hi_action);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4EE3;&#x7801;:linux-3.10/kernel/softirq.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void tasklet_action(struct softirq_action *a)
{
        struct tasklet_struct *t
        ...
        if (tasklet_trylock(t)) {
            ...
            t-&amp;gt;func(t-&amp;gt;data);
        }

}

#ifdef CONFIG_SMP
static inline int tasklet_trylock(struct tasklet_struct *t)
{
    return !test_and_set_bit(TASKLET_STATE_RUN, &amp;amp;(t)-&amp;gt;state);
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. softirq&#x7684;&#x7279;&#x70B9;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;softirq&#x7684;pending&#x53D8;&#x91CF;&#x662F;per-cpu&#x7684;, &#x5E76;&#x4E0D;&#x4F1A;&#x963B;&#x6B62;&#x76F8;&#x540C;&#x7684;handler&#x540C;&#x65F6;&#x8FD0;&#x884C;&#x5728;&#x4E0D;&#x540C;&#x7684;cpu&#x4E0A;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/kernel/softirq.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__do_softirq
{

    pending = local_softirq_pending();
    set_softirq_pending(0);

    do {
        if (pending &amp;amp; 1) {

            -&amp;gt;action
        }

        pending &amp;gt;&amp;gt;= 1;
    }while (pending);

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
  </channel>
</rss>
