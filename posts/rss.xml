<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>HOMEPAGE</title>
    <description>HOMEPAGE</description>
    <link>https://awakening-fong.github.io</link>
    <pubDate>2017-01-07</pubDate>
    <item>
      <title>generic_make_request</title>
      <link>https://awakening-fong.github.io/posts/generic_make_request</link>
      <pubDate>2017-01-04</pubDate>
      <description>&lt;p&gt;linux-3.10.86/block/blk-core.c&lt;/p&gt;

&lt;p&gt;&#x5148;&#x65AD;&#x7AE0;&#x53D6;&#x4E49;&#x4E0B;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;void generic_make_request(struct bio *bio)
{

    bio_list_init(&amp;amp;bio_list_on_stack);
    current-&amp;gt;bio_list = &amp;amp;bio_list_on_stack;
    ...
        /*
        &#x4ECE;&#x8FD9;&#x91CC;&#x6765;&#x770B;, q-&amp;gt;make_request_fn()&#x53EF;&#x80FD;&#x4F1A;&#x5F80;current-&amp;gt;bio_list&#x4E2D;&#x6DFB;&#x52A0;bio,
        &#x5426;&#x5219;, &#x4ECE;&#x54EA;&#x91CC;pop&#x5462;?
        */
    q-&amp;gt;make_request_fn(q, bio);
    bio = bio_list_pop(current-&amp;gt;bio_list);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x4E0A;&#x9762;&#x7684;&#x731C;&#x60F3;&#x662F;&#x7247;&#x9762;&#x7684;, &#x8FD8;&#x662F;&#x6765;&#x4E2A;&#x5168;&#x8C8C;&#x7684;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;void generic_make_request(struct bio *bio)
{
    struct bio_list bio_list_on_stack;

    if (!generic_make_request_checks(bio))
        return;

    if (current-&amp;gt;bio_list) {
        bio_list_add(current-&amp;gt;bio_list, bio);
        return;
    }

    BUG_ON(bio-&amp;gt;bi_next);
    bio_list_init(&amp;amp;bio_list_on_stack);
    current-&amp;gt;bio_list = &amp;amp;bio_list_on_stack;
    do {
        /*
        while&#x518D;&#x6B21;&#x6267;&#x884C;&#x65F6;, q (struct request_queue *)&#x53EF;&#x80FD;&#x548C;&#x4E0A;&#x6B21;&#x5FAA;&#x73AF;&#x65F6;&#x7684;q&#x4E0D;&#x4E00;&#x6837;&#x4E86;,
        &#x6240;&#x4EE5;, &#x5B9E;&#x73B0;&#x4ECE;&#x4E00;&#x79CD;&#x8BBE;&#x5907;&#x5230;&#x53E6;&#x4E00;&#x79CD;&#x8BBE;&#x5907;&#x7684;&#x6620;&#x5C04;, &#x63D0;&#x4EA4;&#x7ED9;&#x65B0;&#x7684;&#x5757;&#x8BBE;&#x5907;&#x6267;&#x884C;.
        */
        struct request_queue *q = bdev_get_queue(bio-&amp;gt;bi_bdev);
        q-&amp;gt;make_request_fn(q, bio);
        /*
        &#x4ECE;&#x8FD9;&#x91CC;&#x6765;&#x770B;, q-&amp;gt;make_request_fn()&#x53EF;&#x80FD;&#x4F1A;&#x5F80;current-&amp;gt;bio_list&#x4E2D;&#x6DFB;&#x52A0;bio,
        &#x5426;&#x5219;, &#x4ECE;&#x54EA;&#x91CC;pop&#x5462;?
        &#x5F53;&#x7136;&#x4E5F;&#x53EF;&#x4EE5;&#x4E0D;&#x5F80;current-&amp;gt;bio_list&#x6DFB;&#x52A0;bio, &#x8868;&#x793A;&#x65E0;&#x9700;&#x518D;&#x7ECF;&#x8FC7;&#x8F6C;&#x6362;&#x4E86;, 
        &#x8FD9;&#x6837;, while&#x4E5F;&#x5C31;&#x7ED3;&#x675F;&#x4E86;.
        */
        bio = bio_list_pop(current-&amp;gt;bio_list);
    } while (bio);
    current-&amp;gt;bio_list = NULL; /* deactivate */
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5047;&#x5B9A;&#x7ECF;&#x8FC7;1&#x6B21;&#x8F6C;&#x6362;, &#x90A3;&#x4E48;, &#x8C03;&#x7528;&#x5927;&#x6982;&#x662F;&#x8FD9;&#x6837;&#x7684;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;generic_make_request
|-- q-&amp;gt;make_request_fn
|   |--...
|   |--generic_make_request
|   |   |--if (current-&amp;gt;bio_list) { bio_list_add(current-&amp;gt;bio_list, bio); return; }
|-- bio = bio_list_pop(current-&amp;gt;bio_list);
|-- q-&amp;gt;make_request_fn(q, bio);
|   |--no call generic_make_request
|--return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x65E0;&#x9700;&#x8F6C;&#x6362;&#x662F;&#x8FD9;&#x6837;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;generic_make_request
|-- q-&amp;gt;make_request_fn  &#x6BD4;&#x5982;&#x4E3A; blk_queue_bio
|   |--no call generic_make_request
|--return
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>tag TOWRITE to avoid livelocking?</title>
      <link>https://awakening-fong.github.io/posts/tag_towrie_livelock</link>
      <pubDate>2017-01-03</pubDate>
      <description>&lt;div class="summary"&gt;
&#x4E3B;&#x8981;&#x4ECB;&#x7ECD;writeback&#x4E2D;&#x7684;livelocking.
&lt;/div&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x4EC0;&#x4E48;&#x662F;livelock&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x901A;&#x5E38;&#x8BF4;&#x7684;livelock&#x6307;&#x7684;&#x662F;&#x53CC;&#x65B9;&#x76F8;&#x4E92;&#x907F;&#x8BA9;, &#x5BFC;&#x81F4;&#x4EFB;&#x52A1;&#x6CA1;&#x6709;&#x8FDB;&#x5C55;.&lt;br&gt;
&#x4E0D;&#x8FC7;, &#x4ECE;&#x4E0B;&#x9762;&#x7684;thread&#x6765;&#x770B;, livelock&#x7684;&#x542B;&#x4E49;&#x662F;:&#x867D;&#x7136;&#x6709;&#x8FDB;&#x5EA6;, &#x4F46;&#x603B;&#x6709;&#x65B0;&#x4EFB;&#x52A1;, &#x5BFC;&#x81F4;&#x65E0;&#x6CD5;&#x5B8C;&#x6210;, &#x4E5F;&#x7B97;livelock.&lt;br&gt;
&#x53CD;&#x6B63;&#x8DDF;&#x9501;&#x6CA1;&#x6709;&#x5173;&#x7CFB;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://lkml.org/lkml/2010/11/9/593"&gt;https://lkml.org/lkml/2010/11/9/593&lt;/a&gt;
For example when a single large file is continuously dirtied, we would never finish syncing it ...
After this patch, program from &lt;a href="http://lkml.org/lkml/2010/10/24/154"&gt;http://lkml.org/lkml/2010/10/24/154&lt;/a&gt; is no
longer able to stall sync forever.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x5B9E;&#x73B0;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5904;&#x7406;&#x65B9;&#x6CD5;&#x662F;: &lt;code&gt;write_cache_pages()&lt;/code&gt;&#x4E2D;, &#x5982;&#x679C; &#x56DE;&#x5199;&#x63A7;&#x5236; &#x8981;&#x6C42;&#x540C;&#x6B65;, &#x90A3;&#x4E48;, &#x7ED9;DIRTY&#x7684;&#x518D;&#x52A0;&#x4E0A;TOWRITE, &#x7136;&#x540E;&#x53EA;&#x7BA1;&#x5904;&#x7406;&#x5B8C;TOWRITE&#x7684;&#x5C31;&#x5B8C;&#x4E8B;&#x4E86;, &#x540E;&#x9762;DIRTY&#x7684;page&#x5C31;&#x4E0D;&#x7BA1;&#x4E86;.&lt;br&gt;
&#x8FD9;&#x4E2A;&#x5957;&#x8DEF;&#x6709;&#x70B9;&#x773C;&#x719F;, &#x6BD4;&#x5982; &lt;code&gt;write_cache_pages()&lt;/code&gt;&#x4E2D;&lt;code&gt;pagevec_lookup_tag()&lt;/code&gt;&#x628A;page&#x6311;&#x9009;&#x51FA;&#x6765;&#x653E;&#x5728;&lt;code&gt;struct pagevec pvec&lt;/code&gt;&#x4E2D;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;write_cache_pages
{

    if (wbc-&amp;gt;sync_mode == WB_SYNC_ALL || wbc-&amp;gt;tagged_writepages)
        tag = PAGECACHE_TAG_TOWRITE;
    else
        tag = PAGECACHE_TAG_DIRTY;
retry:
    if (wbc-&amp;gt;sync_mode == WB_SYNC_ALL || wbc-&amp;gt;tagged_writepages)
        tag_pages_for_writeback(mapping, index, end);//&#x7ED9;DIRTY&#x7684;&#x52A0;&#x4E0A;TOWRITE

    while(...)
    {
        nr_pages = pagevec_lookup_tag(&amp;amp;pvec, mapping, &amp;amp;index, tag,
                  min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);
        if (nr_pages == 0) //&#x5B8C;&#x4E8B;&#x4E86;.
            break;
        ...

            /*

            */
            if (!clear_page_dirty_for_io(page))
                goto continue_unlock;
            (*writepage)(page, wbc, data);

    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x81EA;&#x95EE;&#x81EA;&#x7B54;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x4E0A;&#x9762;&#x7684;&#x5B9E;&#x73B0;, &#x5199;&#x597D;&#x4E4B;&#x540E;, &#x4F3C;&#x4E4E;&#x5E76;&#x6CA1;&#x6709;&#x6E05;&#x6389;radix tree&#x7684;tag, &#x5C31;&#x653E;&#x90A3;&#x4E0D;&#x7BA1;&#x4E86;?&lt;br&gt;
&#x7B54;: &#x641C;&#x7D22; &lt;code&gt;mapping-&amp;gt;tree_lock&lt;/code&gt;, &#x627E;&#x5230; &lt;code&gt;test_set_page_writeback()&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;linux-3.10.86/mm/page-writeback.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;test_set_page_writeback
{
    ...
            radix_tree_tag_clear(&amp;amp;mapping-&amp;gt;page_tree,
                        page_index(page),
                        PAGECACHE_TAG_DIRTY);

        radix_tree_tag_clear(&amp;amp;mapping-&amp;gt;page_tree,
                     page_index(page),
                     PAGECACHE_TAG_TOWRITE)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/include/linux/page-flags.h&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;static inline void set_page_writeback(struct page *page)
{
    test_set_page_writeback(page);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8C03;&#x7528;&lt;code&gt;set_page_writeback&lt;/code&gt;&#x7684;&#x6709;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__block_write_full_page -&amp;gt; set_page_writeback
__mpage_writepage -&amp;gt; set_page_writeback(page);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;writepage&#x901A;&#x5E38;&#x662F; &lt;code&gt;__mpage_writepage&lt;/code&gt;&#x6216; &lt;code&gt;__writepage&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__writepage -&amp;gt;  mapping-&amp;gt;a_ops-&amp;gt;writepage -&amp;gt; ext2_writepage -&amp;gt; block_write_full_page -&amp;gt; block_write_full_page_endio -&amp;gt; __block_write_full_page
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &lt;code&gt;write_cache_pages()&lt;/code&gt;&#x4E2D;&#x7684; (*writepage)(...)&#x4F1A;&#x6E05;&#x6389;&#x76F8;&#x5E94;tag.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. &#x5176;&#x4ED6;livelocking&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=aa373cf550994623efb5d49a4d8775bafd10bbc1"&gt;http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=aa373cf550994623efb5d49a4d8775bafd10bbc1&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
writeback: stop background/kupdate works from livelocking other works

Background writeback is easily livelockable in a loop in wb_writeback() by a process continuously re-dirtying pages (or continuously appending to a file). This is in fact intended as the target of background writeback is to write dirty pages it can find as long as we are over dirty_background_threshold.

But the above behavior gets inconvenient at times because no other work queued in the flusher thread's queue gets processed. In particular, since e.g. sync(1) relies on flusher thread to do all the IO for it, sync(1) can hang forever waiting for flusher thread to do the work.

...

Thus we interrupt background writeback if there is some other work to do.

&lt;/pre&gt;

&lt;p&gt;&#x7B49;&#x7B49;, &#x6211;&#x4EEC;&#x53D1;&#x8D77;sync, &#x7136;&#x540E;&#x8FD9;&#x91CC;&#x4E2D;&#x65AD;&#x4E86;, &#x5565;&#x4E8B;&#x90FD;&#x6CA1;&#x5E72;, &#x8FD4;&#x56DE;&#x4E86;, &#x5408;&#x9002;&#x5417;?&lt;br&gt;
&#x7B54;: &#x4E0A;&#x8FB9;&#x7684;...&#x4E2D;&#x6709; Generally, when a flusher thread has some work queued, someone submitted the work to achieve a goal more specific than what background writeback does.   ...&lt;/p&gt;

&lt;p&gt;linux-3.10.86/fs/fs-writeback.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;wb_writeback
{

        if ((work-&amp;gt;for_background || work-&amp;gt;for_kupdate) &amp;amp;&amp;amp;
            !list_empty(&amp;amp;wb-&amp;gt;bdi-&amp;gt;work_list))
            break;
        if (work-&amp;gt;for_background &amp;amp;&amp;amp; !over_bground_thresh(wb-&amp;gt;bdi))
            break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_4"&gt;&lt;h4&gt;5. more ...&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/log/?qt=grep&amp;amp;q=livelocking"&gt;http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/log/?qt=grep&amp;amp;q=livelocking&lt;/a&gt;   &lt;/p&gt;
</description>
    </item>
    <item>
      <title>do_generic_file_read&#x4E2D;&#x7684;readahead</title>
      <link>https://awakening-fong.github.io/posts/readahead</link>
      <pubDate>2017-01-03</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. readahead&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;do_generic_file_read &#x4E2D;&#x6709;&#x4E24;&#x4E2A;ahead&#x76F8;&#x5173;&#x7684;&#x51FD;&#x6570;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_generic_file_read -&amp;gt; page_cache_sync_readahead 
generic_file_aio_read -&amp;gt; do_generic_file_read -&amp;gt;  page_cache_async_readahead
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;:page_cache_sync_readahead &#x548C; page_cache_async_readahead  &#x7684;&#x5DEE;&#x522B;&#x5728;&#x54EA;&#x91CC;? sync&#x548C;async&#x4F53;&#x73B0;&#x5728;&#x54EA;?&lt;br&gt;
&#x7B54;: &#x4E00;&#x4E2A;&#x5F53;&#x524D;page cache&#x4E2D;&#x6CA1;&#x6709;&#x6240;&#x9700;&#x7684;&#x6570;&#x636E;, &#x53D1;&#x8D77;&#x7684;&#x662F;&#x5BF9;&#x5F53;&#x4E0B;&#x8981;&#x7528;&#x7684;&#x6570;&#x636E;&#x7684;&#x8BFB;&#x53D6;;&lt;br&gt;
&#x53E6;&#x4E00;&#x4E2A;&#x662F;page cache&#x4E2D;&#x6709;&#x6240;&#x9700;&#x7684;&#x6570;&#x636E;, &#x53D1;&#x8D77;&#x5BF9;&#x540E;&#x9762;&#x53EF;&#x80FD;&#x8981;&#x7528;&#x7684;&#x6570;&#x636E;&#x7684;&#x8BFB;&#x53D6;.&lt;/p&gt;

&lt;p&gt;linux-3.10.86/mm/filemap.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_generic_file_read
{
        page = find_get_page(mapping, index);
        if (!page){
            page_cache_sync_readahead(...)
            ...
        }
        if (PageReadahead(page)) {
            page_cache_async_readahead(...)
        }
        ...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sync&#x4F53;&#x73B0;&#x5728;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_generic_file_read
{

            page = find_get_page(mapping, index);
            if (!page){
                page_cache_sync_readahead(...)
                ...
            }
            if (!PageUptodate(page)) {
                if (!trylock_page(page)) //&#x9501;&#x5931;&#x8D25;
                    goto page_not_up_to_date;
                ...
            }

page_not_up_to_date:
        /*&#x8FD9;&#x91CC;&#x7B49;&#x5F85;io complete handler&#x91CA;&#x653E;&#x9501;.*/
        /* Get exclusive access to the page ... */
        error = lock_page_killable(page);
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. how readahead works&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;ondemand_readahead -&amp;gt; __do_page_cache_readahead -&amp;gt; read_pages&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;read_pages
{
    ...
    blk_start_plug(&amp;amp;plug);
    mapping-&amp;gt;a_ops-&amp;gt;readpages()
    blk_finish_plug(&amp;amp;plug);
}


blk_start_plug(struct blk_plug *plug)
{
    ...
    if (!tsk-&amp;gt;plug)
        tsk-&amp;gt;plug = plug;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/include/linux/sched.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct task_struct {
    ...
    /* stacked block device info */
    struct bio_list *bio_list;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/include/linux/blkdev.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct blk_plug {
    unsigned long magic; /* detect uninitialized use-cases */
    /* &#x5148;&#x5C1D;&#x8BD5;&#x548C;current-&amp;gt;plug&#x8FD9;&#x4E2A;struct blk_plug&#x4E2D;&#x7684;struct request&#x5408;&#x5E76;
    &#x5931;&#x8D25;&#x540E;, &#x624D;&#x5C1D;&#x8BD5;&#x7535;&#x68AF;&#x8C03;&#x5EA6;.
    see blk_queue_bio -&amp;gt; attempt_plug_merge()*/
    struct list_head list; /* requests */
    /*entry&#x4E3A;struct blk_plug_cb, see flush_plug_callbacks()*/
    struct list_head cb_list; /* md requires an unplug callback */
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x56DE;&#x5199;&#x8DEF;&#x5F84;</title>
      <link>https://awakening-fong.github.io/posts/writeback_routine</link>
      <pubDate>2017-01-01</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;&#x65B9;&#x5F0F;1. &#x524D;&#x671F;tag dirty&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/page-writeback.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;
write_cache_pages
{

    while (...) {

        nr_pages = pagevec_lookup_tag(&amp;amp;pvec, mapping, &amp;amp;index, tag,
                  min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);
        if (nr_pages == 0)
            break;

        ...
            lock_page(page);
        ...
            /*&#x5E38;&#x89C1;&#x7684;&#x6709;__mpage_writepage &#x6216;&#x8005; __writepage*/
            ret = (*writepage)(page, wbc, data);


}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="c"&gt;__filemap_fdatawrite_range
|   |--do_writepages
|   |   |--mapping-&amp;gt;a_ops-&amp;gt;writepages  or generic_writepages 
|   |   |   |--write_cache_pages

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6BD4;&#x5982;fsync&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do_fsync -&amp;gt; vfs_fsync -&amp;gt; vfs_fsync_range -&amp;gt; file-&amp;gt;f_op-&amp;gt;fsync -&amp;gt; ext2_fsync
-&amp;gt; generic_file_fsync
|--filemap_write_and_wait_range -&amp;gt; __filemap_fdatawrite_range
|--sync_mapping_buffers
|--sync_inode_metadata
|   |--struct writeback_control wbc ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6BD4;&#x5982; linux-3.10.86/fs/sync.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sync_file_range -&amp;gt; filemap_fdatawrite_range -&amp;gt; __filemap_fdatawrite_range
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;&#x65B9;&#x5F0F;2. BDI&#x56DE;&#x5199;&lt;/h4&gt;&lt;/h1&gt;

&lt;h2 id="toc_2"&gt;&lt;h4&gt;2.1 &#x89E6;&#x53D1;&#x56DE;&#x5199;&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;linux-3.10.86/mm/backing-dev.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;default_bdi_init
|--- bdi_wq = alloc_workqueue(&amp;quot;writeback&amp;quot;, WQ_MEM_RECLAIM | WQ_FREEZABLE |
                          WQ_UNBOUND | WQ_SYSFS, 0);

bdi_wb_init(struct bdi_writeback *wb, struct backing_dev_info *bdi)
|--INIT_DELAYED_WORK(&amp;amp;wb-&amp;gt;dwork, bdi_writeback_workfn);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;linux-3.10.86/fs/fs-writeback.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;bdi_writeback_workfn(struct work_struct *work)
{
    struct bdi_writeback *wb = container_of(to_delayed_work(work),
                        struct bdi_writeback, dwork);

    ...

    /*&#x4EFB;&#x52A1;&#x8FD8;&#x6CA1;&#x5B8C;&#x6210;, &#x8BA9;&#x672C;&#x51FD;&#x6570;(bdi_writeback_workfn)&#x518D;&#x8DD1;&#x8DD1;*/
    if (!list_empty(&amp;amp;bdi-&amp;gt;work_list))
        mod_delayed_work(bdi_wq, &amp;amp;wb-&amp;gt;dwork, 0);
    ...
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x901A;&#x8FC7;&#x4EE5;&#x4E0B;&#x51FD;&#x6570; &#x53EF;&#x4EE5;&#x8BA9; &lt;code&gt;bdi_writeback_workfn()&lt;/code&gt;&#x8DD1;&#x8D77;&#x6765;:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flush_delayed_work
mod_delayed_work_on
mod_delayed_work
queue_delayed_work_on
queue_delayed_work
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x5E38;&#x7528;&#x7684;&#x5C01;&#x88C5;&#x8FC7;&#x7684;&#x51FD;&#x6570;&#x662F;:&lt;/p&gt;

&lt;p&gt;linux-3.10.86/fs/fs-writeback.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;bdi_queue_work(struct backing_dev_info *bdi,
               struct wb_writeback_work *work)
{
    ...
    list_add_tail(&amp;amp;work-&amp;gt;list, &amp;amp;bdi-&amp;gt;work_list);    
    mod_delayed_work(bdi_wq, &amp;amp;bdi-&amp;gt;wb.dwork, 0);

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x8C03;&#x7528;&lt;code&gt;bdi_queue_work&lt;/code&gt;&#x7684;&#x6709;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__bdi_start_writeback()
writeback_inodes_sb_nr()
sync_inodes_sb()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="c"&gt;wakeup_flusher_threads -&amp;gt; __bdi_start_writeback

linux-3.10.86/fs/sync.c
sync -&amp;gt; wakeup_flusher_threads

linux-3.10.86/fs/buffer.c
free_more_memory -&amp;gt; wakeup_flusher_threads

linux-3.10.86/mm/vmscan.c
do_try_to_free_pages -&amp;gt; wakeup_flusher_threads

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="c"&gt;linux-3.10.86/fs/sync.c
syncfs -&amp;gt; sync_filesystem -&amp;gt; __sync_filesystem -&amp;gt; writeback_inodes_sb -&amp;gt; writeback_inodes_sb_nr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x5927;&#x4F53;&#x4E0A;&#x662F;&#x4E24;&#x7C7B;, &#x4E00;&#x7C7B;&#x662F;&#x5185;&#x5B58;&#x4E0D;&#x8DB3;&#x89E6;&#x53D1;&#x7684;, &#x4E00;&#x7C7B;&#x662F;&#x540C;&#x6B65;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x89E6;&#x53D1;&#x7684;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;2.2 kupdate&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;__mark_inode_dirty -&amp;gt; bdi_wakeup_thread_delayed -&amp;gt; queue_delayed_work
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;2.3 &#x524D;&#x671F;dirty inode&lt;/h4&gt;&lt;/h2&gt;

&lt;p&gt;&#x5728;&#x89E6;&#x53D1;&#x56DE;&#x5199;&#x7EBF;&#x7A0B;&#x524D;, &lt;code&gt;b_dirty&lt;/code&gt;, &lt;code&gt;b_io&lt;/code&gt;, &lt;code&gt;b_more_io&lt;/code&gt;&#x7B49;&#x94FE;&#x8868; &#x8FD8;&#x662F;&#x8981;&#x975E;&#x7A7A;&#x7684;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;__set_page_dirty
|-- __mark_inode_dirty(mapping-&amp;gt;host, I_DIRTY_PAGES);
|   |--list_move(&amp;amp;inode-&amp;gt;i_wb_list, &amp;amp;bdi-&amp;gt;wb.b_dirty);


generic_write_end
|--if (i_size_changed)  mark_inode_dirty(inode);
|   |--__mark_inode_dirty(inode, I_DIRTY);

generic_file_direct_write
|--i_size_write
|--mark_inode_dirty
|   |--__mark_inode_dirty(inode, I_DIRTY);

...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="c"&gt;struct bdi_writeback {
    ...
    struct list_head b_dirty;   /* dirty inodes */
    /*
    &#x8FD9;&#x4E2A;&#x662F;&#x5E38;&#x89C1;&#x7684;&#x5957;&#x8DEF;, &#x4E00;&#x6B21;&#x6027;&#x628A;b_dirty&#x4E2D;&#x5408;&#x9002;&#x7684;(&#x8FC7;&#x671F;&#x7684;)node&#x632A;&#x5230;b_io&#x4E2D;, 
    &#x7136;&#x540E;&#x5176;&#x4ED6;&#x4EBA;&#x53EF;&#x4EE5;&#x7EE7;&#x7EED;&#x5F80;&#x94FE;&#x8868;&#x4E2D;b_dirty&#x6DFB;&#x52A0;, &#x6211;&#x4EEC;&#x53EA;&#x9700;&#x5904;&#x7406;&#x94FE;&#x8868;b_io&#x4E0A;&#x7684;inode,&#x53EF;&#x4EE5;&#x51CF;&#x5C11;&#x9501;&#x7684;overhead.

    &#x53E6;&#x4E00;&#x65B9;&#x9762;&#x6B21;&#x8981;&#x7684;&#x539F;&#x56E0;&#x662F; &#x53EF;&#x4EE5;&#x907F;&#x514D;&#x6709;&#x4EBA;&#x4E00;&#x76F4;&#x5F80;&#x94FE;&#x8868;b_dirty&#x4E2D;&#x6DFB;&#x52A0;, 
    &#x5BFC;&#x81F4;&#x5199;&#x4E2A;&#x4E0D;&#x505C;, &#x4E0D;&#x8FC7;&#x8FD9;&#x4E2A;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x9650;&#x5236;&#x6BCF;&#x6B21;&#x5199;&#x7684;&#x6570;&#x91CF;&#x6765;&#x907F;&#x514D;.
    */
    struct list_head b_io;      /* parked for writeback */
    /*
    writeback_sb_inodes
    |--if inode&#x5E0C;&#x671B;I_SYNC, &#x4F46;&#x56DE;&#x5199;&#x63A7;&#x5236;&#x4E0D;&#x662F;, &#x653E;&#x5165;b_more_io


    requeue_inode
    {
        if (mapping_tagged(inode-&amp;gt;i_mapping, PAGECACHE_TAG_DIRTY)) {

            if (wbc-&amp;gt;nr_to_write &amp;lt;= 0) {
                requeue_io(inode, wb);
            }
            ...
        }
    }
    &#x8FD8;&#x6709;page&#x8981;&#x5199;, &#x4E0D;&#x8FC7;&#x914D;&#x989D;&#x7528;&#x5149;&#x4E86;, &#x5219;&#x653E;&#x5165;b_more_io.
    */
    struct list_head b_more_io; /* parked for more writeback */

}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>generic_perform_write&#x6D41;&#x7A0B;</title>
      <link>https://awakening-fong.github.io/posts/generic_perform_write</link>
      <pubDate>2016-12-31</pubDate>
      <description>&lt;pre&gt;&lt;code class="c"&gt;generic_perform_write
{

        /*
        ==0==&#x8BA1;&#x7B97;&#x6CA1;&#x6709;&#x548C;PAGE_CACHE_SIZE&#x5BF9;&#x9F50;&#x7684;&#x90A3;&#x90E8;&#x5206;&#x7684;&#x5927;&#x5C0F;, &#x4EE3;&#x7801;&#x4E2D;&#x7684;bytes.

        &#x6742;&#x95EE;&#x9898;:
        &#x5047;&#x5B9A;PAGE_CACHE_SIZE&#x4E3A;4, pos&#x4E3A;5, iov_iter_count()&#x5927;&#x4E8E;2&#x4E2A;PAGE_CACHE_SIZE,
        &#x5219;offset&#x4E3A;1, bytes&#x4E3A;3
        &#x6240;&#x4EE5;, &#x4EE3;&#x7801;&#x4E2D;&#x7684;bytes&#x5C31;&#x662F;&#x793A;&#x610F;&#x56FE;&#x4E2D;|///|&#x90A3;&#x90E8;&#x5206;:
      pos==0    pos==5
        ^         ^
        |         |
        |----|  |-.---|  |----|
                  |///|
                  &#x8BFB;&#x53D6;
        */
        offset = (pos &amp;amp; (PAGE_CACHE_SIZE - 1));
        bytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,
                        iov_iter_count(i));
again:
        /*
        &#x5982;&#x4F55;&#x9632;&#x6B62;dead lock&#x53EF;&#x53C2;&#x8003;
        https://lkml.org/lkml/2015/6/30/631
        */
        iov_iter_fault_in_readable(...);

        /*
        ==1==&#x51C6;&#x5907;page
        &#x7B54;:
        &#x5982;&#x679C;&#x5728;address_space&#x4E2D;&#x6CA1;&#x6709;&#x8BE5;pos&#x5BF9;&#x5E94;&#x7684;page, &#x5219;&#x5206;&#x914D;page&#x5E76;&#x6DFB;&#x52A0;&#x5230;address_space.
        &#x5982;&#x679C;&#x6CA1;&#x6709;&#x5199;&#x5B8C;&#x6574;&#x7684;&#x4E00;&#x4E2A;sector, &#x5219;&#x9700;&#x8981;&#x5148;&#x4ECE;&#x78C1;&#x76D8;&#x8BFB;&#x51FA;&#x539F;sector.
        */
        status = a_ops-&amp;gt;write_begin(file, mapping, pos, bytes, flags,
                        &amp;amp;page, &amp;amp;fsdata);

        /*
        ==2==&#x586B;&#x5145;page cache
        */
        /*
        flush_dcache_page &#x89C1;https://awakening-fong.github.io/posts/flush_dcache_page
        */
        if (mapping_writably_mapped(mapping))
            flush_dcache_page(page);
        pagefault_disable();
        copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);
        pagefault_enable();
        flush_dcache_page(page);
        /*
        ==3==&#x6807;&#x8BB0;&#x4E3A;dirty, &#x5904;&#x7406;short write
        short wrtie&#x662F;&#x8BA9; copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);&#x590D;&#x5236;bytes, &#x7ED3;&#x679C;&#x5B9E;&#x9645;&#x53EA;&#x590D;&#x5236;copied. &#x82E5;&#x53D1;&#x751F;short write, &#x5219;&#x91CD;&#x6765;.
        */
        a_ops-&amp;gt;write_end(...);

}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>flush_dcache_page</title>
      <link>https://awakening-fong.github.io/posts/flush_dcache_page</link>
      <pubDate>2016-12-31</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. flush_dcache_page&#x7684;&#x5B9E;&#x73B0;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x95EE;&#x9898;:flush_dcache_page()&#x5230;&#x5E95;&#x662F; invalid, &#x8FD8;&#x662F; clean and invalid, &#x8FD8;&#x662F;&#x4EC5;&#x6E05;&#x6389;dirty bit&lt;/p&gt;

&lt;p&gt;linux-3.10.86/arch/arm/mm/flush.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flush_dcache_page -&amp;gt; __flush_dcache_page
{
    /*
     * Writeback ...
    */

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x662F;Writeback, &#x6240;&#x4EE5;, &#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A; clean and invalid, &#x5C3D;&#x7BA1;&#x5B9E;&#x73B0;&#x4E0A;&#x53EF;&#x80FD;&#x91C7;&#x7528;lazy&#x4EC0;&#x4E48;&#x7684;.&lt;/p&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x8BFB;&#x5199;&#x4E2D;&#x7684;&#x4F7F;&#x7528;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/filemap.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;do_generic_file_read
{

page_ok:  /*page&#x662F;uptodate&#x72B6;&#x6001;*/

        ...
        /* If users can be writing to this page using arbitrary
         * virtual addresses, take care about potential aliasing
         * before reading the page on the kernel side.

        &#x53EF;&#x80FD;&#x662F;&#x5E94;&#x5BF9;&#x8FD9;&#x6837;&#x7684;&#x573A;&#x666F;:
        1. &#x7528;&#x6237;&#x53D1;&#x8D77; &#x8BFB;
        2. &#x78C1;&#x76D8;&#x9A71;&#x52A8;&#x5F00;&#x59CB;&#x5DE5;&#x4F5C;, &#x4F20;&#x9001;&#x5185;&#x5BB9;&#x5230;page
        3. &#x7528;&#x6237;&#x5199; page
        4. &#x672C;&#x51FD;&#x6570;&#x7684;flush_dcache_page
        5. actor()


         */
        if (mapping_writably_mapped(mapping))
            flush_dcache_page(page);
        ...
        ret = actor(desc, page, offset, nr);//&#x6BD4;&#x5982;file_read_actor()

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="c"&gt;generic_perform_write
{


        /*
        1. &#x95EE;&#x9898;:&#x65E2;&#x7136;&#x63A5;&#x4E0B;&#x6765;&#x8981;&#x4ECE;&#x7528;&#x6237;&#x6001;&#x90A3;&#x8FB9;&#x62F7;&#x8D1D;&#x6570;&#x636E;&#x5230;page, &#x8FD9;&#x91CC;flush&#x6709;&#x5565;&#x610F;&#x4E49;?
        &#x7B54;:    &#x5B58;&#x5728;cache alias&#x7684;&#x53EF;&#x80FD;, &#x4F1A;&#x5BFC;&#x81F4;&#x540E;&#x7EED;&#x4E0D;&#x77E5;&#x9053;&#x90A3;&#x4E2A;&#x624D;&#x662F;latest&#x7684;, &#x6545;&#x62F7;&#x8D1D;&#x524D;&#x5148;flush&#x6389;,
        &#x8FD9;&#x6837;&#x5C31;&#x4E0D;&#x4F1A;&#x4E0D;&#x77E5;&#x9053;&#x7528;&#x54EA;&#x4E2A;cache line&#x4E86;.

        2. &#x573A;&#x666F;:
        cache alias in mmap + write
        https://lkml.org/lkml/2010/1/20/60

        3.  &#x53EF;&#x4EE5;&#x8003;&#x8651;&#x6539;&#x5199; 2&#x4E2D;&#x7684;&#x7A0B;&#x5E8F;, &#x8BA9;&#x6570;&#x636E;&#x7684;&#x5927;&#x5C0F; &#x5927;&#x4E8E; &#x4E00;&#x4E2A;cache line, &#x8FD9;&#x6837;&#x5C31;&#x53EF;&#x4EE5;&#x77E5;&#x9053;, 
        flush_dcache_page&#x662F;&#x4E0D;&#x662F;clean and invalid&#x4E86;

        */
        if (mapping_writably_mapped(mapping))
            flush_dcache_page(page);

        iov_iter_copy_from_user_atomic(page, i, offset, bytes);
        ...
        /*
        &#x95EE;&#x9898;:&#x8FD9;&#x91CC;flush&#x7684;&#x539F;&#x56E0;&#x662F;?
        &#x7B54;:iov_iter_copy_from_user_atomic()&#x4E2D;&#x5BF9;page&#x7684;&#x8BBF;&#x95EE;&#x662F;&#x4F7F;&#x7528;kmap_atomic, 
        &#x6620;&#x5C04;&#x5230;&#x5185;&#x6838;&#x5730;&#x5740;, &#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x503C;&#x5927;&#x4E8E;3G&#x7684;&#x5730;&#x5740;, 

        &#x800C;&#x7528;&#x6237;&#x6001;&#x5BF9;&#x8BE5;page&#x7684;&#x8BBF;&#x95EE;, &#x662F;&#x901A;&#x8FC7;&#x4E00;&#x4E2A;&#x5C0F;&#x4E8E;3G&#x7684;&#x5730;&#x5740; (map&#x7684;&#x8BDD;, &#x89E3;&#x51B3;&#x4E86;&#x6743;&#x9650;&#x95EE;&#x9898;), 
        &#x8FD9;&#x662F;&#x4E24;&#x4E2A;&#x503C;&#x4E0D;&#x540C;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;, &#x5BF9;&#x5E94;&#x540C;&#x4E00;&#x4E2A;&#x7269;&#x7406;RAM, &#x597D;&#x4E86;, D-cache aliasing.

        &#x573A;&#x666F;&#x662F;:
        1. &#x7528;&#x6237;&#x53D1;&#x8D77;&#x5199;
        2. &#x5185;&#x6838;iov_iter_copy_from_user_atomic
        3. &#x7528;&#x6237;&#x5199;page
        4. flush_dcache_page

        */
        flush_dcache_page(page);

        a_ops-&amp;gt;write_end(...); //&#x6BD4;&#x5982;ext2_write_end -&amp;gt; generic_write_end()


}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;generic_write_end -&amp;gt; block_write_end
{
    /*
    &#x5982;&#x679C;&#x8C03;&#x7528;&#x8DEF;&#x5F84;&#x662F;generic_write_end -&amp;gt; block_write_end&#x7684;&#x8BDD;,
    &#x5BF9;&#x4E8E;ext2, &#x5927;&#x6982;&#x662F;&#x6CA1;&#x6709;&#x5FC5;&#x8981;, &#x4F46;&#x5176;&#x4ED6;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x662F;&#x9700;&#x8981;&#x7684;.

    &#x53E6;&#x5916;, &#x8FD8;&#x6709;&#x5176;&#x4ED6;&#x8C03;&#x7528;&#x8DEF;&#x5F84;, &#x4E0D;&#x5355;&#x5355;&#x88AB;generic_write_end&#x8C03;&#x7528;, &#x4E0D;&#x5206;&#x6790;&#x4E86;.
    &#x90FD;&#x4E00;&#x4E2A;&#x5957;&#x8DEF;, &#x586B;page cache&#x540E;, flush&#x4E4B;.
    */
    flush_dcache_page(page);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x603B;&#x7ED3;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5927;&#x81F4;&#x5C31;&#x8FD9;&#x6837;, &#x603B;&#x7ED3;&#x4E0B;:&lt;/p&gt;

&lt;p&gt;linux-3.10.86/Documentation/cachetlb.txt&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  void flush_dcache_page(struct page *page)
    Any time the kernel writes to a page cache page, _OR_
    the kernel is about to read from a page cache page and
    user space shared/writable mappings of this page potentially
    exist, this routine is called.
    NOTE: This routine need only be called for page cache pages which can potentially ever be mapped into the address
          space of a user process.  So for example, VFS layer code
          handling vfs symlinks in the page cache need not call
          this interface at all.
    The phrase &amp;quot;kernel writes to a page cache page&amp;quot; means,
    specifically, that the kernel executes store instructions
    that dirty data in that page at the page-&amp;gt;virtual mapping
    of that page.  It is important to flush here to handle
    D-cache aliasing, to make sure these kernel stores are
    visible to user space mappings of that page.
    The corollary case is just as important, if there are users
    which have shared+writable mappings of this file, we must make
    sure that kernel reads of these pages will see the most recent
    stores done by the user. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x95EE;&#x9898;:&#x662F;&#x5199;page cache&#x4E4B;&#x524D;&#x8C03;&#x7528;flush_dcache_page, &#x8FD8;&#x662F;&#x5199;page cache&#x4E4B;&#x540E;&#x8C03;&#x7528;?&lt;br&gt;
&#x7B54;:&#x4E0A;&#x9762;&#x6709;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;... to make sure these kernel stores are visible to user space mappings of that page.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&#x6240;&#x4EE5;, &#x662F;&#x5199;page cache&#x4E4B;&#x540E;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ARM&#x7684;&#x4E00;&#x4E9B;&#x6C47;&#x7F16;</title>
      <link>https://awakening-fong.github.io/posts/arm_asm</link>
      <pubDate>2016-12-31</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. ^&#x540E;&#x7F00;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;ARM &#xAE; Developer Suite Version 1.2 Assembler Guide P128  &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;4.2.4 LDM and STM&lt;br&gt;
^ is an optional suffix. You must not use it in User mode or System mode.&lt;br&gt;
It has two purposes:&lt;br&gt;
    &#x2022; If op is LDM and reglist contains the pc (r15), in addition to the normal multiple register transfer, the SPSR is copied into the CPSR. This is for returning from exception handlers. Use this only from exception modes.&lt;br&gt;
    &#x2022; Otherwise, data is transferred into or out of the User mode registers instead of the current mode registers.  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&#x4F8B;&#x5982;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&#x53EA;&#x6709;&#x5F53;pop/LDM&#x5217;&#x8868;&#x4E2D;&#x6709;pc&#x65F6;, &#x624D;&#x4F1A;cpsr:=spsr.
&#x4F8B; &lt;code&gt;ldmia sp,{r0-pc}^&lt;/code&gt;
&#x8FD9;&#x91CC;^&#x8868;&#x793A; &#x5C06;spsr&#x590D;&#x5236;&#x5230;cpsr.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;stmdb   r0, {sp, lr}^&lt;/code&gt;
&#x8FD9;&#x91CC;^&#x8868;&#x793A;&#x8BBF;&#x95EE;&#x7684;&#x662F;usr &#x6A21;&#x5F0F;&#x4E0B;&#x7684;&#x5BC4;&#x5B58;&#x5668;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. SUBS&#x548C;MOVS(S&#x540E;&#x7F00;)&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x5728;&#x5F02;&#x5E38;&#x6A21;&#x5F0F;&#x4E0B;, &lt;code&gt;SUBS pc, lr&lt;/code&gt; &#x4F1A;&#x6267;&#x884C;CPSR:=SPSR, &#x4E14;&#x4FEE;&#x6539;PC(&#x5373;&#x8DF3;&#x8F6C;), &#x4E5F;&#x5C31;&#x662F;&#x7528;&#x6765;&#x5B8C;&#x6210;&#x4ECE;&#x5F02;&#x5E38;&#x6A21;&#x5F0F;&#x9000;&#x51FA;.&lt;/p&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. pop&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;ldm&#x548C;stm&#x6307;&#x4EE4;
registers&#x662F;&#x6309;&#x5BC4;&#x5B58;&#x5668;&#x7F16;&#x53F7;&#x6392;&#x5E8F;&#x7684;(&#x548C;&#x4E66;&#x5199;&#x987A;&#x5E8F;&#x65E0;&#x5173;), &#x4F4E;&#x7F16;&#x53F7;&#x7684;&#x5F97;&#x5230;&#x4F4E;&#x5730;&#x5740;&#x7684;, &#x9AD8;&#x7F16;&#x53F7;&#x5F97;&#x5230;&#x9AD8;&#x5730;&#x5740;&#x7684;.&lt;/p&gt;

&lt;p&gt;&#x6309;&#x7167;&#x5BC4;&#x5B58;&#x5668;&#x7F16;&#x53F7;, &#x800C;&#x4E0D;&#x662F;&#x6307;&#x4EE4;&#x4E2D;&#x7684;&#x4E66;&#x5199;&#x987A;&#x5E8F;&#x6765;&#x5165;&#x6808;&#x548C;&#x51FA;&#x6808;.&lt;/p&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. blx&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;bl&#x548C;blx&#x7684;&#x533A;&#x522B;?
&#x7B54;:blx&#x6839;&#x636E;&#x60C5;&#x51B5;&#x4F1A;&#x5207;&#x6362;&#x5230;thumb.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;BX{cond} Rm&lt;/code&gt;&lt;br&gt;
Rm is an ARM register containing the address to branchto.&lt;br&gt;
Bit 0 of Rm is not used as part of the address. &#x4E0D;&#x7BA1;&#x662F;arm&#x6216;&#x8005;thumb&#x6A21;&#x5F0F;&#x4E0B;, bit 0&#x90FD;&#x4E0D;&#x7528;&#x4F5C;&#x5BFB;&#x5740;.&lt;br&gt;
If bit 0 of Rm is set, the instruction sets the T flag in the CPSR, and the code at the destination is interpreted as Thumb code.  &#x5982;&#x679C;bit 0&#x88AB;&#x7F6E;&#x4F4D;, &#x90A3;&#x4E48;, &#x6307;&#x4EE4;&#x4F1A;&#x8BBE;&#x7F6E;CPSR&#x7684;T&#x6807;&#x5FD7;&#x4F4D;.&lt;br&gt;
If bit 0 of Rm is clear, bit 1 must not be set.  &lt;/p&gt;
</description>
    </item>
    <item>
      <title>set_buffer_new</title>
      <link>https://awakening-fong.github.io/posts/set_buffer_new</link>
      <pubDate>2016-12-31</pubDate>
      <description>&lt;div class="summary"&gt;
&#x672C;&#x6587;&#x4E3B;&#x8981;&#x89E3;&#x91CA;BH_New&#x7684;&#x542B;&#x4E49;, &#x4EE5;&#x53CA;&#x4F55;&#x65F6;&#x8BBE;&#x7F6E;&#x8BE5;&#x6807;&#x5FD7;.
&lt;/div&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1.  set_buffer_new &lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/fs/ext2/inode.c  &lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;static int ext2_get_blocks(struct inode *inode,
               sector_t iblock, unsigned long maxblocks,
               struct buffer_head *bh_result,
               int create)
{


    /*
    &#x5728;&#x67E5;&#x627E;@iblock&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;, &#x9047;&#x5230;&#x4E86;&#x6307;&#x5411;&#x5757;0&#x7684;&#x60C5;&#x51B5;.
    &#x6BD4;&#x5982;ext2_get_blocks()&#x67E5;&#x627E;iblock&#x4E3A;6&#x7684;&#x6620;&#x5C04;,
    &#x7ED3;&#x679C;ext2_inode&#x7684;i_data[5]==0

    &#x5047;&#x5B9A;&#x6587;&#x4EF6;&#x7684;0-21&#x5757;&#x90FD;&#x662F;hole:
    ext2_get_blocks()&#x4E2D;&#x67E5;&#x627E;@iblock&#x4E3A;20,
    i_data[12]==0, &#x90A3;&#x4E48;, &#x4F1A;set_buffer_new;
    &#x4E0B;&#x56DE;&#x67E5;&#x627E;@iblock&#x4E3A;21, i_data[12]!=0, 
    &#x4E0D;&#x8FC7;, i_data&#x7684;&#x4E0B;&#x4E00;&#x7EA7;, offset&#x4E3A;8&#x7684;&#x5730;&#x65B9;, &#x8FD8;&#x662F;0 ,
    &#x6240;&#x4EE5;, &#x4F9D;&#x65E7;set_buffer_new.
    &#x4E5F;&#x5C31;&#x662F;&#x8BF4;, &#x67E5;&#x627E;@iblock&#x4E3A;20, &#x53EA;&#x89E6;&#x53D1;1&#x6B21;set_buffer_new, &#x800C;&#x4E0D;&#x662F;2&#x6B21;, 
    &#x56E0;&#x4E3A;&#x662F;&#x5728;&#x5206;&#x914D;&#x597D;chain&#x6240;&#x9700;&#x7684;&#x5757;&#x540E;, &#x624D;&#x8C03;&#x7528;&#x4E00;&#x6B21;set_buffer_new.
    &#x7136;&#x540E;&#x67E5;&#x627E;@iblock&#x4E3A;21, &#x4F1A;&#x89E6;&#x53D1;1&#x6B21;set_buffer_new;


    &#x95EE;&#x9898;:buffer_new()&#x610F;&#x5473;&#x7740;&#x4EC0;&#x4E48;?
    &#x7B54;:&#x610F;&#x5473;&#x7740;, &#x5C06;&#x539F;&#x5148;&#x8FD8;&#x4E0D;&#x5C5E;&#x4E8E;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x5757;, &#x5212;&#x5206;&#x7ED9;&#x4E86;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;.

    */
    set_buffer_new(bh_result);
got_it:
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. unmap_underlying_metadata&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code class="c"&gt;
__block_write_begin
{
    ...
    err = get_block(inode, block, bh, 1); //&#x6BD4;&#x5982;ext2_get_blocks
    if (err)
        break;
    if (buffer_new(bh)) {
        unmap_underlying_metadata(bh-&amp;gt;b_bdev,
                    bh-&amp;gt;b_blocknr);
        ...
    }

}


/*
 __block_write_full_page
 {
    create_page_buffers //&#x8FD9;&#x91CC;&#x6CA1;&#x6709;&#x4ECE;&#x88F8;&#x5757;&#x8BBE;&#x5907;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x4E2D;&#x67E5;&#x627E;
    unmap_underlying_metadata
 }
 */
void unmap_underlying_metadata(struct block_device *bdev, sector_t block)
{
    struct buffer_head *old_bh;

    might_sleep();

    old_bh = __find_get_block_slow(bdev, block);//&#x4ECE;&#x88F8;&#x5757;&#x8BBE;&#x5907;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x4E2D;&#x67E5;&#x627E;
    if (old_bh) {
        clear_buffer_dirty(old_bh);
        /*
        &#x95EE;&#x9898;:&#x8FD9;&#x91CC;&#x6CA1;&#x6709;&#x83B7;&#x53D6;&#x9501;, &#x53EA;&#x662F;&#x7B49;&#x5F85;&#x4ED6;&#x4EBA;&#x628A;&#x9501;&#x91CA;&#x653E;&#x6389;, &#x610F;&#x4E49;&#x4F55;&#x5728;?
        &#x7B54;:&#x8BA9;&#x4E24;&#x8005;&#x4E0D;&#x8981;&#x76F8;&#x4E92;&#x5E72;&#x6270;.
        */
        wait_on_buffer(old_bh);
        clear_buffer_req(old_bh);
        ...
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>&#x8BFB;&#x5199;&#x51FD;&#x6570;&#x4E2D;&#x7684;lock_page</title>
      <link>https://awakening-fong.github.io/posts/read_write_lock_page</link>
      <pubDate>2016-12-30</pubDate>
      <description>&lt;div class="summary"&gt;
do_generic_file_read&#x548C;generic_perform_write&#x4E2D;&#x5BF9;&#x9501;&#x7684;&#x5904;&#x7406;.  &lt;br&gt;  
&#x4ECE;&#x78C1;&#x76D8;&#x8BFB;&#x5230;RAM&#x4E2D;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;, page&#x9700;&#x8981;&#x5904;&#x4E8E;lock&#x72B6;&#x6001;.  &lt;br&gt;
&#x628A;&#x7528;&#x6237;&#x7684;&#x6570;&#x636E;&#x62F7;&#x8D1D;&#x5230;page cahe, &#x8BE5;&#x8FC7;&#x7A0B;&#x4E5F;&#x8981;&#x5904;&#x7406;&#x597D;lock page&#x95EE;&#x9898;.
&lt;/div&gt;

&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. do_generic_file_read&#x4E2D;&#x7684;lock page&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/filemap.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;do_generic_file_read
{

    if (!PageUptodate(page)) {

        if ( ... || !mapping-&amp;gt;a_ops-&amp;gt;is_partially_uptodate)
            goto page_not_up_to_date;

        unlock_page(page);

    }

page_not_up_to_date:
    error = lock_page_killable(page);

page_not_up_to_date_locked:
...
    /* Start the actual read. The read will unlock the page. */
    error = mapping-&amp;gt;a_ops-&amp;gt;readpage(filp, page);

    if (!PageUptodate(page)) {
                /*
                a_ops-&amp;gt;readpage&#x4F1A;&#x7ACB;&#x523B;&#x8FD4;&#x56DE;&#x5417;? 
                &#x7B54;:&#x662F;&#x7684;, &#x901A;&#x5E38;&#x662F;submit_bh&#x6216;submit_bio&#x540E;&#x5C31;&#x8FD4;&#x56DE;&#x4E86;, 
                &#x6240;&#x4EE5;, lock_page_killable()&#x5C31;&#x662F;&#x5728;
                &#x7B49;a_ops-&amp;gt;readpage&#x4E2D;&#x7684;&#x8BBE;&#x7F6E;&#x7684;I/O completion handler&#x7684;unlock.
                &#x6BD4;&#x5982;end_buffer_async_read&#x4E2D;&#x7684;unlock_page();
                */
                error = lock_page_killable(page);
                ...
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&#x8BFB;&#x7684;&#x53D1;&#x8D77;&#x8005; lock_page&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&#x8BFB;&#x7684;&#x53D1;&#x8D77;&#x8005; a_ops-&amp;gt;readpage()&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&#x8BFB;&#x7684;&#x53D1;&#x8D77;&#x8005;&#x4E0D;&#x5FC5;unlock_page, &#x800C;&#x662F;&#x7531;io complete handler&#x6765;&#x5B8C;&#x6210;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. generic_perform_write &#x586B;&#x5145;page cache&lt;/h4&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code class="c"&gt;generic_perform_write
{

    a_ops-&amp;gt;write_begin(...); //&#x8FD9;&#x91CC;&#x9762;lock_page
    ...
    copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);
    ...
    a_ops-&amp;gt;write_end(...); //&#x8FD9;&#x91CC;&#x9762;unlock_page
}


block_write_begin
{
    page = grab_cache_page_write_begin(mapping, index, flags); //&#x5185;&#x6709;lock page

}

ext2_write_end -&amp;gt; generic_write_end()
{
    ...
    /* &#x586B;&#x597D;page cache, &#x5269;&#x4E0B;&#x662F;write back&#x7684;&#x4E8B;&#x4E86;*/
    unlock_page(page);

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. write_cache_pages &#x56DE;&#x5199;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/mm/page-writeback.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;write_cache_pages
{

    while (...) {

        nr_pages = pagevec_lookup_tag(&amp;amp;pvec, mapping, &amp;amp;index, tag,
                  min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);
        if (nr_pages == 0)
            break;

        ...
            lock_page(page);
        ...
            /*&#x5E38;&#x89C1;&#x7684;&#x6709;__mpage_writepage &#x6216;&#x8005; __writepage*/
            ret = (*writepage)(page, wbc, data);


}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="c"&gt;__block_write_full_page
{

    /*
    &#x95EE;&#x9898;:&#x8FD9;&#x4E2A;&#x662F;&#x548C;&#x54EA;&#x91CC;&#x5BF9;&#x5E94;&#x7684;?
    &#x7B54;:
    write_cache_pages
    |--lock_page
    |--writepage -&amp;gt; __writepage -&amp;gt; ext2_writepage -&amp;gt; block_write_full_page -&amp;gt; block_write_full_page_endio -&amp;gt; __block_write_full_page
    */
    unlock_page(page);
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_3"&gt;&lt;h4&gt;4. more ... &lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;Documentation/filesystems/Locking&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ext2 disk layout</title>
      <link>https://awakening-fong.github.io/posts/ext2_layout</link>
      <pubDate>2016-12-30</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt; 1.&#x76EE;&#x6807;/&#x4EFB;&#x52A1;&lt;/h4&gt;&lt;/h1&gt;

&lt;div class="summary"&gt;
&#x4E3B;&#x8981;&#x4E3A;&#x4E86;&#x9A8C;&#x8BC1;&#x5BF9;ext2&#x7684; Disk Organization&#x7684;&#x7406;&#x89E3;, &#x8BF8;&#x5982;Block Group Descriptor, Inode Table&#x4E4B;&#x7C7B;.&lt;br/&gt;

&#x7ED9;&#x5B9A;&#x4E00;&#x4E2A;ext2&#x955C;&#x50CF;, &#x904D;&#x5386;&#x5176;&#x6240;&#x6709;&#x6587;&#x4EF6;, &#x5E76;&#x663E;&#x793A;&#x6587;&#x4EF6;&#x5185;&#x5BB9;.&lt;br/&gt;

&#x5047;&#x5B9A;&#x8BE5;&#x955C;&#x50CF;&#x7684;&#x6587;&#x4EF6;&#x5927;&#x5C0F;&#x90FD;&#x6BD4;&#x8F83;&#x5C0F;, &#x4E0D;&#x9700;&#x8981;indirect pointer.
&lt;/div&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2.&#x6E90;&#x7801;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;ext2_parse.c&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;

#define dbg_print(fmt,args...)\
    printf(&amp;quot;%s(),%d:&amp;quot;fmt, __func__, __LINE__, ##args)
#define info_print(fmt,args...)\
        printf(&amp;quot;%s(),%d:&amp;quot;fmt, __func__, __LINE__, ##args)

typedef unsigned int __le32;
typedef unsigned int __u32;
typedef unsigned short __le16;
typedef unsigned short __u16;
typedef unsigned char __u8;
/*
&#x4E3B;&#x8981;&#x4E3A;&#x4E86;&#x9A8C;&#x8BC1;&#x5BF9;ext2&#x7684; Disk Organization&#x7684;&#x7406;&#x89E3;, &#x8BF8;&#x5982;Block Group Descriptor, Inode Table&#x4E4B;&#x7C7B;.
1. &#x4E0D;&#x8003;&#x8651;&#x5927;&#x5C0F;&#x7AEF;&#x95EE;&#x9898;
2. &#x5904;&#x7406;file hole&#x7684;&#x60C5;&#x51B5;
3. &#x5904;&#x7406;block size&#x4E0D;&#x4E3A;1024&#x7684;&#x60C5;&#x51B5;
   &#x7B80;&#x5316;, &#x5FFD;&#x7565;indirect pointer&#x7684;&#x60C5;&#x51B5;
*/
enum {
    EXT2_FT_UNKNOWN        = 0,
    EXT2_FT_REG_FILE    = 1,
    EXT2_FT_DIR        = 2,
    EXT2_FT_CHRDEV        = 3,
    EXT2_FT_BLKDEV        = 4,
    EXT2_FT_FIFO        = 5,
    EXT2_FT_SOCK        = 6,
    EXT2_FT_SYMLINK        = 7,
    EXT2_FT_MAX
};

struct ext2_super_block {
    __le32    s_inodes_count;        /* Inodes count */
    __le32    s_blocks_count;        /* Blocks count */
    __le32    s_r_blocks_count;    /* Reserved blocks count */
    __le32    s_free_blocks_count;    /* Free blocks count */
    __le32    s_free_inodes_count;    /* Free inodes count */
    __le32    s_first_data_block;    /* First Data Block */
    /*[Professional Linux Kernel Architecture] 
    Currently, the three values 0, 1, and 2 are used
    &#x8868;&#x793A; block sizes of 20 &#xD7; 1,024 = 1,024, 21 &#xD7; 1,024 = 2,048,
    and 22 &#xD7; 1,024 = 4,096 bytes
    */
    __le32    s_log_block_size;    /* Block size */
    __le32    s_log_frag_size;    /* Fragment size */
    __le32    s_blocks_per_group;    /* # Blocks per group */
    __le32    s_frags_per_group;    /* # Fragments per group */
    __le32    s_inodes_per_group;    /* # Inodes per group */
    __le32    s_mtime;        /* Mount time */
    __le32    s_wtime;        /* Write time */
    __le16    s_mnt_count;        /* Mount count */
    __le16    s_max_mnt_count;    /* Maximal mount count */
    __le16    s_magic;        /* Magic signature */
    __le16    s_state;        /* File system state */
    __le16    s_errors;        /* Behaviour when detecting errors */
    __le16    s_minor_rev_level;     /* minor revision level */
    __le32    s_lastcheck;        /* time of last check */
    __le32    s_checkinterval;    /* max. time between checks */
    __le32    s_creator_os;        /* OS */
    __le32    s_rev_level;        /* Revision level */
    __le16    s_def_resuid;        /* Default uid for reserved blocks */
    __le16    s_def_resgid;        /* Default gid for reserved blocks */
    /*
     * These fields are for EXT2_DYNAMIC_REV superblocks only.
     *
     * Note: the difference between the compatible feature set and
     * the incompatible feature set is that if there is a bit set
     * in the incompatible feature set that the kernel doesn&amp;#39;t
     * know about, it should refuse to mount the filesystem.
     * 
     * e2fsck&amp;#39;s requirements are more strict; if it doesn&amp;#39;t know
     * about a feature in either the compatible or incompatible
     * feature set, it must abort and not try to meddle with
     * things it doesn&amp;#39;t understand...
     */
    __le32    s_first_ino;         /* First non-reserved inode */
    __le16   s_inode_size;         /* size of inode structure */
    __le16    s_block_group_nr;     /* block group # of this superblock */
    __le32    s_feature_compat;     /* compatible feature set */
    __le32    s_feature_incompat;     /* incompatible feature set */
    __le32    s_feature_ro_compat;     /* readonly-compatible feature set */
    __u8    s_uuid[16];        /* 128-bit uuid for volume */
    char    s_volume_name[16];     /* volume name */
    char    s_last_mounted[64];     /* directory where last mounted */
    __le32    s_algorithm_usage_bitmap; /* For compression */
    /*
     * Performance hints.  Directory preallocation should only
     * happen if the EXT2_COMPAT_PREALLOC flag is on.
     */
    __u8    s_prealloc_blocks;    /* Nr of blocks to try to preallocate*/
    __u8    s_prealloc_dir_blocks;    /* Nr to preallocate for dirs */
    __u16    s_padding1;
    /*
     * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.
     */
    __u8    s_journal_uuid[16];    /* uuid of journal superblock */
    __u32    s_journal_inum;        /* inode number of journal file */
    __u32    s_journal_dev;        /* device number of journal file */
    __u32    s_last_orphan;        /* start of list of inodes to delete */
    __u32    s_hash_seed[4];        /* HTREE hash seed */
    __u8    s_def_hash_version;    /* Default hash version to use */
    __u8    s_reserved_char_pad;
    __u16    s_reserved_word_pad;
    __le32    s_default_mount_opts;
     __le32    s_first_meta_bg;     /* First metablock block group */
    __u32    s_reserved[190];    /* Padding to the end of the block */
};

struct ext2_group_desc
{    
    __le32    bg_block_bitmap;        /* Blocks bitmap block */
    __le32    bg_inode_bitmap;        /* Inodes bitmap block */
    __le32    bg_inode_table;        /* Inodes table block */
    __le16    bg_free_blocks_count;    /* Free blocks count */
    __le16    bg_free_inodes_count;    /* Free inodes count */
    __le16    bg_used_dirs_count;    /* Directories count */
    __le16    bg_pad;
    __le32    bg_reserved[3];
};

struct ext2_inode {
    __le16    i_mode;        /* File mode */
    __le16    i_uid;        /* Low 16 bits of Owner Uid */
    __le32    i_size;        /* Size in bytes */
    __le32    i_atime;    /* Access time */
    __le32    i_ctime;    /* Creation time */
    __le32    i_mtime;    /* Modification time */
    __le32    i_dtime;    /* Deletion Time */
    __le16    i_gid;        /* Low 16 bits of Group Id */
    __le16    i_links_count;    /* Links count */
    __le32    i_blocks;    /* Blocks count  &#x7528;&#x6765;&#x5904;&#x7406;file hole, &#x5355;&#x4F4D;&#x4E3A;512&#x5B57;&#x8282; */
    __le32    i_flags;    /* File flags */
    union {
        struct {
            __le32  l_i_reserved1;
        } linux1;
        #if 0 //awakening-fong.github.io &#x53EA;&#x7BA1;linux&#x7684;
        struct {
            __le32  h_i_translator;
        } hurd1;
        struct {
            __le32  m_i_reserved1;
        } masix1;
        #endif
    } osd1;                /* OS dependent 1 */
    #define EXT2_N_BLOCKS (15)
    __le32    i_block[EXT2_N_BLOCKS];/* Pointers to blocks */
    __le32    i_generation;    /* File version (for NFS) */
    __le32    i_file_acl;    /* File ACL */
    __le32    i_dir_acl;    /* Directory ACL */
    __le32    i_faddr;    /* Fragment address */
    union {
        struct {
            __u8    l_i_frag;    /* Fragment number */
            __u8    l_i_fsize;    /* Fragment size */
            __u16    i_pad1;
            __le16    l_i_uid_high;    /* these 2 fields    */
            __le16    l_i_gid_high;    /* were reserved2[0] */
            __u32    l_i_reserved2;
        } linux2;
        #if 0 //awakening-fong.github.io &#x53EA;&#x7BA1;linux&#x7684;
        struct {
            __u8    h_i_frag;    /* Fragment number */
            __u8    h_i_fsize;    /* Fragment size */
            __le16    h_i_mode_high;
            __le16    h_i_uid_high;
            __le16    h_i_gid_high;
            __le32    h_i_author;
        } hurd2;
        struct {
            __u8    m_i_frag;    /* Fragment number */
            __u8    m_i_fsize;    /* Fragment size */
            __u16    m_pad1;
            __u32    m_i_reserved2[2];
        } masix2;
        #endif
    } osd2;                /* OS dependent 2 */
};
struct ext2_dir_entry_2 {
    __le32    inode;            /* Inode number */
    __le16    rec_len;        /* Directory entry length */
    __u8    name_len;        /* Name length */
    __u8    file_type;
    char    name[];            /* File name, up to EXT2_NAME_LEN */
};
struct ext2_dir_entry {
    __le32    inode;            /* Inode number */
    __le16    rec_len;        /* Directory entry length */
    __le16    name_len;        /* Name length */
    char    name[];            /* File name, up to EXT2_NAME_LEN */
};



int inodes_per_group;
int block_size=0;
int blocks_per_group;
void list_file(char *buf,struct ext2_inode *dir_inode);
static int FileIn( const char *strFile, unsigned char *inBuff)
{

    FILE *p_in=NULL;
    if((p_in = fopen(strFile,&amp;quot;rb&amp;quot;)) == NULL)
    {
       dbg_print(&amp;quot;open file:%s error!\n&amp;quot;,strFile);
       return -1;
    }

    fseek(p_in, 0L, SEEK_END);
    unsigned int file_size = ftell(p_in);
    fseek(p_in, 0L,SEEK_SET);
    dbg_print(&amp;quot;ftell size %d\n&amp;quot;, file_size);

    ssize_t nread=0;
    size_t nleft =file_size;
    unsigned char *bufp = inBuff;
    while (nleft &amp;gt; 0)
    {
       if ((nread = fread(bufp, nleft,1,p_in)) == -1) 
       {
            if (errno == EINTR) /* interrupted by signal handler return */
                nread = 0;      /* and call read() again */
            else
                return -1;      /* errno set by read() */
        }
        else if (nread == 0)
            break;              /* EOF */
        nleft -= nread;
        bufp += nread;
    }

    dbg_print(&amp;quot;file read size %u\n&amp;quot;, file_size);
    fclose(p_in);
    p_in=NULL;
    return file_size;

}


//group descriptors&#x5206;&#x5E03;&#x5728;&#x5404;&#x4E2A;block group&#x4E2D;&#x7684;&#x5185;&#x5BB9;&#x662F;&#x4E00;&#x6837;&#x7684;.
struct ext2_inode *get_inode_buf(char *buf, int inode)
{
    //inode&#x7F16;&#x53F7;&#x4ECE;1&#x5F00;&#x59CB;.
    int group_th=inode/inodes_per_group;
    char *p;
//    dbg_print(&amp;quot;group_th:%d\n&amp;quot;,group_th);    
    int first_desc_table_nr_block=((1024+1024)+(block_size-1))/block_size;//copy from main()
    struct ext2_group_desc *p_desc =(struct ext2_group_desc *) (buf + first_desc_table_nr_block * block_size);
    p_desc+=group_th;
    int dst_block=p_desc-&amp;gt;bg_inode_table;
//    dbg_print(&amp;quot;bg_inode_table:%d\n&amp;quot;,dst_block);
    //block&#x7F16;&#x53F7;&#x4ECE;0&#x5F00;&#x59CB;
    p=buf + dst_block*block_size;
    //inode&#x7F16;&#x53F7;&#x4ECE;1&#x5F00;&#x59CB;.
    p+=(inode-1)%inodes_per_group * sizeof(struct ext2_inode);
    return (struct ext2_inode*)p;
}


void read_from_ext2_dir_entry_2(char *buf,struct ext2_dir_entry_2 *entry)
{
    if(EXT2_FT_DIR==entry-&amp;gt;file_type)
    {
        dbg_print(&amp;quot;start  list file for %s\n&amp;quot;,entry-&amp;gt;name);
        struct ext2_inode *dir_inode=get_inode_buf(buf, entry-&amp;gt;inode);
        list_file(buf,dir_inode);
        dbg_print(&amp;quot;end of list_file %s\n&amp;quot;,entry-&amp;gt;name);
    }
    else if(EXT2_FT_REG_FILE==entry-&amp;gt;file_type)
    {
        struct ext2_inode *file_inode=get_inode_buf(buf, entry-&amp;gt;inode);

        int sum_size=0;
        int j=0;
        while(1)
        {
            int i=0;
            int block_th=file_inode-&amp;gt;i_block[j]; 
//            dbg_print(&amp;quot;block_th:%d\n&amp;quot;,block_th);
            /*
            &#x8FD9;&#x4E2A;&#x662F;&#x9519;&#x8BEF;&#x7684;&#x5199;&#x6CD5;, &#x56E0;&#x4E3A;&#x6CA1;&#x6709;&#x8003;&#x8651;file hole&#x7684;&#x60C5;&#x51B5;.
            if(0==block_th)
                break;
            */
            if(0==block_th)
            {

                //XXX     &#x6682;&#x4E0D;&#x8003;&#x8651;indirect&#x7684;&#x60C5;&#x51B5;
                if( (j+1)*block_size&amp;lt;file_inode-&amp;gt;i_size )
                {
                    j++;
                    continue;
                }
                else
                    break;

            }


            //XXX     &#x6682;&#x4E0D;&#x8003;&#x8651;indirect&#x7684;&#x60C5;&#x51B5;
            //dbg_print(&amp;quot;block_th:%d\n&amp;quot;,block_th);
            char *p=buf + block_th* block_size;

            //dbg_print(&amp;quot;inode i_size:%d\n&amp;quot;,root_inode-&amp;gt;i_size);
            do
            {
                printf(&amp;quot;%c&amp;quot;,p[i++]);
                sum_size++;
            }while(i&amp;lt;block_size &amp;amp;&amp;amp; sum_size &amp;lt; file_inode-&amp;gt;i_size );
            j++;
        }
    }
}

void list_file(char *buf,struct ext2_inode *dir_inode)
{

    int i=0;
    while(1)
    {
        int block_th=dir_inode-&amp;gt;i_block[i]; 
        //dbg_print(&amp;quot;block_th:%d\n&amp;quot;,block_th);

        //a regular file&#x624D;&#x6709;file hole
        if(0==block_th)
            break;
        char *p=buf + block_th* block_size;
        struct ext2_dir_entry_2*p_dir_entry=(struct ext2_dir_entry_2*)p;

        int sum_size=0;
        //dbg_print(&amp;quot;inode i_size:%d\n&amp;quot;,dir_inode-&amp;gt;i_size);

        if(0==p_dir_entry-&amp;gt;inode) //https://courses.cs.washington.edu/courses/cse451/09sp/projects/project3light/project3_light.html
        {
            dbg_print(&amp;quot;p_dir_entry inode:%d\n&amp;quot;,p_dir_entry-&amp;gt;inode);
            break;
        }
        /*
        if(0==strlen(p_dir_entry-&amp;gt;name))
            break;
        */    
        do
        {
//            if(EXT2_FT_DIR==p_dir_entry-&amp;gt;file_type)
                //info_print(&amp;quot;dir:\n&amp;quot;);

            //dbg_print(&amp;quot;%s  lel:%d\n&amp;quot;,p_dir_entry-&amp;gt;name,strlen(p_dir_entry-&amp;gt;name));
            dbg_print(&amp;quot;%s\n&amp;quot;,p_dir_entry-&amp;gt;name);
            if(!(strlen(p_dir_entry-&amp;gt;name)==1 &amp;amp;&amp;amp; p_dir_entry-&amp;gt;name[0]==&amp;#39;.&amp;#39;)
            &amp;amp;&amp;amp; !(strlen(p_dir_entry-&amp;gt;name)==2 &amp;amp;&amp;amp; 0==strcmp(p_dir_entry-&amp;gt;name,&amp;quot;..&amp;quot;)))
                read_from_ext2_dir_entry_2(buf,p_dir_entry);
            sum_size+=p_dir_entry-&amp;gt;rec_len;
            p+=p_dir_entry-&amp;gt;rec_len;
            //dbg_print(&amp;quot;sum_size:%d\n&amp;quot;,sum_size);//tmp_fong
            p_dir_entry=(struct ext2_dir_entry_2*)p;
        //}while(sum_size&amp;lt;block_size &amp;amp;&amp;amp; sum_size&amp;lt;dir_inode-&amp;gt;i_size);
        /*&#x4E3A;&#x4F55;&#x8981;sum_size&amp;lt;block_size ???*/
        }while(sum_size&amp;lt;block_size &amp;amp;&amp;amp; sum_size&amp;lt;dir_inode-&amp;gt;i_blocks*512); //XXX &#x5148;&#x4E0D;&#x7BA1;file hole
        //}while(sum_size&amp;lt;dir_inode-&amp;gt;i_blocks*512); //XXX &#x5148;&#x4E0D;&#x7BA1;file hole
        i++;

    }

}


int main(int argc, char *argv[])
{
int file_size=-1;
unsigned char *buf=(unsigned char *)malloc(70*1024*1024);
if (!buf)
{
dbg_print(&amp;quot;malloc fail\n&amp;quot;);
return -1;
}
file_size=FileIn(argv[1],buf);
if(file_size&amp;lt;0)
{
dbg_print(&amp;quot;FileIn fail\n&amp;quot;);
return -1;
}

struct ext2_super_block super_block;
memset(&amp;amp;super_block, 0, sizeof(super_block));
/*
The Superblock is always located at byte 1024 from the beginning of the volume and is exactly 1024 bytes in length.
(&#x6765;&#x81EA; http://wiki.osdev.org/Ext2)
*/
memcpy(&amp;amp;super_block, buf+1024, sizeof(super_block));
dbg_print(&amp;quot;sizeof(super_block):%d\n&amp;quot;,sizeof(super_block));
dbg_print(&amp;quot;s_magic:0x%x\n&amp;quot;,super_block.s_magic);
assert(super_block.s_magic==0xef53);
dbg_print(&amp;quot;s_log_block_size:%d\n&amp;quot;,super_block.s_log_block_size);

if(0==super_block.s_log_block_size)
    block_size=1024;
else if(1==super_block.s_log_block_size)
    block_size=2048;
else if(2==super_block.s_log_block_size)
    block_size=4096;
else
    exit(-1);
dbg_print(&amp;quot;block_size:%d\n&amp;quot;,block_size);

inodes_per_group=super_block.s_inodes_per_group;
blocks_per_group=super_block.s_blocks_per_group;


/*&#x904D;&#x5386;group*/
const int nr_group=(super_block.s_blocks_count+blocks_per_group -1)/blocks_per_group;
dbg_print(&amp;quot;nr_group:%d\n&amp;quot;,nr_group);
int i=0;
struct ext2_super_block *p_sb;
char *p;
for( i=0; i&amp;lt;nr_group ; i++  )
{
    if(i==0)
        p = buf + 1024 + i*blocks_per_group * block_size;
    else
        p = buf + 1024*(1024&amp;gt;=block_size) + i*blocks_per_group * block_size;
    p_sb=(struct ext2_super_block *)p;
//        __le16    s_block_group_nr;     /* block group # of this superblock */
    dbg_print(&amp;quot;s_block_group_nr:%d\n&amp;quot;,p_sb-&amp;gt;s_block_group_nr);
}


/*&#x904D;&#x5386;group descriptors*/
int first_desc_table_nr_block=((1024+1024)+(block_size-1))/block_size;
struct ext2_group_desc *p_desc =(struct ext2_group_desc *) (buf + first_desc_table_nr_block * block_size);
for( i=0; i&amp;lt;nr_group ; i++)
{
dbg_print(&amp;quot;group %d:\n&amp;quot;,i);
dbg_print(&amp;quot;bg_block_bitmap:%d\n&amp;quot;,p_desc-&amp;gt;bg_block_bitmap);
dbg_print(&amp;quot;bg_inode_bitmap:%d\n&amp;quot;,p_desc-&amp;gt;bg_inode_bitmap);
dbg_print(&amp;quot;bg_inode_table:%d\n\n&amp;quot;,p_desc-&amp;gt;bg_inode_table);
p_desc += 1;
}

//&#x9012;&#x5F52;&#x663E;&#x793A; &#x5404;&#x76EE;&#x5F55;&#x4E0B;&#x7684;&#x6587;&#x4EF6;&#x540D;&#x53CA;&#x5185;&#x5BB9;
struct ext2_inode *root_inode=get_inode_buf(buf,2); //root dir
dbg_print(&amp;quot;root_inode-&amp;gt;i_size:%d\n&amp;quot;,root_inode-&amp;gt;i_size);
list_file(buf,root_inode);
//free(buf); we donot care this.
return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_2"&gt;&lt;h4&gt;3. &#x9A8C;&#x8BC1;&lt;/h4&gt;&lt;/h1&gt;

&lt;h2 id="toc_3"&gt;&lt;h4&gt;3.1 &#x811A;&#x672C;&lt;/h4&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class="shell"&gt;$ cat ext2_layout.sh 
file_img=&amp;quot;img.70M_2048&amp;quot;
rm $file_img a.out
orig_path=$PWD
dd if=/dev/zero of=$file_img bs=1M count=70
/sbin/mke2fs -b 2048 -O ^sparse_super,^has_journal,^dir_index,^resize_inode $file_img &amp;lt;&amp;lt;EOF
y
EOF
mkdir /mnt/ext2
umount /mnt/ext2
/sbin/losetup -d /dev/loop0
/sbin/losetup  /dev/loop0  $file_img
/sbin/mkfs.ext2 /dev/loop0
mount -t ext2 /dev/loop0 /mnt/ext2/
cd /mnt/ext2
echo file_root_01_01234567aaaaaaaabbbbbbbbccccccccdddddddd &amp;gt;&amp;gt; root_01
echo file_root_02_01234567aaaaaaaabbbbbbbbccccccccddddddddeeeeeeee &amp;gt;&amp;gt; root_02
echo file_root_03_01234567aaaaaaaabbbbbbbbccccccccddddddddffffffff &amp;gt;&amp;gt; root_03
mkdir d.home d.lib d.usr d.boot
cd d.boot/
echo file_in_d.boot_file00_named_file00_end_of_file &amp;gt;&amp;gt; file00
echo file_in_d.boot_file01_named_file01_end_of_file &amp;gt;&amp;gt; file01
echo -n &amp;quot;X&amp;quot; | dd of=file02_file_hole bs=1024 seek=6
sync
sync
umount /mnt/ext2
sync
echo $orig_path &amp;gt; /dev/stderr
cd $orig_path
gcc -m32 ext2_parse.c &amp;amp;&amp;amp; ./a.out $file_img
#dumpe2fs $file_img
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_4"&gt;&lt;h4&gt;3.2 &#x811A;&#x672C;&#x6267;&#x884C;&#x7ED3;&#x679C;&lt;/h4&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class="shell"&gt;$ sudo sh ext2_layout.sh 
70+0 records in
70+0 records out
73400320 bytes (73 MB) copied, 0.8425 seconds, 87.1 MB/s
mke2fs 1.39 (29-May-2006)
img.70M_2048 is not a block special device.
Proceed anyway? (y,n) Filesystem label=
OS type: Linux
Block size=2048 (log=1)
Fragment size=2048 (log=1)
17952 inodes, 35840 blocks
1792 blocks (5.00%) reserved for the super user
First data block=0
3 block groups
16384 blocks per group, 16384 fragments per group
5984 inodes per group
Superblock backups stored on blocks: 
    16384, 32768

Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 28 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
mkdir: cannot create directory `/mnt/ext2&amp;#39;: File exists
mke2fs 1.39 (29-May-2006)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
17928 inodes, 71680 blocks
3584 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67371008
9 block groups
8192 blocks per group, 8192 fragments per group
1992 inodes per group
Superblock backups stored on blocks: 
    8193, 24577, 40961, 57345

Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 22 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
0+1 records in
0+1 records out
1 byte (1 B) copied, 7.9348e-05 seconds, 12.6 kB/s
umount: /mnt/ext2: device is busy
umount: /mnt/ext2: device is busy
/opt/drivr_study/ext2_parse
FileIn(),227:ftell size 73400320
FileIn(),247:file read size 73400320
main(),428:sizeof(super_block):1024
main(),429:s_magic:0xef53
main(),431:s_log_block_size:0
main(),441:block_size:1024
main(),449:nr_group:9
main(),461:s_block_group_nr:0
main(),461:s_block_group_nr:1
main(),461:s_block_group_nr:0
main(),461:s_block_group_nr:3
main(),461:s_block_group_nr:0
main(),461:s_block_group_nr:5
main(),461:s_block_group_nr:0
main(),461:s_block_group_nr:7
main(),461:s_block_group_nr:0
main(),470:group 0:
main(),471:bg_block_bitmap:259
main(),472:bg_inode_bitmap:260
main(),473:bg_inode_table:261

main(),470:group 1:
main(),471:bg_block_bitmap:8451
main(),472:bg_inode_bitmap:8452
main(),473:bg_inode_table:8453

main(),470:group 2:
main(),471:bg_block_bitmap:16385
main(),472:bg_inode_bitmap:16386
main(),473:bg_inode_table:16387

main(),470:group 3:
main(),471:bg_block_bitmap:24835
main(),472:bg_inode_bitmap:24836
main(),473:bg_inode_table:24837

main(),470:group 4:
main(),471:bg_block_bitmap:32769
main(),472:bg_inode_bitmap:32770
main(),473:bg_inode_table:32771

main(),470:group 5:
main(),471:bg_block_bitmap:41219
main(),472:bg_inode_bitmap:41220
main(),473:bg_inode_table:41221

main(),470:group 6:
main(),471:bg_block_bitmap:49153
main(),472:bg_inode_bitmap:49154
main(),473:bg_inode_table:49155

main(),470:group 7:
main(),471:bg_block_bitmap:57603
main(),472:bg_inode_bitmap:57604
main(),473:bg_inode_table:57605

main(),470:group 8:
main(),471:bg_block_bitmap:65537
main(),472:bg_inode_bitmap:65538
main(),473:bg_inode_table:65539

main(),479:root_inode-&amp;gt;i_size:1024
list_file(),386:.
list_file(),386:..
list_file(),386:lost+found
read_from_ext2_dir_entry_2(),300:start  list file for lost+found
list_file(),386:.
list_file(),386:..
list_file(),373:p_dir_entry inode:0
read_from_ext2_dir_entry_2(),303:end of list_file lost+found
list_file(),386:root_01
file_root_01_01234567aaaaaaaabbbbbbbbccccccccdddddddd
list_file(),386:root_02
file_root_02_01234567aaaaaaaabbbbbbbbccccccccddddddddeeeeeeee
list_file(),386:root_03
file_root_03_01234567aaaaaaaabbbbbbbbccccccccddddddddffffffff
list_file(),386:d.home
read_from_ext2_dir_entry_2(),300:start  list file for d.home
list_file(),386:.
list_file(),386:..
read_from_ext2_dir_entry_2(),303:end of list_file d.home
list_file(),386:d.lib
read_from_ext2_dir_entry_2(),300:start  list file for d.lib
list_file(),386:.
list_file(),386:..
read_from_ext2_dir_entry_2(),303:end of list_file d.lib
list_file(),386:d.usr
read_from_ext2_dir_entry_2(),300:start  list file for d.usr
list_file(),386:.
list_file(),386:..
read_from_ext2_dir_entry_2(),303:end of list_file d.usr
list_file(),386:d.boot
read_from_ext2_dir_entry_2(),300:start  list file for d.boot
list_file(),386:.
list_file(),386:..
list_file(),386:file00
file_in_d.boot_file00_named_file00_end_of_file
list_file(),386:file01
file_in_d.boot_file01_named_file01_end_of_file
list_file(),386:file02_file_hole
Xread_from_ext2_dir_entry_2(),303:end of list_file d.boot
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_5"&gt;&lt;h4&gt;3.3 dumpe2fs&lt;/h4&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class="shell"&gt;$ dumpe2fs img.70M_2048 
dumpe2fs 1.39 (29-May-2006)
Filesystem volume name:   &amp;lt;none&amp;gt;
Last mounted on:          &amp;lt;not available&amp;gt;
Filesystem UUID:          dc4c52d6-692e-4d99-a8bb-ed363dd83472
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      resize_inode dir_index filetype sparse_super
Default mount options:    (none)
Filesystem state:         not clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              17928
Block count:              71680
Reserved block count:     3584
Free blocks:              68116
Free inodes:              17917
First block:              1
Block size:               1024
Fragment size:            1024
Reserved GDT blocks:      256
Blocks per group:         8192
Fragments per group:      8192
Inodes per group:         1992
Inode blocks per group:   249
Filesystem created:       Thu Jan 29 02:59:27 2015
Last mount time:          Thu Jan 29 02:59:27 2015
Last write time:          Thu Jan 29 02:59:27 2015
Mount count:              1
Maximum mount count:      22
Last checked:             Thu Jan 29 02:59:27 2015
Check interval:           15552000 (6 months)
Next check after:         Tue Jul 28 02:59:27 2015
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:          128
Default directory hash:   tea
Directory Hash Seed:      a46ae30c-3b9f-410d-856b-1c29adc3c0b6


Group 0: (Blocks 1-8192)
  Primary superblock at 1, Group descriptors at 2-2
  Reserved GDT blocks at 3-258
  Block bitmap at 259 (+258), Inode bitmap at 260 (+259)
  Inode table at 261-509 (+260)
  7666 free blocks, 1978 free inodes, 2 directories
  Free blocks: 524-1024, 1028-8192
  Free inodes: 15-1992
Group 1: (Blocks 8193-16384)
  Backup superblock at 8193, Group descriptors at 8194-8194
  Reserved GDT blocks at 8195-8450
  Block bitmap at 8451 (+258), Inode bitmap at 8452 (+259)
  Inode table at 8453-8701 (+260)
  7683 free blocks, 1992 free inodes, 0 directories
  Free blocks: 8702-16384
  Free inodes: 1993-3984
Group 2: (Blocks 16385-24576)
  Block bitmap at 16385 (+0), Inode bitmap at 16386 (+1)
  Inode table at 16387-16635 (+2)
  7940 free blocks, 1991 free inodes, 1 directories
  Free blocks: 16636-24064, 24066-24576
  Free inodes: 3986-5976
Group 3: (Blocks 24577-32768)
  Backup superblock at 24577, Group descriptors at 24578-24578
  Reserved GDT blocks at 24579-24834
  Block bitmap at 24835 (+258), Inode bitmap at 24836 (+259)
  Inode table at 24837-25085 (+260)
  7683 free blocks, 1992 free inodes, 0 directories
  Free blocks: 25086-32768
  Free inodes: 5977-7968
Group 4: (Blocks 32769-40960)
  Block bitmap at 32769 (+0), Inode bitmap at 32770 (+1)
  Inode table at 32771-33019 (+2)
  7937 free blocks, 1988 free inodes, 1 directories
  Free blocks: 33020-33280, 33282-33792, 33795-40448, 40450-40960
  Free inodes: 7973-9960
Group 5: (Blocks 40961-49152)
  Backup superblock at 40961, Group descriptors at 40962-40962
  Reserved GDT blocks at 40963-41218
  Block bitmap at 41219 (+258), Inode bitmap at 41220 (+259)
  Inode table at 41221-41469 (+260)
  7682 free blocks, 1991 free inodes, 1 directories
  Free blocks: 41470-48640, 48642-49152
  Free inodes: 9962-11952
Group 6: (Blocks 49153-57344)
  Block bitmap at 49153 (+0), Inode bitmap at 49154 (+1)
  Inode table at 49155-49403 (+2)
  7940 free blocks, 1991 free inodes, 1 directories
  Free blocks: 49404-56832, 56834-57344
  Free inodes: 11954-13944
Group 7: (Blocks 57345-65536)
  Backup superblock at 57345, Group descriptors at 57346-57346
  Reserved GDT blocks at 57347-57602
  Block bitmap at 57603 (+258), Inode bitmap at 57604 (+259)
  Inode table at 57605-57853 (+260)
  7683 free blocks, 1992 free inodes, 0 directories
  Free blocks: 57854-65536
  Free inodes: 13945-15936
Group 8: (Blocks 65537-71679)
  Block bitmap at 65537 (+0), Inode bitmap at 65538 (+1)
  Inode table at 65539-65787 (+2)
  5892 free blocks, 1992 free inodes, 0 directories
  Free blocks: 65788-71679
  Free inodes: 15937-17928
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>address_space&#x548C;buffer_head&#x7684;&#x4E00;&#x4E9B;field</title>
      <link>https://awakening-fong.github.io/posts/field_of_bh_and_address_space</link>
      <pubDate>2016-12-30</pubDate>
      <description>&lt;h1 id="toc_0"&gt;&lt;h4&gt;1. &#x95EE;&#x9898;&#x5F15;&#x5165;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;&#x8FD9;&#x91CC;&#x4ECE;&#x4E00;&#x4E2A;&#x5730;&#x5740;&#x7A7A;&#x95F4; &#x5230;&#x53E6;&#x4E00;&#x4E2A;&#x5730;&#x5740;&#x7A7A;&#x95F4;, &#x662F;&#x4E3A;&#x5565;?&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;generic_file_fsync
{
    struct inode *inode = file-&amp;gt;f_mapping-&amp;gt;host;
    ret = sync_mapping_buffers(inode-&amp;gt;i_mapping);

}

sync_mapping_buffers(struct address_space *mapping)
{
    struct address_space *buffer_mapping = mapping-&amp;gt;private_data;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="toc_1"&gt;&lt;h4&gt;2. &#x89E3;&lt;/h4&gt;&lt;/h1&gt;

&lt;p&gt;linux-3.10.86/include/linux/fs.h&lt;/p&gt;

&lt;pre&gt;&lt;code class="c"&gt;struct address_space {

    /*
    &#x94FE;&#x8868;&#x4E0A;&#x7684;node&#x662F;buffer_head, &#x672C;field(private_list)&#x662F;&#x94FE;&#x8868;&#x7684;head:
    sync_mapping_buffers -&amp;gt;  fsync_buffers_list(,&amp;amp;mapping-&amp;gt;private_list)
    |--struct buffer_head *bh= BH_ENTRY(list-&amp;gt;next)
    &#x94FE;&#x8868;&#x4E0A;&#x7684;node  &#x53EF;&#x4EE5;&#x662F;ext2&#x67E5;&#x627E;indoe&#x8FC7;&#x7A0B;&#x7684;chain&#x6D89;&#x53CA;&#x7684; &#x7528;&#x6765;&#x5B58;&#x50A8;pointer&#x7684;&#x5757; &#x6240;&#x5BF9;&#x5E94;&#x7684;bh.


    &#x95EE;&#x9898;:&#x6DFB;&#x52A0;&#x5230;private_list&#x7684;&#x4EE3;&#x7801;?
    &#x7B54;:
    1. mark_buffer_dirty_inode
    2. &#x8FD9;&#x4E2A;&#x4E0D;&#x662F;&#x91CD;&#x70B9;:fsync_buffers_list() 
    -&amp;gt; list_add(&amp;amp;bh-&amp;gt;b_assoc_buffers, &amp;amp;mapping-&amp;gt;private_list);
    */
    struct list_head    private_list;    /* ditto */
     /*&#x6709;&#x65F6;&#x8D4B;&#x503C;&#x5728; mark_buffer_dirty_inode()
    &#x4ECE;sync_mapping_buffers&#x548C;fsync_buffers_list&#x6765;&#x770B;,
    &#x4F3C;&#x4E4E;&#x662F;&#x88F8;&#x5757;&#x8BBE;&#x5907;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;.
    */
    void            *private_data;    /* ditto */
} __attribute__((aligned(sizeof(long))));
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="c"&gt;struct buffer_head {

     /*
    &#x95EE;&#x9898;:&#x7528;&#x9014;?
    &#x7528;&#x6765;&#x8FDE;&#x63A5;chain&#x7684;&#x5757;, see
    ext2_alloc_branch -&amp;gt; mark_buffer_dirty_inode
    &#x53EF;&#x987A;&#x4FBF;see fsync_buffers_list
     */
    struct list_head b_assoc_buffers; /* associated with another mapping */
    /*&#x6709;&#x65F6;&#x8D4B;&#x503C;&#x662F;&#x5728;mark_buffer_dirty_inode(), &#x5E38;&#x89C4;&#x6587;&#x4EF6;&#x5185;&#x5BB9;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;.*/
    struct address_space *b_assoc_map;    /* mapping this buffer is
                           associated with */

};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="c"&gt;/*
&#x8C03;&#x7528;&#x8DEF;&#x5F84;ext2_alloc_branch()
&#x8BE5;@inode&#x7684; chain&#x4E0A; &#x7528;&#x6765;&#x5B58;&#x50A8;pointer&#x7684;&#x5757;, @bh&#x4E0E;&#x4E4B;&#x5173;&#x8054;, &#x5BF9;&#x5417;?

*/
void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)
{

    struct address_space *mapping = inode-&amp;gt;i_mapping;//&#x8FD9;&#x4E2A;&#x662F;&#x6587;&#x4EF6;&#x5185;&#x5BB9;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;
    /*&#x8FD9;&#x4E2A;&#x662F;&#x88F8;&#x5757;&#x8BBE;&#x5907;&#x7684;&#x5730;&#x5740;&#x7A7A;&#x95F4;, see 
    ext2_alloc_branch
    |--bh = sb_getblk()
    |--mark_buffer_dirty_inode
    */
    struct address_space *buffer_mapping = bh-&amp;gt;b_page-&amp;gt;mapping;

    mark_buffer_dirty(bh);
    if (!mapping-&amp;gt;private_data) {
        mapping-&amp;gt;private_data = buffer_mapping;
    } else {
        BUG_ON(mapping-&amp;gt;private_data != buffer_mapping);
    }
    if (!bh-&amp;gt;b_assoc_map) {
        spin_lock(&amp;amp;buffer_mapping-&amp;gt;private_lock);
        list_move_tail(&amp;amp;bh-&amp;gt;b_assoc_buffers,
                &amp;amp;mapping-&amp;gt;private_list);
        bh-&amp;gt;b_assoc_map = mapping;
        spin_unlock(&amp;amp;buffer_mapping-&amp;gt;private_lock);
    }
}
EXPORT_SYMBOL(mark_buffer_dirty_inode);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="c"&gt;/**
 *    ext2_alloc_branch - allocate and set up a chain of blocks.
&#x95EE;&#x9898;:&#x4EC0;&#x4E48;&#x662F;branch?
&#x7B54;:&#x4ECE;&#x7684;&#x539F;&#x578B;ext2_alloc_branch(, Indirect *branch),
&#x53EF;&#x77E5;branch&#x5C31;&#x662F;Indirect, &#x5BF9;&#x5417;?

 *    @inode: owner
 *    @num: depth of the chain (number of blocks to allocate)
&#x8FD9;&#x4E2A;&#x53C2;&#x6570;(@num)&#x5728;3.10&#x4E2D;&#x4E0D;&#x89C1;&#x4E86;, &#x5E94;&#x8BE5;&#x5C31;&#x662F;3.10&#x7684;@indirect_blks
fong:&#x4ECE;&#x4E00;&#x4E2A;pointer &#x8DF3;&#x5230;&#x6700;&#x540E;&#x7684;data block&#x7684;&#x8DEF;&#x5F84;&#x79F0;&#x4E3A;chain, 
&#x8BE5;&#x8FC7;&#x7A0B;&#x4F7F;&#x7528;&#x7684;pointer&#x7684;&#x4E2A;&#x6570; &#x79F0;&#x4E3A;depth, 
&#x6BD4;&#x5982;, &#x6587;&#x4EF6;&#x504F;&#x79FB;&#x91CF;&#x4E3A;6&#x7684;, depth&#x4E3A;1, 
&#x6216;&#x8005;&#x8BF4; &#x65E0;&#x9700;indirect, &#x5219;depth&#x4E3A;1.


 *    @offsets: offsets (in the blocks) to store the pointers to next.
offset&#x542B;&#x4E49;:&#x5728;&#x5355;&#x4E2A;&#x5757;&#x5185;, &#x5B58;&#x50A8;pointer&#x7684;&#x4F4D;&#x7F6E;, &#x7528;&#x76F8;&#x5BF9;&#x4E8E;&#x8BE5;block&#x5F00;&#x5934;&#x7684;&#x504F;&#x79FB;&#x91CF;&#x6765;&#x8868;&#x793A;&#x7684;&#x503C;, &#x5C31;&#x662F;offset.
&#x6BD4;&#x5982;, &#x4E0B;&#x9762;&#x7684;&#x793A;&#x610F;&#x56FE;, &#x5BF9;&#x4E8E;block0, offsets&#x4E3A;1; &#x5BF9;&#x4E8E;block1, offsets&#x4E3A;2.
+---+                
|-- |   +---+         
|-- |\-&amp;gt;|-- |     |-- |         
|-- |   |-- |     |-- |         
+---+   |-- |\--&amp;gt; |-- |
        |-- |     |-- |
        +---+     +---+              
block0    block1    data block

 */


static int ext2_alloc_branch(struct inode *inode,
            int indirect_blks, int *blks, ext2_fsblk_t goal,
            int *offsets, Indirect *branch)
{
...
        bh = sb_getblk(inode-&amp;gt;i_sb, new_blocks[n-1]);
...
        mark_buffer_dirty_inode(bh, inode);

}


fsync_buffers_list
{
    while (!list_empty(list)) {


    }
    while (!list_empty(&amp;amp;tmp)) {
            if (buffer_dirty(bh)) {
            /*
            &#x7531;&#x4E8E;write_dirty_buffer&#x5728;&#x5199;&#x5165;&#x524D;, &#x4F1A;&#x6E05;&#x6389;bh&#x7684;dirty,
            &#x5230;&#x8FD9;&#x91CC;&#x51FA;&#x73B0;dirty&#x7684;&#x8BDD;, &#x5927;&#x6982;&#x662F;&#x5199;&#x5165;&#x5B8C;&#x6210;&#x540E;, &#x53C8;&#x88AB;&#x4EBA;&#x91CD;&#x65B0;dirty&#x4E86;.
            &#x7B49;&#x5F85;&#x4E0B;&#x56DE;generic_file_fsync -&amp;gt; sync_mapping_buffers
            -&amp;gt; sync_mapping_buffers -&amp;gt; fsync_buffers_list &#x5199;&#x5165;.
            */
            list_add(&amp;amp;bh-&amp;gt;b_assoc_buffers,
                 &amp;amp;mapping-&amp;gt;private_list);
            bh-&amp;gt;b_assoc_map = mapping;
            }
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
  </channel>
</rss>
